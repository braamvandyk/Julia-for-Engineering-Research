---
title: "Solving Differential Equations"
---

## ODEs and PDEs

The [DifferentialEquations](https://docs.sciml.ai/DiffEqDocs/stable/) package is a very powerful toolkit for solving differential equations. It has multiple, state of the art solvers for oridinary differential equations. It can also handle stochastic differential equations, random differential equations, delay differential equations, differential algebraic equations, stochastic differential algebraic equations etc.

Should you wish to solve partial differential equations, you will need to convert the PDE to a set of ODEs. This can be done via the method of lines ([MethodOfLines.jl](https://github.com/SciML/MethodOfLines.jl)), or via several other advanced tools in Julia, including [Trixi.jl](https://trixi-framework.github.io/Trixi.jl/stable/) or several other finite element methods [see JuliaFEM](http://www.juliafem.org/).

Here we shall focus on the most common applications in process modelling: ordinary differential equations and using the method of lines to solve partial differential equations.

## Solving a Plug Flow Reactor Model

For our ODE example, we take a simple PFR model and a rate equation.

$$ A + B \rightarrow C$$

with the reaction proceeding in the gas phase over a catalyst with the following rate equation:

$$-r_A = k_o exp \Big[\frac{E_a}{R}(1/T - 1/T_o)\Big] P_A P_B$$
$$[-r_A] = kmol/h/kg$$

We also have the following data:

| Parameter | Value            |
|:----------|:----------------:|
| $k_o$     | $0.5 \frac{kmol}{h.kg.bar^2}$|
| $E_a$     | $100\ J/mol$     |
| $T_o$ | $500\ K$          |
| $R$       | $8.314\ J/mol/K$ |

The feed stream entering the reactor has 60kmol/h of A and 40kmol/h of B. The reactor is isothermal at 510K. The inlet pressure is 10bar(abs) and the pressure drop is 1bar. Calculate the composition profile for the reactor. 

In order to solve the problem, we need to tell the solver what the set of ODEs is for each of the molar flows. We already know the equation for the rate of change for A as it flows over the catalyst. Stoichiometry gives us the rate of change for B and C.

We package this information into a function, `rates(u, p, t)`, which is what we will supply to the solver.

The differential equation solver will accept two forms of functions:

`rates(u, p, t)` is a function that takes the current values of the dependent variable(s), model parameter(s), `p` and the current value of the independent variable, `t`, and then returns the differential(s) of the dependent variable(s) at that point.

`u` can be a vector or a scalar. `p` should be any iterable type, but is usually passed as a tuple, since this will give faster code than passing a vector.

The alternative form, called the in-place form, is `rates!(du, u, p, t)`. In this case, `du` is a scalar or vector that holds the derivative(s) and is updated in the function. This in-place version typically results in faster code, as there are fewer memory allocation needed. This should be your default form for specifying ordinary differential equations.

```julia
using DifferentialEquations, Plots

"""
The reactions rates for A + B -> C
    u:  array with the molar flows of A, B and C
    p:  tuple with P and T
    t:  position in the reactor 0..L
"""
function rates!(du, u, p, t)
    k₀ = 0.50
    Eₐ = 100.0
    T₀ = 500.0
    R = 8.314
    
    # Convert molar flows to molar fractions
    y = u ./ sum(u)

    # Unpack the tuple to get pressure and temperature
    P, ΔP, T = p

    k = k₀ * exp(-Eₐ/R * (1/T - 1/T₀))
    rA = -k * y[1] * y[2] * P^2
    rB = rA
    rC = -rA

    du[1] = rA
    du[2] = rB
    du[3] = rC
end

# Set up the input values and pack into a tuple of parameters
T = 510.0
P = 10.0
ΔP = 1.0
p = (P, ΔP, T)

# The starting values for the initial value problem
u₀ = [60.0, 40.0, 0.0]

# The span over which to integrate - here the mass of catalyst
tspan = (0.0, 20.0)

# Create the ODEProblem object
prob = ODEProblem(rates!, u₀, tspan, p)

# Solve with the default solver
sol = solve(prob)

# Plot the result - the molar flows vs the mass of catalyst
plot(sol, leg=:right)
```
![The plot of `sol.u` vs `sol.t`, generated by `plot(sol)](img/ODEmol.svg)

The default plot recipe (defined by the DifferentialEquations package) will plot each of the dependent varaiables against the independent variable. All we need to do is call `plot(sol)`. Here, the default placement of the legend was interfering with the lines, so we move it to the right centre, by adding `leg = :right`) to the call to `plot()`.

Now we have solved the set of three differential equations and we have the molar flows of each component at various points along the length of the reactor. The points were set by the variable set-size solver. There are *many* options you can pass the solver, including fixed steps at which to record the values. See the [documentation](https://docs.sciml.ai/DiffEqDocs/stable/) for details.

Part of what is returned in the `sol` structure is an interpolator. If we want to have the molar flows at **any** point in the reactor, we need only call `sol(x)` to get the values of the dependent variables  (`sol.u`) at a value `x` of the independent variable (`sol.t`). `sol` is a callable structure, sometimes called a *functor*.

```julia
julia> sol(5.123)
3-element Vector{Float64}:
 28.21896144058894
  8.218961440588943
 31.78103855941106
```
The original question however was for the composition, which is generally interpreted as the fractions of the components, not their flows. Let's convert the results to molar fractions:

```julia
# Now, we want to plot the molar fractions...
# Copy over the independent values (sol.t) into our x array (optional)
x = sol.t

# For each entry in sol.u, sum up the molar flows - we get an array of values
# with the total molar flow at every point in the reactor
totflows = sum.(sol.u)

# Now divide the individual flows with the total. 
fracs = sol.u ./ n

# We get the same structure as sol.u - an array of arrays.
# We need to flatten this to plot it.
y = hcat(fracs...)'
plot(x,y, labels=["A" "B" "C"])
```
![The plot of molar fractions in the reactor profile](img/ODEfrac.svg)

The last bit of code in this part will need some explanation. As mentioned above, 
the solution returned by the ODE solver is a structure, `sol` with multiple fields, including `sol.t` for the independent variable. This will hold the values for each step taken by the solver. The results for the dependent variables, `u[...]` are in `sol.u`, for each the steps in `t`. This means that `sol.u` is an array of arrays:

```julia
julia> sol.u
17-element Vector{Vector{Float64}}:
 [60.0, 40.0, 0.0]
 [59.99858583756605, 39.99858583756605, 0.001414162433950248]
 [59.98444659631364, 39.98444659631364, 0.015553403686357834]
 [59.84329235637935, 39.84329235637935, 0.15670764362064588]
 [58.455429083342196, 38.455429083342196, 1.544570916657804]
 [53.856423524473534, 33.856423524473534, 6.143576475526465]
 [46.98711817371082, 26.987118173710822, 13.012881826289178]
 ⋮
 [23.183086441910287, 3.18308644191029, 36.81691355808971]
 [21.75465210851499, 1.7546521085149929, 38.245347891485004]
 [20.925564799269747, 0.9255647992697497, 39.07443520073025]
 [20.469163592127106, 0.4691635921271096, 39.53083640787289]
 [20.229681690060957, 0.22968169006096079, 39.770318309939036]
 [20.118457320604698, 0.11845732060470164, 39.881542679395295]
```
We can to convert these to molar fractions, which means we need to divide each entry of the sub-arrays by the sum of that sub-array. This is very easy in Julia. We just do this:

```julia
totflows = sum.(sol.u)
fracs = sol.u ./ totflows
```

We *broadcast* the `sum()` function over `sol.u` by inserting a period between the function name and the first parenthesis - `sum.()`. This means the function is applied individually to each element in `sol.u`. Since each entry of `sol.u` is an array, we therefore get the an array of the total molar flows at each point in the reactor.

Now we want to divide each entry in each sub-array in `sol.u` with this sum to get the molar fractions ar each point. We do this by broascasting again. For functions the period is inserted between the function name and the parenthesis, but for operators, the period is put in front of the operator. The broadcasted, or element-wise, division will divide each entry in `fracs` (an array of molar flows) by the corresponding entry in `totflows`. The result in an array of arrays, just like `sol.u`, but with the molar fractions instead of molar flows.

```julia
julia> totflows
17-element Vector{Float64}:
 100.0
  99.99858583756604
  99.98444659631363
  99.84329235637935
  98.4554290833422
  93.85642352447353
  86.98711817371081
   ⋮
  63.18308644191029
  61.75465210851499
  60.92556479926975
  60.4691635921271
  60.22968169006096
  60.11845732060469

julia> fracs
17-element Vector{Vector{Float64}}:
 [0.6, 0.4, 0.0]
 [0.5999943432702689, 0.3999915149054033, 1.4141824327869601e-5]
 [0.5999377767074147, 0.39990666506112205, 0.0001555582314632852]
 [0.5993721855923528, 0.3990582783885293, 0.0015695360191177955]
 [0.593724791284591, 0.3905871869268865, 0.0156880217885225]
 [0.5738171294203449, 0.36072569413051736, 0.06545717644913773]
 [0.5401617982087747, 0.31024269731316206, 0.1495955044780633]
 ⋮
 [0.3669191827661746, 0.050378774149261896, 0.5827020430845635]
 [0.35227551877853375, 0.02841327816780064, 0.6193112030536656]
 [0.34346115408552697, 0.015191731128290557, 0.6413471147861823]
 [0.338505816455383, 0.0077587246830745525, 0.6537354588615425]
 [0.33587562016618194, 0.00381343024927297, 0.6603109495845451]
 [0.33464693236081094, 0.0019703985412164293, 0.6633826690979727]
```

The plotting library expects you to pass the x-values as an array and when there are multiple y-values, these should be in a matrix where each column is a series. We therefore need to convert the array of arrays into a matrix.

This is done with `y = hcat(fracs...)'`, which uses two new Julia concepts.

The first is *splatting*. If a function, say `f(a, b, c)` takes three scalar parameters, we can *splat* an array into the function by calling `f(d...)`, where d is an array. The first entry in `d` will be passed into `a`, the second into `b` and the rest of the array into `c`. If `d` had only three entries, `c` will be a scalar, else `c` will be a vector.

The opposite of splatting is *slurping*, when multiple scalars are slurped up into a single array parameter. It uses the same syntax of an ellipsis.

What happens here is that the `hcat()` function (horizontal concatenation) expects a series of values that will be concatenated as the rows of a new array. We pass it the fracs variable, which is an array of arrays, and we splat it. This means that `hcat()` gets a series of inputs, one for each row in `fracs`. These are then concatenated as follows:

```julia
julia> hcat(fracs...)
3×17 Matrix{Float64}:
 0.6  0.599994    0.599938     0.599372    0.593725  0.573817   0.540162  0.500565  0.458581  0.420309  0.389287   0.366919   0.352276   0.343461   0.338506    0.335876    0.334647
 0.4  0.399992    0.399907     0.399058    0.390587  0.360726   0.310243  0.250847  0.187872  0.130463  0.0839301  0.0503788  0.0284133  0.0151917  0.00775872  0.00381343  0.0019704
 0.0  1.41418e-5  0.000155558  0.00156954  0.015688  0.0654572  0.149596  0.248588  0.353547  0.449229  0.526783   0.582702   0.619311   0.641347   0.653735    0.660311    0.663383
 ```

 Why use `hcat()` and not `vcat()`? Remember that a 1D array in Julia is considered to be a column vector. This means `fracs` is a column vector where each entry is also a column vector. If we `vcat` fracs, these individual column vectors get appended to each other in one long column vector and we lose the distinction between the individual points along the reactor:

 ```julia
 julia> vcat(fracs...)
51-element Vector{Float64}:
 0.6
 0.4
 0.0
 0.5999943432702689
 0.3999915149054033
 1.4141824327869601e-5
 0.5999377767074147
 ⋮
 0.33587562016618194
 0.00381343024927297
 0.6603109495845451
 0.33464693236081094
 0.0019703985412164293
 0.6633826690979727
 ```

 But the `hcat(fracs...)` call horizontally concatenated the sub-arrays (column vectors), making each series a row of the matrix. We need each series to be a column. We get that by transposing the result with the `'` appended to the end. `A'` is the transposed version of a real matrix, `A`

::: {.callout-important}
`A'` is technically the **adjoint** matrix. This means it is the transpose of the matrix of complex conjugates. For real values, however, this makes not difference. For complex values, you need to call `transpose()`, rather than use the adjoint operator. 
:::

```julia
julia> y = hcat(fracs...)'
17×3 adjoint(::Matrix{Float64}) with eltype Float64:
 0.6       0.4         0.0
 0.599994  0.399992    1.41418e-5
 0.599938  0.399907    0.000155558
 0.599372  0.399058    0.00156954
 0.593725  0.390587    0.015688
 0.573817  0.360726    0.0654572
 0.540162  0.310243    0.149596
 ⋮
 0.366919  0.0503788   0.582702
 0.352276  0.0284133   0.619311
 0.343461  0.0151917   0.641347
 0.338506  0.00775872  0.653735
 0.335876  0.00381343  0.660311
 0.334647  0.0019704   0.663383
```

Finally we get:

```julia
julia> y = hcat(fracs...)'
17×3 adjoint(::Matrix{Float64}) with eltype Float64:
 0.6       0.4         0.0
 0.599994  0.399992    1.41418e-5
 0.599938  0.399907    0.000155558
 0.599372  0.399058    0.00156954
 0.593725  0.390587    0.015688
 0.573817  0.360726    0.0654572
 0.540162  0.310243    0.149596
 ⋮
 0.366919  0.0503788   0.582702
 0.352276  0.0284133   0.619311
 0.343461  0.0151917   0.641347
 0.338506  0.00775872  0.653735
 0.335876  0.00381343  0.660311
 0.334647  0.0019704   0.663383
```
::: {.callout-note}
Note that the type returned is an adjoint(::Matrix{Float64}). This is a *lazy* structure. It just maps onto the original matrix, rather than recalculate it.
:::

Now we have each series as a column and we pass the series labels as a **row vector** (with spaces between the entries, not commas), since each series must also be a column in the `labels` parameter.
