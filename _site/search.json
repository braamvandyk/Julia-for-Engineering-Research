[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia for Engineering Research",
    "section": "",
    "text": "This is an introductory course to using the Julia programming language for technical programming.\nIt assumes some nominal programming background and knowledge of the engineering sciences and numerical methods to fully appreciate the examples.\nThis is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About the Course",
    "section": "",
    "text": "This is an introductory course to using the Julia programming language for technical programming. It assumes some nominal programming background and knowledge of the engineering sciences, specifically in chemical engineering."
  },
  {
    "objectID": "Getting_started_with_Julia.html",
    "href": "Getting_started_with_Julia.html",
    "title": "Getting Started with Julia",
    "section": "",
    "text": "There are a vast number of articles on the internet on the topic of why you would want to use Julia. I’ll briefly explain why I prefer programming in Julia and think you may too.\nEveryone who either programs seriously, or merely dabbles in code likely has a personal favourite programming language. It may be that they only know one language. Professional programmers often have more than one language they work in, and often prefer a certain tool for specific tasks. It is a simple fact that some languages are better for certain tasks than others for various reasons.\nJulia was conceived with technical programming in mind. It has its origins in academia, being developed at MIT, and is still mostly used by researchers, in natural and engineering sciences, computer science, mathematics, machine learning and many other fields. Commercial software written in Julia is available, e.g. Pumas for pharmaceutical drug discovery, or TIM for automatically building predictive models from time-series data. The bulk of work done in Julia, however, is in research and development, in academia, but also at approximately 10,000 companies and institutions world-wide, including AstraZeneca, BlackRock, Google, Intel, Microsoft, Moderna, Pfizer, NASA, the Federal Aviation Adminstration and the Federal Reserve Bank of New York to name a few. Julia is taught in over 1,500 universities, including MIT, Stanford and UC Berkley.\nJulia was designed to solve the so-called two language problem. This is where a researcher develops algorithms in a dynamic language, such as Python or R, where it is easy to interact with the code and change things around with little effort. At some point however, they find the need to speed up the code as it becomes more complex. This often results in a rewrite of the program in a fast language, such as C or Fortran. Julia is a dynamic language, but generates code as fast as anything you can do in C, without the arcane syntax and multiple built-in ways to shoot yourself in the foot. This doesn’t imply that your Julia code is always fast. It is possible to write slow code in any language. It is just a whole lot easier to write fast code in Julia. When you run into speed problems in Python or R, the only solution is to call libraries written in C, with Python or R wrappers. In Julia, your fast code is usually 100% Julia code - you don’t need to know a second, fast language. In addition, Julia plays well with C, Python and R and you can call code written in any of these directly from Julia and vice versa.\nJulia is open-source and free. There are thousands of packages available in Julia - also open-sourced and free. Since Julia was developed for technical programming, most of these packages similarly are for solving technical problems. There are however also many others, from web development to animation and just about anything in between. Linear algebra is baked right into the language, including working with sparse matrices, so is parallel programming - multithreading and multiprocessing. There are very powerful differential equation solvers, non-linear equation solvers, optimisers, machine learning libraries, and even thermodynamic property libraries readily and freely available.\nJulia’s syntax is borrows the best parts from Matlab, Python and Lisp. A lot of effort has gone into making it easier to learn the syntax. That said, there is always some learning curve when venturing into a new programming language. Like you can only learn to ride a bicycle by climbing on one and starting to pedal, the only way to learn programming and programming languages is to write code.\n\n\nThe defining paradigm in Julia is multiple dispatch. Unless you are a computer scientist, that probably doesn’t mean much to you. I’ll try to explain simply with some examples.\nHere is a little Julia code. Don’t worry if you don’t know the syntax yet. We are just defining a function thats takes two inputs a and b and returns 2b + a. Note that we don’t need a multiplication sign between the 2 and b in Julia - the language attempts to follow standard mathematical syntax where possible. You can also use any Unicode symbols, like Greek letters, subscripts and superscripts for variable names. Just don’t get carried away with those.\nfunction myfunc(a, b)\n    return 2b + a\nend\nWe enter the code at the Julia REPL (we’ll get to this soon) and call it:\njulia> function myfunc(a, b)\n           return 2b + a\n       end\nmyfunc (generic function with 1 method)\n\njulia> myfunc(1, 2)\n5\n\njulia> myfunc(1.0, 2.0)\n5.0\nThe first thing to notice is that unlike in languages like C, Basic, Pascal or Fortran, we never specified the types of the variable, i.e. whether they are integers or floating point values (numbers with fractional parts). There are times when you want to do this, but generally you would not. However, when we called the function with two integers, the answer was returned as an integer. When we called the code with two floating point values, the answer was returned as a floating point value.\nWhat happened behind the scenes? Julia infers the types of all of the inputs and generates the optimal code for that collection of input types. We can see this in action by asking Julia to show us the code it generated1:\njulia> @code_llvm myfunc(1, 2)\n;  @ REPL[1]:1 within `myfunc`\n; Function Attrs: uwtable\ndefine i64 @julia_myfunc_172(i64 signext %0, i64 signext %1) #0 {\ntop:\n;  @ REPL[1]:2 within `myfunc`\n; ┌ @ int.jl:88 within `*`\n   %2 = shl i64 %1, 1\n; └\n; ┌ @ int.jl:87 within `+`\n   %3 = add i64 %2, %0\n; └\n  ret i64 %3\n}\nMost of what you see here is going to look like hieroglyphics, but don’t worry. You can ignore any line that starts with a semi-colon. These are automatically generated comments. The first line of actual code is:\ndefine i64 @julia_myfunc_172(i64 signext %0, i64 signext %1) #0 {\nThis defines a function (with a unique name - you’ll understand later why this is done) that returns a type i64, a 64-bit integer, and accepts two inputs, %0 amd %1, both of type i64.\nThe next line is:\n%2 = shl i64 %1, 1\nThis shifts the value in %1 left by one bit and stores the result in a new variable, %2. If you know binary numbers2, you will know that this means the value is multiplied by two, just like shifting a decimal number left by one position multiplies the value by ten.\nThe next line is:\n%3 = add i64 %2, %0\nThis creates a new variable, %3 and writes into this variable the result of adding %2 and %0.\nFinally, we have\nret i64 %3\nThis returns the value in %3, as an i64, a 64-bit integer.\nWithout breaking your head about the details, you should appreciate that this is code that is optimised for the case where we passed two integers, including using a shl (shift left) operation, rather than the machine multiplication instruction, as the former is faster.\nNow let’s see what we get when we pass to 64-bit floating-point values.\njulia> @code_llvm myfunc(1.0, 2.0)\n;  @ REPL[1]:1 within `myfunc`\n; Function Attrs: uwtable\ndefine double @julia_myfunc_191(double %0, double %1) #0 {\ntop:\n;  @ REPL[1]:2 within `myfunc`\n; ┌ @ promotion.jl:389 within `*` @ float.jl:385\n   %2 = fmul double %1, 2.000000e+00\n; └\n; ┌ @ float.jl:383 within `+`\n   %3 = fadd double %2, %0\n; └\n  ret double %3\n}\nThe function definition looks similar to the previous case, expect that we now have variables of type double, rather than i64.\nThe next line:\n%2 = fmul double %1, 2.000000e+00\nSince we can’t simply shift a floating point value left by one bit to multiply it by two, the fmul instruction, floating point multiplication, is used to multiply the value in %1 by 2.0. Then, in the next line, the fadd (floating point addition) instruction adds the result from the multiplcation to %0:\n%3 = fadd double %2, %0\n\n\n\n\n\n\nNote\n\n\n\nThe important thing to learn from this is that Julia built optimised versions of the function for each case. Similarly, is we pass an integer and a floating point value, or vice versa, or any two other appropriate types of values, new versions of the functon will be constructed and each will be optimised for that combination of types passed.\n\n\nIt goes evern further.\njulia> A = [1 2;\n            3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> B = [5 6;\n            7 8]\n2×2 Matrix{Int64}:\n 5  6\n 7  8\n\njulia> myfunc(A, B)\n2×2 Matrix{Int64}:\n 11  14\n 17  20\nHere we defined to 2x2 matrices of 64-bit integers and passed those to our function. And it just works! More so, the code was again optimised for handling these types of variables.\nThis is how Julia generates fast code. The original function we defined without specifying variable types is called a generic function. Julia then builds specialised version of the function based on the types of the variables we passed. Whenever we call the function, Julia checks if it has already compiled an appropriate version and then calls that version. If not, it compiles a new, specialised version to use.\nThis allows you to generate the fastest possible code, but for large pieces of code, this also results in a delay while the code is compiled. This is called TTFX (Time to First X) or often just Time to First Plot, as this is especially noticable when calling the various plotting libraries in Julia. The first time to call a plotting function, there is a considerable delay. Every time after that, the plotting is lightning fast.\njulia> @time using Plots\n  6.401451 seconds (8.83 M allocations: 612.705 MiB, 2.67% gc time, 11.00% compilation time: 3% of which was recompilation)\n\njulia> @time scatter(randn(10), randn(10))\n  1.152227 seconds (93.64 k allocations: 4.612 MiB, 99.65% compilation time)\n\njulia> @time scatter(randn(10), randn(10))\n  0.000392 seconds (414 allocations: 43.344 KiB)\nIt takes 6.4 seconds to import the Plots package. The first time we call scatter to generate a scatter plot, the code is compiled, which takes 1.15 seconds. The next time however, the compiled code is already available and it takes 0.4 milliseconds to generate the plot. Every subsequent call to scatter with the same types of values passed to it, will also be fast.\nIn every new version of the Julia compiler, some work is included to reduce he latency of TTFX. The next version of Julia at the time of writing, v1.9, will include several new features to significantly reduce the problem. This is not magic though, merely a toolset that allows package authors to increase the amount of code that is precompiled when the package is first installed. This will only help of the tools are used. Since the Julia community is generally very enshusiastic about speed, it is reasonable to expect most, if not all of them will indeed do so.\n\n\n\nSome of the people reading this document will be experienced programmers and some will be masters of numerical methods. Most of you won’t be either, but still want to solve a technical problem. Here Julia is your friend.\nAny commonly-used numerical methods you are likely to want to use is already available in a package, generally written by people with PhDs in the relevant field and optimised to the nth degree by researchers who needed this before you did and contributed to the openly available source code. Sometimes, the methods are already built into Julia, as is the case for linear algebra.\nLet’s say you want to factorise a matrix. You could pull your linear algebra text book and your numerical methods notes off the shelf and remind yourself which factorisation methods are best-suited to your type of matrix and how that methods works, then code your own copy. Or you could just let Julia take care of it for you:\njulia> A = rand(5, 5) #create a random matrix\n5×5 Matrix{Float64}:\n 0.80492   0.282962  0.470656  0.947669   0.185726\n 0.201024  0.65166   0.827719  0.759129   0.597441\n 0.391872  0.829147  0.437748  0.0278852  0.0868745\n 0.583262  0.934832  0.187209  0.771838   0.373839\n 0.424062  0.973599  0.7794    0.917351   0.0827884\n\njulia> B = A*A' #create a symmetric matrix by multiplying A with its transpose\n5×5 Matrix{Float64}:\n 1.88205   1.56614  0.798632  1.62299  1.86838\n 1.56614   2.0834   1.0545    1.69067  2.11067\n 0.798632  1.0545   1.041     1.13963  1.34739\n 1.62299   1.69067  1.13963   1.98464  2.0424\n 1.86838   2.11067  1.34739   2.0424   2.58357\n\njulia> factorize(A)\nLU{Float64, Matrix{Float64}, Vector{Int64}}\nL factor:\n5×5 Matrix{Float64}:\n 1.0       0.0        0.0        0.0       0.0\n 0.526837  1.0        0.0        0.0       0.0\n 0.724621  0.885107   1.0        0.0       0.0\n 0.486846  0.83853    0.379704   1.0       0.0\n 0.249744  0.70464   -0.537792  -0.110424  1.0\nU factor:\n5×5 Matrix{Float64}:\n 0.80492  0.282962   0.470656   0.947669   0.185726\n 0.0      0.824524   0.531441   0.418083  -0.0150591\n 0.0      0.0       -0.62422   -0.284911   0.252587\n 0.0      0.0        0.0       -0.675877  -0.0868263\n 0.0      0.0        0.0        0.0        0.68792\n\njulia> factorize(B)\nCholesky{Float64, Matrix{Float64}}\nU factor:\n5×5 UpperTriangular{Float64, Matrix{Float64}}:\n 1.37188  1.1416    0.582145  1.18304   1.36191\n  ⋅       0.883262  0.441459  0.385059  0.62939\n  ⋅        ⋅        0.712192  0.394468  0.38853\n  ⋅        ⋅         ⋅        0.53026   0.0671023\n  ⋅        ⋅         ⋅         ⋅        0.420928\nFor the sake of examples, we create a random 5x5 matrix, A and then multiply it by its transpose to create a symmetrix matrix, B. We then ask Julia to factorise both, by calling the factorize() function (note the American spelling!).\nFor the square, random matrix, LU decomposition is the most appropriate method and that is what we get. For the symmetrix matrix, Cholesky’s methods is the most efficient and hence that is what Julia uses. It will also use other specialised methods for other specific matrix types. See the manual for details. When you use the factorised matrix in computations, further specialised, optimised methods will be used, depending on the factorisation that was used. You can of course just call specific factorisation methods, such as lu() or qr() as well.\nAlso note that the Cholesky factorisation returns a specialised type of matrix, UpperTriangular{Float64, Matrix{Float64}}, which also has specialised calculations methods that take advantage of knowledge of the structure of the matrix.\nIn a similar fashion, when solving differential equations, the DifferentialEquations.jl package can automatically select algorithms. You can help it along by supplying a hint that the problem is stiff, or you can specify which methods you want to use. For stiff problems, implicit methods are available and the package will use automatic differentiation to generate the higher level derivaties needed for these with low overheads.\nThese things don’t happen through magic, although it may look like it. The code, either in the Julia standard library or an a user-supplied package, was simply written by experts in the field. This means you can get away with knowing a little less about the intracacies of the mathematics than you would be able to if you had to write everything yourself. This by no means implies you shouldn’t learn more about the mathematics and numerical methods! More knowledge will always give better results.\n\n\n\nJulia has several powerful plotting libraries available for data visualisation. You can use Plots.jl as a unified front-end for several plotting engines, like GR, Plotly or PyPlot. You may prefer to use Makie - a Julia-specific plotting library with that gives you extreme control over every aspect of the plot, including interactivity. You may prefer to add statistical analyses to the plot via GadFly.jl or AlgebraOfGraphics.jl.\n\n\n\nA Makie generated plot.\n\n\n\n\n\nAn AlgebraOfGraphics generated plot.\n\n\nJulia has one of the fastest tools for reading data files, in CSV.jl, or you can prefer to manipulate your Excel files directly from Julia with XLSX.jl. Tabular data can be easily handled with DataFrames.jl and you can even execute SQL-like queries on the data via Query.jl. If you need to add units to your numbers, then Unitful.jl is for you.\n\n\n\nThere are likely Julia packages for any task you wish to attempt. And if there isn’t a Julia-specific package, there is probably a wrapper for a Python or C library.\nBecause of Julia’s generic code, code re-use is Julia is more more common than in any other language, as was illustrated when we passed matrices to your little example function before. It is often possible to combine packages that have little if anything to do with each other to solve a problem.\nWriting generic code is encouraged in the Julia ecosystem specifically to enable this. Rather than needing some all-encompasing package to solve your problem, you simply combine a few smaller, simpler and more easily optimised packaged to get the result you need.\n\n\n\nThere are of course instances where Julia is not the optimal choice.\nIf you want to compile a model to a binary file, Julia is likely not the best tool. While it is perfectly possible to compile Julia code to, e.g. a DLL file, the dynamic nature of Julia means that the entire Julia run-time is included in the file. This means a VERY large file is produced. This is an area of active development, and it is possible in some cases to compile small files, but at this time, there are better tools.\nIf you want to distribute your code to other people, but do not want to give them access to the source code, Julia may not be your first choice. It is again possible, and one way of doing this is by running your code on a server and giving the users access via a web page or Excel front-end, but it is not as simple as just compiling a DLL or EXE file in C or Visual Basic.\nIf you need to create a user interface with minimal effort, Excel is probably a better choice, especially if you intend to distribute the code. It is however possible (and not too difficult) to use Excel as a front-end for Julia code too."
  },
  {
    "objectID": "Installing_Julia.html",
    "href": "Installing_Julia.html",
    "title": "Installing Julia",
    "section": "",
    "text": "To use Julia, you need two things:\n\nThe Julia compiler\nA code editor\n\nIt is also recommended that you consider a few additional tools, although they are optional.\n\n\nWhile not strictly required, installing Windows Terminal is highly recommended. Windows Terminal is a much more modern replacement for the venerable Windows command prompt. It has the same features as a typical Linux terminal and will make your experience of the Julia REPL a lot more pleasant.\nIf you are going to use Windows Terminal, install it first, from the Microsoft Store. If you then install Julia or Git, they will automatically configure themselves in Windows Terminal.\n\n\n\nThere are several ways to install Julia on your machine, whether or not you have local administrator rights. Julia will happily run from a user-only installation, or you can install it for all users on your machine. You can also use a portable (not installed) version.\n\n\nYou can download and install Julia from the official homepage. The 64-bit version is recommended, unless you have a specific reason to want a 32-bit version.\n\n\n\nThe recommended way of installing Julia, if this is an option for you, is via the Microsoft Store. Installing Julia this way actually installs JuliaUp, an installation manager for Julia.\nJuliaUp allows you to have multiple installations of Julia, e.g. the current release version as well as the current development (pre-release) version.\nYou can easily switch between them with a single command-line instruction. JuliaUp will also automatically keep your Julia installation updated when a new version is released.\n\n\n\n\nThe recommended code editor for Julia is Visual Studio Code (VSCode). This is a Microsoft project that is free and partially open-sourced. You can download and install it from the official homepage or via the Microsoft Store.\nVSCode will prompt you to install updates, so there is less reason to want to install this from the Microsoft Store. New releases are typically available monthly.\n\n\nVSCode is a general-purpose code editor. To use it with Julia, you need to install the Julia add-in from within VSCode. You can also install Python, R, C, Fortran and many other add-ins.\nIf you are adventurous, you can install the insider version of the Julia add-in, but this is not recommended for for typical end-users.\nThe Julia add-in not only links Julia to VSCode seamlessly, it also provides a debugger and many other tools, like compiling system images for quicker start-up.\nSee the documentation for more information.\n\n\n\nSome add-ins recommended for everyday use are: - Edit CSV - Rainbow CSV - SandDance for VSCode - SVG\nEdit CSV allows for easy editing CSV (Comma-Separated Values) files rigth within VSCode, so you don’t need to go back to Excel for small edits.\nRainbow CSV color-codes the columns in CSV files, making it much easier to work with them.\nSandDance generates plots of the data in a CSV for quick data exploration.\nSVG allows you to preview SVG (Scalable Vector Graphics) files inside VSCode. Most of the plotting packages can save plots as SVG files, which is recommended, since you can zoom in or out infinitly without loss of quality. Microsoft Office can include SVG files in, e.g. Word and PowerPoint.\nFor writing technical documents that include running code, e.g. to generate the plots, and to publish these to web pages, .PDF or DOCX documents, among others, consider Quarto (this will require the installation of the Quarto program as well as the VSCode add-in)\n\n\n\n\nJulia can make full use of Unicode fonts. This means you can use greek letters, emojis or anything else as variable names. Julia will also use common mathematical symbols, althoug there are alternatives for those who prefer to stick to ASCII. For examples:\nmass = 1.23\nvol = 2.56\n\nρ = mass/vol\nif 0.1 <= ρ <= 1.0\n    if ρ ≈ 0.48\n        println(\"Correct\")\n    end\nend\nThis reads a lot more like what you would normally write out by hand, e.g. using ρ instead of rho. In the place of ≈, you can use the isapprox() function, which has a few more options.\nThe use of <= is entirely optional as well. You simply type a < followed by =, and with the correct fonts installed, this will automatically be rendered as <=. If you don’t like that, just change the option in VSCode that allows use of font ligatures.\nTo make use of the Unicode abilities in you need a font installed that can handle ligatures and has a decent coverage of Unicode symbols. The following are recommended - JetBrains Mono - JuliaMono - Fira Code\nVSCode uses fall-back fonts, so if the first font specified in the settings does not include the character it should render, it will look in the next font until it finds the glyph, or runs out of fonts to look in. You can therefore install all three these fonts and then add them to the from of the list of specified fonts.\nYou use Unicode characters my typing, e.g. \\rho and pressing the <tab> key. If you find a character in someone’s code that you don’t know how to type, simply copy it and paste it next to the help prompt in Julia:\nhelp?> ℱ\n\"ℱ\" can be typed by \\scrF<tab>\n\n\n\nGit is a version control software. No, more accurately, Git is THE version control software. You do not need to use Git, but it will most certainly make your life a lot easier if you are either working in a team or working on large projects.\nGit is integrated into VSCode, but it is often handy to have the command-line version. You can get it from the Git homepage. Like Julia and VSCode, Git is free and open-sourced."
  },
  {
    "objectID": "An_Overview_of_the_Language.html",
    "href": "An_Overview_of_the_Language.html",
    "title": "An Overview of the Language",
    "section": "",
    "text": "Julia will open up in the default environment, e.g. @v1.8. You can add packages to this environment and they will be available to load as soon as you open Julia. Be very careful about doing this, as this can very often lead to what is lightly called dependency hell. This is what happens when a package you want to update depends on another package that can’t update, sometime because it depends on a specific version of yet another package. The more packages you have in the current environment, to more often this will happen. The solution is to create a new environment for each project and add only the packages you are actually using.\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.8.5 (2023-01-08)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> cd(\"./Dummy\")\n\njulia> pwd()\n\"D:\\\\JuliaCode\\\\Dummy\"\n\n(@v1.8) pkg> activate .\n  Activating project at `D:\\JuliaCode\\Dummy`\n\n(Dummy) pkg> add UnicodePlots\n    Updating registry at `C:\\Users\\Braam\\.julia\\registries\\General.toml`\n   Resolving package versions...\n    Updating `D:\\JuliaCode\\Dummy\\Project.toml`\n  [b8865327] + UnicodePlots v3.4.1\n    Updating `D:\\JuliaCode\\Dummy\\Manifest.toml`\n  [d360d2e6] + ChainRulesCore v1.15.7\n  [9e997f8a] + ChangesOfVariables v0.1.6\n  [35d6a980] + ColorSchemes v3.20.0\n  .\n  .\n  .\n\n(Dummy) pkg> st\nStatus `D:\\JuliaCode\\Dummy\\Project.toml`\n  [b8865327] UnicodePlots v3.4.1\nHere we changed the current directory to the Dummy sub-folder. Note the use of a forward slash. Backslashes are used for special characters, e.g. \\n for a new line and must themselves be escaped by typing a double backslash: cd(\".\\\\Dummy\"). Or you can use a raw string: cd(raw\".\\Dummy\"). The forward slash however works just as well in Linux and MaxOS, so is preferred.\npwd() is a function that replicates the Unix (Linux) command for print working directory and simply returns the name of the current folder.\nThe package manager is then activated with ] and the current folder is activated as a project with activate ., where . means the current directory (.. means the parent directory).\nFinally we add a registered packages, UnicodePlots.jl, and once the installation is done, check which packages and versions are currently installed with the st command (short for status).\nOnce a package is installed, it can be loaded by issuing the using command:\njulia> using UnicodePlots\nIn the Dummy folder, Julia creates two files: project.toml and manifest.toml. These hold the record of the specific versions of packages that have been installed. The packages directly installed are in the project.toml file, while the version numbers of dependencies are tracked in manifest.toml. These two files mean that someone else can reinstate the exact environment you developed your code in by activating the project and issuing the instantiate command to the package manager. This will install the same versions of the packages and dependencies as listed in the *.toml files.\nEach project should be in its own folder, with its own *.toml files. This means different projects can potentially use different versions of the same package, depending on what other packages are in use.\nTo update the packages and dependencies to the latest versions (as allowed for by the specified versions of dependencies for each packages), use the up command of the package manager. This updates packages for the current project only."
  },
  {
    "objectID": "An_Overview_of_the_Language.html#keyboard-shortcuts",
    "href": "An_Overview_of_the_Language.html#keyboard-shortcuts",
    "title": "An Overview of the Language",
    "section": "Keyboard Shortcuts",
    "text": "Keyboard Shortcuts\nThe REPL has commandline completion. For example, if you typed:\ninclude(\"myscript.jl\")\nin the previous example, then typing inc and pressing the up cursor will repeat the previous line that started with inc, i.e. include(\"myscript.jl\").\nYou could also start typing a command and hit <tab> to get full command with some intelligence built-in. E.g., type prin and hit <tab>. Julia will complete the command to print. Hit <tab> again, and you get:\njulia> print\nprint        println      printstyled\njulia> print\nSince there are more than one command that starts with print, Julia lists them all, creates a new prompt and starts off with the letters print, so you can complete the line.\nYou can clear the REPL with ctrl-L and close it with ctrl-D on an empty line."
  },
  {
    "objectID": "An_Overview_of_the_Language.html#running-julia-inside-vscode",
    "href": "An_Overview_of_the_Language.html#running-julia-inside-vscode",
    "title": "An Overview of the Language",
    "section": "Running Julia inside VSCode",
    "text": "Running Julia inside VSCode"
  },
  {
    "objectID": "Running_Julia.html",
    "href": "Running_Julia.html",
    "title": "Running Julia",
    "section": "",
    "text": "When you open up Julia, you will be presented with the REPL (Read Execute Print Loop). This is basically a command prompt that Reads your input, Executes the instructions, Prints the results and then Loops back to waiting for a new input.\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.8.5 (2023-01-08)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia>\nYou can enter code directly at the julia> prompt, but since none of this will be saved, it is probably not the prefered way of coding.\nA better way would be to save your code into a file, e.g. myscript.jl, and then execute this script by using the include() command. For example, if the file myscript.jl includes the following:\nusing UnicodePlots\n\nbarplot([\"A\", \"B\", \"C\"], rand(3))\nthen my can run the script as follows:\njulia> include(\"myscript.jl\")\n     ┌                                        ┐\n   A ┤■■■■■■■■■■■■■■■■■■■ 0.479201\n   B ┤■■■■■■■■■■■■■■■■ 0.394627\n   C ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.754307\n     └                                        ┘\nYou can also run the script from the commandline with:\njulia myscript.jl\nThe REPL has a few modes. You can access the package manager by pressing ] at the julia> prompt. To access the help mode, use ? (also inside the package manager). You can also access the underlying shell with ;, but unless you are running Julia inside Windows Terminal, very little will work in Shell Mode.\nWhile it is good to be familiar with the REPL, realisitically speaking, the only thing the average user will every do in the REPL is to access the package manager. This is where to install or remove packages and update installed packages.\nYou can use Unicode characters in the REPL, but unless you are using Windows Terminal, most non-ASCII characters won’t display properly.\n\n\nThe REPL has commandline completion. For example, if you typed:\ninclude(\"myscript.jl\")\nin the previous example, then typing inc and pressing the up cursor will repeat the previous line that started with inc, i.e. include(\"myscript.jl\").\nYou could also start typing a command and hit <tab> to get full command with some intelligence built-in. E.g., type prin and hit <tab>. Julia will complete the command to print. Hit <tab> again, and you get:\njulia> print\nprint        println      printstyled\njulia> print\nSince there are more than one command that starts with print, Julia lists them all, creates a new prompt and starts off with the letters print, so you can complete the line.\nYou can clear the REPL with ctrl-L and close it with ctrl-D on an empty line."
  },
  {
    "objectID": "Running_Julia.html#running-julia-inside-vscode",
    "href": "Running_Julia.html#running-julia-inside-vscode",
    "title": "Running Julia",
    "section": "Running Julia inside VSCode",
    "text": "Running Julia inside VSCode\nOne of the most common ways of working with Julia is from inside VSCode. If everything is set up correctly, simply do the following\n\nCreate a folder for your project\nRight click inside the folder in Windows Explorer and select Open with Code. This will start up VSCode and open the folder inside the editor.\nAdd a file to contain your code. Be sure to give it a .jl extension, so VSCode can identify it as Julia code.\n\nNow you can enter code.\nTo execute the code, either click the run button to execute the whole file, or click on a line you want to execute and hit Shift-Enter to execute the code block. A code block is intelligently identified, so if the line you are on is inside a function definition, for example, the function will be compiled.\nOnce you are executing code, a Julia REPL will be open in the Terminal inside VSCode. Anything you can do in the REPL can be done here. The Julia add-in also provides more features, like listing all exising variables in the current scope and their values, as well as a plot pane and many other useful tools."
  },
  {
    "objectID": "Running_Julia.html#jupy",
    "href": "Running_Julia.html#jupy",
    "title": "Running Julia",
    "section": "Jupy",
    "text": "Jupy"
  },
  {
    "objectID": "Running_Julia.html#jupyter-and-pluto",
    "href": "Running_Julia.html#jupyter-and-pluto",
    "title": "Running Julia",
    "section": "Jupyter and Pluto",
    "text": "Jupyter and Pluto\nThere are two more useful tools for running Julia. * Jupyter notebooks * Pluto notebooks\nThese run inside your browser. Code is entered in cells and results displayed below (Jupyter) or above (Pluto) the cell after it is executed.\nThe main difference between the two is that Jupyter cells are static - they only run when you execute them manually, while Pluto is reactive. If a cell in pluto assigns a value to variable and is edited, then Pluto will also execute all other cells that use this variable.\nJupyter can be used with Python and R as well as Julia (the name Jupyter is from Julia, Python and R). Pluto is only for Julia.\nMore on these later."
  },
  {
    "objectID": "An_Overview_of_the_Language.html#using-vs-import",
    "href": "An_Overview_of_the_Language.html#using-vs-import",
    "title": "An Overview of the Language",
    "section": "Using vs Import",
    "text": "Using vs Import\nThere are two ways to load a Julia package: using and import\nIf you use using, all methods and variables exported by a package are brought into the current namespace. You can call them directly:\nusing Plots\n\nscatter(rand(10), rand(10))\nThis does mean that several functions and variables you are not using are now also in the namespace and you cannot define a new function with the same name, or use another package that exports a function with the same name. For those cases, you can use import. If a package is imported, you need to prepend each function call with the package name.\nimport Plots\nimport GLMakie\n\nPlots.scatter(rand(10), rand(10))\nGLMakie.scatter(rand(10), rand(10))\n\n\n\n\n\n\nTry this\n\n\n\nSee what happens when you use using for the previous example.\n\n\nYou can load specific functions or variables from a package:\nusing Plots: scatter\nimport GLMakie: lines\nNone of the other exported variables or functions will become available. When loading a single item, you can also rename it using the as keyword:\nimport Plots.scatter as ps\nimport GLMakie: scatter as ms\n\nps(rand(10), rand(10))\nms(rand(10), rand(10))\nor even rename the package during import:\njulia> import BenchmarkTools as bt\n\njulia> bt.@benchmark sin.(1:1_000_000)\nBenchmarkTools.Trial: 400 samples with 1 evaluation.\n Range (min … max):  11.751 ms … 24.278 ms  ┊ GC (min … max): 0.00% … 49.13%\n Time  (median):     12.043 ms              ┊ GC (median):    0.00%\n Time  (mean ± σ):   12.515 ms ±  2.246 ms  ┊ GC (mean ± σ):  3.56% ±  9.50%\n\n  ▆█▅\n  ████▆▁▄▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▁▅▇▆ ▆\n  11.8 ms      Histogram: log(frequency) by time        24 ms <\n\n Memory estimate: 7.63 MiB, allocs estimate: 2."
  },
  {
    "objectID": "An_Overview_of_the_Language.html#functions",
    "href": "An_Overview_of_the_Language.html#functions",
    "title": "An Overview of the Language",
    "section": "Functions",
    "text": "Functions"
  },
  {
    "objectID": "An_Overview_of_the_Language.html#types",
    "href": "An_Overview_of_the_Language.html#types",
    "title": "An Overview of the Language",
    "section": "Types",
    "text": "Types"
  },
  {
    "objectID": "An_Overview_of_the_Language.html#built-in-types",
    "href": "An_Overview_of_the_Language.html#built-in-types",
    "title": "An Overview of the Language",
    "section": "Built-in Types",
    "text": "Built-in Types"
  },
  {
    "objectID": "An_Overview_of_the_Language.html#variables",
    "href": "An_Overview_of_the_Language.html#variables",
    "title": "An Overview of the Language",
    "section": "Variables",
    "text": "Variables\nThere is no programming without variables. In Julia, there is no need to pre-declare a variable and variables can be reassigned to a value of another type:\njulia> x = 1\n1\n\njulia> typeof(x)\nInt64\n\njulia> x = 2.4\n2.4\n\njulia> typeof(x)\nFloat64\n\njulia> x = \"Hello, World\"\n\"Hello, World\"\n\njulia> typeof(x)\nString\nWhen assigning a value to the variable x, Julia infers the type of the value, e.g. Int64 and then associates the name, x, with that value.\nAs illustrated, the function typeof() will return the type of the variable or value.\n\nIntegers and Floating-point Values\nJulia has the usual selection of variable types for integers and floating point values. There are signed and unsigned versions of 8, 16, 32, 64 and 128-bit integers. See the manual for details.\nThere is also a Bool type that holds either true (1) or false (0).\nFor floating point values, there is Float16, Float32 and Float64.\nThe default integer, Int is Int64 for 64-bit Julia and Int32 for 32-bit Julia. Generally, you would want to use Float64 for floating-point numbers, unless there is a specific reason not to. Calculations on a GPU (via e.g. CUDA.jl) should be done using Float32.\n\nA Word on Floating Point Values\nFloating point values are stored in a limited number of bits (typically 64 bits - a.k.a. double precision) and hence have a limited precision. The result is that most values cannot be precisley stored in a Float64 variable. As a simple example, 1/10, which is clearly precisely equal to 0.1, is actually calculated as 0.1000000000000000055511151231257827021181583404541015625 with 256-bit precision.\nThe smallest positive value that can be stored in a Float64, is 2.220446049250313e-16. You can calculate this in Julia using the eps() function, e.g. eps(Float64). The value epsilon is an indication of the precision you can expect. It is the smallest value you can add to the floating point value that will cause it to result in a new value. Anything smaller may as well be zero. Obviously epsilon depends on the magnitude of the values you are working with and you can again use the eps() function: eps(100) = 1.4210854715202004e-14, so adding a smaller amount to 100 will not change the value.\nWhile you can safely ignore this for many, if not most engineering calculations, it can sometimes become an issue when you least expect it. Consider adding up a very large number of small values. The larger the difference between the running total and the next value you are adding, the larger the rounding error will become. At some point in this exercise, the value you are adding to the running total will be in the order of the relative epsilon and the running total will stop increasing, no matter how many more values you add. The solution to this is actually fairly simple and implemented in the Julia sum() function. The list of values is split into pairs and the pairs are added to each other, then this is repeated over and over until there is only one value left - the answer. The algorithm works under the inherent assumption that the values are fairly equally sized and so adding similar values results in minimal rounding error. Once the pairs have been summed, the new values should also be simialrly sized and so the process repeats, with a minimum rounding error at each step.\nSomething else to consider, which much more often trips up new programmers, is that you will very rarely find two identical floating point values through calculations. Directly comparing values that are realistically speaking equal, will very often result in the wrong part of an if statement executing. When comparing floating point values, always use a check for approximate equality. This is done either via the ≈ operator (\\approx<tab>), or the isapprox() function, which allows you to specify absolute and relative tolerances. The ≈ operator calls isapprox() with default tolerances.\nThe internal storage of floating point values is standardised by the IEEE 754 standard, which is used in just about every programming language.\n\n\n\nBigInt and BigFloat\nSometimes, you may find a need for additional precision. Arbitrary precicion integer and floating point types are available as BigInt and BigFloat.\nThere are several ways to specifiy that you are using big numbers, but the simplest is via the big() function:\njulia> x = big(10.0)\n10.0\n\njulia> typeof(x)\nBigFloat\nThe precision again comes at the cost of performance. See the manual for more details.\n\n\nComplex Numbers\nJulia has built-in types for complex numbers, which depend on the integer or floating-point type used to store the real and imaginary parts, e.g.\njulia> typeof(1 + 2im)\nComplex{Int64}\n\njulia> typeof(1.0 + 2.0im)\nComplexF64 (alias for Complex{Float64})\nAs you will notice, a complex type is specified as Complex{T} where T is an integer or floating point type. Any of the integer and floating points types mentioned before could be used, including BigInt and BigFloat. Simply define the value as:\njulia> z = big(10.0) + 1.0im\n10.0 + 1.0im\n\njulia> typeof(z)\nComplex{BigFloat}\n\njulia> z = big(10) + 1im\n10 + 1im\n\njulia> typeof(z)\nComplex{BigInt}\nThe imaginary part of the number is indicated by adding im directly behind the number - no space!\nThe standard functions used with complex numbers are available, including:\njulia> z = 1 + 1im\n1 + 1im\n\njulia> real(z) # real part\n1\n\njulia> imag(z) # imaginary part\n1\n\njulia> conj(z) # complex conjugate\n1 - 1im\n\njulia> abs(z) # absolute value - distance from zero\n1.4142135623730951\n\njulia> abs2(z) # squared absolute value\n2\n\njulia> angle(z) # phase angle (radians)\n0.7853981633974483\n\njulia> angle(z) * 360/2π # convert to degrees\n45.0\n\njulia> √z\n1.09868411346781 + 0.45508986056222733im\n\njulia> sqrt(z)\n1.09868411346781 + 0.45508986056222733im\n\n\nRational Numbers\nYou can also work with rational numbers.\njulia> a = 1//2 + 3//8\n7//8\n\njulia> float(a)\n0.875\n\njulia> rationalize(0.875)\n7//8\nThis eliminates rounding losses, but at a loss of performance:\njulia> function myfunc(x)\n           sum = zero(x)\n           for i in 1:10_000\n               sum += x * i\n           end\n           return sum\n       end\n\nmyfunc (generic function with 1 method)\n\njulia> using BenchmarkTools\n\njulia> @benchmark myfunc(1.0)\nBenchmarkTools.Trial: 10000 samples with 3 evaluations.\n Range (min … max):  8.500 μs …  73.733 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     8.700 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   8.704 μs ± 966.620 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▅  █  ▆  ▃         █  █   ▅  ▂  ▁   ▁  ▁                    ▂\n  █▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁█▁▁▁▇▁▁█▁▁▇▁▁▄ █\n  8.5 μs       Histogram: log(frequency) by time       9.1 μs <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n\njulia> @benchmark myfunc(1//1)\nBenchmarkTools.Trial: 7295 samples with 1 evaluation.\n Range (min … max):  663.600 μs …  1.234 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     680.100 μs              ┊ GC (median):    0.00%\n Time  (mean ± σ):   682.504 μs ± 29.021 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▇█▆▃▂▃██▅▄▃▃▃▂▃▁▁▁▁       ▁                                  ▂\n  ███████████████████████▇▇████▇▇█▆▆▇▇▇▅▆▆▅▆▅▅▅▃▅▅▄▆▅▃▅▅▄▄▁▃▃▅ █\n  664 μs        Histogram: log(frequency) by time       811 μs <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\nSo, floating point calculations are about 78x faster than with rational numbers. What about integers?\njulia> @benchmark myfunc(1)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  1.900 ns … 27.200 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     2.000 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   1.976 ns ±  0.530 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▄                                                        █\n  █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▂\n  1.9 ns         Histogram: frequency by time           2 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n1.9 nanoseconds?!? That sounds too good to be true, doesn’t it? Let’s see what type of code Julia generated to make that possible.\njulia> @code_llvm myfunc(1)\n;  @ REPL[6]:1 within `myfunc`\n; Function Attrs: uwtable\ndefine i64 @julia_myfunc_739(i64 signext %0) #0 {\ntop:\n;  @ REPL[6]:3 within `myfunc`\n  %1 = mul i64 %0, 50005000\n;  @ REPL[6]:6 within `myfunc`\n  ret i64 %1\n}\nWe can again ignore any line starting with a semi-colon. The one line that matters is this:\n  %1 = mul i64 %0, 50005000\nThe Julia compiler could analyse the code well enough to see that the answer to our function is sumply 50005000 times the input value and that is exactly what it returned!\nWith floating point and rational values, there were type conversions required before multiplying the integer value of the loop counter with the input value. This “hid” the true nature of the calculation enough that the compiler could not see the short-cut. There is however continuous development in the compiler and we can reasonbly expect this to also be optimised in a future version of Julia.\n\n\nArrays, Tuples and Ranges\n\nArrays\nIn most code, you will find it convenient to deal with a collection of values at the same time. There are several ways of doing this.\nThe most common collection of values is an Array. In mathematics, you will be familar with vectors and matrices. These are simply one- and two dimensional arrays. You can have arrays with any number of dimensions (tensors). The keywords Vector and Matrix are also available as synonyms for Array in the special cases of one and two dimensions.\nSimple one dimensional arrays are treated as column vectors for use in linear algebra calculations. You can s Some examples:\njulia> a = [1, 2, 3]   # use commas to specify column vectors\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> b = [1 2 3]   # use spaces to specify row vectors\n1×3 Matrix{Int64}:\n 1  2  3\n\njulia> a * b \n3×3 Matrix{Int64}:\n 1  2  3\n 2  4  6\n 3  6  9\n\njulia> A = [1 2 3;   # directly specify a 2D array a.k.a. a matrix\n            4 5 6;\n            7 8 9]\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> B = zeros(3, 3, 3)   # zeros() and ones() fill the array of the specified size\n3×3×3 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 3] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 \n\njulia> C = [1;2;;3;4;;;5;6;;7;8;;;9;10;;11;12]  # ; separates in first dimension, ;; in second dimension, ;;; in third etc.\n2×2×3 Array{Int64, 3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8\n\n[:, :, 3] =\n  9  11\n 10  12\n\njulia> A = Float64[]   # an empty 1D array of Float64\nFloat64[]\nThe individual entries of an array are accessed via [], e.g. \njulia> A[2, 3]\n6\nIn the background, [] calls getindex() and setindex() to retrieve or modify the entries of the array. If you define your own array-like type, you will need to supply the appropriate getindex() and setindex() functions.\nYou can concatenate arrays horizontally and vertically with hcat() and vcat(), or using the syntax above with spaces or semi-colons:\njulia> A = [1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> B = [4, 5, 6]\n3-element Vector{Int64}:\n 4\n 5\n 6\n\njulia> [A; B]\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> [A B]\n3×2 Matrix{Int64}:\n 1  4\n 2  5\n 3  6\n\njulia> vcat(A, B)\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> hcat(A, B)\n3×2 Matrix{Int64}:\n 1  4\n 2  5\n 3  6\n\n\nTuples\nTuples are functionally similar to arrays. They are specified with commas and parentheses. They are intimately linked with passing parameters to functions and returning values from functions, e.g.\njulia> function myfunc(a, b)\n           return a*b, a+b\n       end\nmyfunc (generic function with 1 method)\n\njulia> myfunc(1, 2)\n(2, 3)\nWe pass the parameters to the function as a tuple, (a, b). The results are returned as a tuple, (2, 3). Other than passing parameters to functions, what is the use of tuples? They are fairly widely used in Julial. The main differences from arrays are that while arrays are heap-allocated, tuples are stack-allocated. This is some more computer jargon, but what it means is that tuples can be accessed faster than arrays, but cannot be as large.\nTuples are also immutable, meaning once created, they cannot be modified. The entries of an array can always be modified. This is important to keep in mind when writing functions in Julia. The only way you can modify a parameter passed to a function is if that parameter is an array. And then only the contents of the array can be changed.\nSome examples:\njulia> a = (1, 2, 3)\n(1, 2, 3)\n\njulia> typeof(a)\nTuple{Int64, Int64, Int64}\n\njulia> b = (1., 2., 3.)\n(1.0, 2.0, 3.0)\n\njulia> typeof(b)\nTuple{Float64, Float64, Float64}\n\njulia> a[2]\n2\n\njulia> c = (1,)\n(1,)\n\njulia> typeof(c)\nTuple{Int64}\n\njulia> d = 1,2,3  # the parentheses are optional here\n(1, 2, 3)\n\njulia> typeof(d)\nTuple{Int64, Int64, Int64}\nWe again use [] to access the individual entries.\nTuples can be unpacked into variables:\njulia> a\n(1, 2, 3)\n\njulia> x, y, z = a\n(1, 2, 3)\n\njulia> x\n1\n\njulia> y\n2\n\njulia> z\n3\nAnd since the parentheses are option in the direct specification of tuples, we can do this:\njulia> x = 1\n1\n\njulia> y = 2\n2\n\njulia> y, x = x, y\n(1, 2)\n\njulia> x\n2\n\njulia> y\n1\nHere we defined a tuple (x, y) and then unpacked it into the variables y and x, swopping their values.\nSince tuples have superior performance to arrays, there exists a package that builds small arrays from tuples - StaticArrays.jl. This is commonly used for maximum performance, but only for smallish arrays, typically less than 200-300 entries. More than that and you run out of space on the stack, which has a limited size.\n\n\nNamed Tuples\nYou can also name the entries in a tuple and access them via the names instead or indeces:\njulia> nt = (a = 1, b = 2, c = \"Bob\")\n(a = 1, b = 2, c = \"Bob\")\n\njulia> nt.a\n1\n\njulia> nt[2]\n2\n\njulia> nt.c\n\"Bob\"\n\njulia> typeof(nt)\nNamedTuple{(:a, :b, :c), Tuple{Int64, Int64, String}}\nNote that the entries in a tuple or named tuple needn’t be all of the same type. This is also true for arrays, but in that case the array will be of type Any and performance will be hugely impacted. Avoid this whenever possible!\n\n\nRanges\nThe third collection type we are considering are ranges. There are several ways to specify a range:\njulia> a = 1:10   #start : stop with default step of one, hence a unit range\n1:10\n\njulia> typeof(a)\nUnitRange{Int64}\n\njulia> b = 1:2:20   # start : step : stop, hence a step range\n1:2:19\n\njulia> typeof(b)\nStepRange{Int64, Int64}\n\njulia> c = 1.0:0.5:5.0 # with floating point steps, we get a StepRangeLen - start, stop, length\n1.0:0.5:5.0\n\njulia> typeof(c)\nStepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}\n\njulia> d = range(2.0, step=5.3, length=5)  # instead of colon notation, you can call the function with more options\n2.0:5.3:23.2\n\njulia> typeof(d)\nStepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}\nAnd just like before, we access the entries with []:\njulia> a[2]\n2\n\njulia> b[3]\n5\n\njulia> c[4]\n2.5\n\njulia> d[5]\n23.2\nThe main difference is that, while arrays and tuples consist of values stored in memory, ranges are lazy. The values are only calculated when they are requested and no matter the length of the range, it takes up the same amount of memory - just enough to store the start, step and stop values that are needed to calculate any entry and know when you have run through the whole range.\n\n\nIterables\nArrays, tuples and ranges are all iterable types, meaning you can iterate through their entries:\njulia> a = [1, 5, 10]\n3-element Vector{Int64}:\n  1\n  5\n 10\n\njulia> for i in a\n           println(i)\n       end\n1\n5\n10\n\njulia> for j in 1:3\n           println(j*2)\n       end\n2\n4\n6\n\njulia> t = (1, 2, 3)\n(1, 2, 3)\n\njulia> for k in t\n           println(k)\n       end\n1\n2\n3\nFrom a programmer’s point of view, iterable types all behave the same. I can therefore write a function that can handle any iterable type. The only requirement here is that the item passed should have at least two entries, or there will be an error.\njulia> function mycomp(a)\n           if a[1] > a[2]\n               return true\n           else\n               return false\n           end\n       end\nmycomp (generic function with 1 method)\n\njulia> ar = [1, 2]\n2-element Vector{Int64}:\n 1\n 2\n\njulia> t = (2, 1)\n(2, 1)\n\njulia> r = 10:-1:1\n10:-1:1\n\njulia> mycomp(ar)\nfalse\n\njulia> mycomp(t)\ntrue\n\njulia> mycomp(r)\ntrue\nFor each case, the Julia compiler will generate optimised code depending on the type of the variable passed.\n\n\nIndexing\nIn the examples above, we used one dimensional arrays and there was really no choice in how to index into the structure. In the case if multi-dimensional arrays, there are better and worse options. This is because of how the values are stored in memory. It is faster to sequencially access values that are stored next to each other than to jump around in memory. Julia is column major, meaning that the values in the first column of a matrix are stored next to each other in memory, followed by the values of the next column etc. For higher dimenstions, the sequence is similar: each subsequent index follows the next. This is then the fastest way of iterating through the whole array.\njulia> A = rand(10_000, 10_000);  # the _ is ignored - it is just to make reading easier. The ; at the end suppresses output of the result\n\njulia> function myfunc(A)\n           mysum = 0.0\n           m, n = size(A)\n           for i = 1:m, j = 1:n  # we are running through the matrix a row at a time\n               mysum += A[i, j]\n           end\n           return mysum\n       end\nmyfunc (generic function with 1 method)\n\njulia> function myfunc2(A)\n           mysum = 0.0\n           m, n = size(A)\n           for j = 1:n, i = 1:m  # we are running through the matrix a column at a time\n               mysum += A[i, j]\n           end\n           return mysum\n       end\nmyfunc2 (generic function with 1 method)\n\njulia> using BenchmarkTools\n\njulia> @btime myfunc(A) # @btime is similar to @benchmark, but just returns the minimum time\n  1.827 s (1 allocation: 16 bytes)\n5.000090241950586e7\n\njulia> @btime myfunc2(A)\n  96.449 ms (1 allocation: 16 bytes)\n5.000090241950418e7\nSo, in our 10,000 x 10,000 random matrix, summing up the values row-wise takes 1.827s, while column-wise it takes only 96.449ms. Quite the improvement! If you are worried you won’t remember the correct way of iterating through a structure, Julia has you covered. Use eachindex() to get the optimal sequence:\njulia> function myfunc3(A)\n           mysum = 0.0\n           m, n = size(A)\n           for i in eachindex(A)\n               mysum += A[i]\n           end\n           return mysum\n       end\nmyfunc3 (generic function with 1 method)\n\njulia> @btime myfunc3(A)\n  96.394 ms (1 allocation: 16 bytes)\n5.000090241950418e7\neachindex() returns a linear index, no matter what the dimensionality of the array is and sequences it for the fastest sequencial access.\nAnother useful indexing function is enumerate. It returns an iterator if tuples, each containing an index and value pair. The indeces are linear, not cartesian.\njulia> A = rand(2,2)\n2×2 Matrix{Float64}:\n 0.488632  0.177813\n 0.221677  0.559213\n\njulia> for (index, value) in enumerate(A)\n           println(\"$index $value\")\n       end\n1 0.4886321057630626\n2 0.22167740760406662\n3 0.17781317540395236\n4 0.5592126504604934\nFor more information, see the manual."
  },
  {
    "objectID": "An_Overview_of_the_Language.html#note",
    "href": "An_Overview_of_the_Language.html#note",
    "title": "An Overview of the Language",
    "section": "Note",
    "text": "Note\nIn the REPL this is helpfully printed in red"
  },
  {
    "objectID": "An_Overview_of_the_Language.html#type-stability",
    "href": "An_Overview_of_the_Language.html#type-stability",
    "title": "An Overview of the Language",
    "section": "Type Stability",
    "text": "Type Stability\nBeing able to change the type of a variable can be useful, but it does also open the door to something that can cause slowdown in your code: type instability. This is when the type of x changes during the execution of your code, making many of the optimisations Julia could do impossible. Instead, additional code is required to handle the type changes. Keep a look-out for something like this:\njulia> function myfunc(n)\n           sum = 0\n           for i in 1:n\n               sum += 1.5\n           end\n           return sum\n       end\nmyfunc (generic function with 1 method)\nAt first glance, there is nothing strange about this code. If you take a closer look however, you will see that sum is created as an integer via sum = 0, but then we assign floating point values to it.\nJulia has a lot of code analyses tools. One of which is @code_warntype:\njulia> @code_warntype myfunc(5)\nMethodInstance for myfunc(::Int64)\n  from myfunc(n) in Main at REPL[20]:1\nArguments\n  #self#::Core.Const(myfunc)\n  n::Int64\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  sum::Union{Float64, Int64}\n  i::Int64\nBody::Union{Float64, Int64}\n1 ─       (sum = 0)\n│   %2  = (1:n)::Core.PartialStruct(UnitRange{Int64}, Any[Core.Const(1), Int64])\n│         (@_3 = Base.iterate(%2))\n│   %4  = (@_3 === nothing)::Bool\n│   %5  = Base.not_int(%4)::Bool\n└──       goto #4 if not %5\n2 ┄ %7  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Int64\n│         (sum = sum + 1.5)\n│         (@_3 = Base.iterate(%2, %9))\n│   %12 = (@_3 === nothing)::Bool\n│   %13 = Base.not_int(%12)::Bool\n└──       goto #4 if not %13\n3 ─       goto #2\n4 ┄       return sum\nLike when we looked at the LLVM code generated for a function, this may seem intimidating, but the important bit is this:\nsum::Union{Float64, Int64}\n\n\n\n\n\n\nNote\n\n\n\nIn the REPL this is helpfully printed in red to draw your attention.\n\n\nJulia indicates that the variable sum is not type stable. It is assigned both Int64 and Float64values."
  },
  {
    "objectID": "An_Overview_of_the_Language.html#the",
    "href": "An_Overview_of_the_Language.html#the",
    "title": "An Overview of the Language",
    "section": "The",
    "text": "The"
  },
  {
    "objectID": "An_Overview_of_the_Language.html#the-type-hierarchy",
    "href": "An_Overview_of_the_Language.html#the-type-hierarchy",
    "title": "An Overview of the Language",
    "section": "The Type Hierarchy",
    "text": "The Type Hierarchy\nThe built-in types have a hieracrchy:\n\n\n\nThe type hierarchy - Ref: https://thautwarm.github.io/\n\n\nThis consists of abstract and concrete types. You can only instanciate a variable of a concrete type, but the abstracts types are useful to specificy groups of types that would behave similarly, e.g. Float64 and Int64 could both the added or multiplied. This is true for all the Number types, be they Real or Complex. We could specify allowed groups of types, via the <: operator, or specific types, via ::, e.g.\nfunction f(x::T) where T <: Number\n    #do something\nend\nHere, Julia will allow us to call f(x) with any sub-type of the Number abstract type, such as Float64, Int32 or ComplexF64. Calling f(x) with a String type will give an error."
  }
]