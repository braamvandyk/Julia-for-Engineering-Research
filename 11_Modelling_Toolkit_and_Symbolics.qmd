---
title: "Modeling Toolkit and Symbolics"
---

Up to now, when we needed to solve a system of ODEs or non-linear equations, for example, we have programmed these and passed them to a solver. If you are comfortable with writing code, this is not a problem. There is however a few tools available in Julia that can make the task a lot easier, both for experienced and novice programmers - a modern Computer Algebra System, [Symbolics.jl](https://symbolics.juliasymbolics.org/stable/).

## Symbolics.jl and the Symbolics Ecosystem
Symbolics allows you to simply specify the equations for your system and then do symbolic manipulations and simplifications to the system. Since Symbolics is written in pure Julia, it interacts seamlessly with normal Julia code and you can do anything with a symbolic variable you would do with any other Julia variable. This gives great flexibility. It doesn't stop there however - it will also generate a Julia function for you - optimised and parallelised, if specified. 

In addition, there are several other packages that build on Symbolics:

- **ModelingToolkit**: Provides the tools to symbolically specify common numerical systems like ODEs, PDEs, non-linear systems, control problems, causal and acausal modelling etc.
- **Catalyst**: Provides tools for specifying reaction networks and kinetics
- **DataDrivenDiffEq**: Automatic identifications of ODEs/DAEs from data
- **SymbolicRegression**: Genetic programming to find equations from data
- **ReversePropagation**: Source-to-source mode automatic differentiation

## Using Symbolics
This is a very brief introduction to Symbolics. For more detail, refer to the [manual](https://symbolics.juliasymbolics.org/stable/getting_started/).

At the simples level, Symbolics works with symbolic variables and equations. You specify equations with the `@variables` macro and then simply build equations with these symbolic variables. You can simplify equations, using `simplify()`, define and calculate derivates and jacobians etc. If you are using Symbolics in a Jupyter notebook or in Pluto, the equations will be rendered as $LaTeX$. In the REPL or a script, there will be text output. You can also generate $LaTeX$ expressions with the [Latexify](https://korsbo.github.io/Latexify.jl/stable/) package.


```julia
using Symbolics

@variables x, y
# 2-element Vector{Num}:
#  x
#  y

z = (x + y)*(x - y)

Dx = Differential(x)
# (::Differential) (generic function with 2 methods)

Dy = Differential(y)
# (::Differential) (generic function with 2 methods)

expand_derivatives(Dx(z))
# 2x

expand_derivatives(Dy(z))
# -2y

simplify(2x + x^2 - y - x -2x^2)
# x - y - (x^2)

A = [x x*y y^2;
     y 2*x*y x^2*y]

# 2×3 Matrix{Num}:
#  x   x*y      y^2
#  y  2x*y  y*(x^2)

latexify(A)
# L"\begin{equation}
# \left[
# \begin{array}{ccc}
# x & x y & y^{2} \\
# y & 2 x y & x^{2} y \\
# \end{array}
# \right]
# \end{equation}
# "
```
The last result, when rendered in $LaTeX$, or in a Jupyter notebook, for example, looks like this:

$$
\begin{equation}
\left[
\begin{array}{ccc}
x & x y & y^{2} \\
y & 2 x y & x^{2} y \\
\end{array}
\right]
\end{equation}
$$

So, we can do basic math and calculus and make pretty equations for reports. What else can we do? Well, a whole lot, as it turns out. Symbolics is a full-featured CAS (Computer Algebra System). Whats more, since it is fully written in Julia, it interacts with the rest of Julia in a pretty seamless manner. Anything you would do with a Julia variable, you can also do with a symbolic (type `Num`) variable.

For example, we can call a function:

```julia
f(u) = 2*u[1] - u[2]
# f (generic function with 1 method)

f([x, y])
# 2x - y
```

We can also define more complicated systems, where the variables are dependent on each other:

```julia
using Symbolics, Latexify

@variables t x(t) y(t) # Declare an unknown dependency on t for x and y
# 3-element Vector{Num}:
#     t
#  x(t)
#  y(t)

z = x*t + y*t^2
# t*x(t) + (t^2)*y(t)

Dt = Differential(t)
# (::Differential) (generic function with 2 methods)

expand_derivatives(Dt(z))
# t*Differential(t)(x(t)) + (t^2)*Differential(t)(y(t)) + 2t*y(t) + x(t)

latexify(expand_derivatives(Dt(z)))
# L"\begin{equation}
# t \frac{\mathrm{d} x\left( t \right)}{\mathrm{d}t} + t^{2} \frac{\mathrm{d} y\left( t \right)}{\mathrm{d}t} + 2 t y\left( t \right) + x\left( t \right)
# \end{equation}
# "

```
Where the result from the last line is:
$$
\begin{equation}
t \frac{\mathrm{d} x\left( t \right)}{\mathrm{d}t} + t^{2} \frac{\mathrm{d} y\left( t \right)}{\mathrm{d}t} + 2 t y\left( t \right) + x\left( t \right)
\end{equation}
$$

In other words, since we indicated that `x` and `y` depend on `t`, this information was included in the derivative calculation. 

The final, but most important part of Symbolics is its ability to convert symbolic equations into Julia code.

```julia

using Symbolics

@variables x y
# 2-element Vector{Num}:
#  x
#  y

eqs = [x^2 + y, y^2 + x]
# 2-element Vector{Num}:
#  y + x^2
#  x + y^2)

f_expr = build_function(eqs, [x, y])
Base.remove_linenums!.(f_expr)
# (:(function (ˍ₋arg1,)
#       begin
#           begin
#               (SymbolicUtils.Code.create_array)(typeof(ˍ₋arg1), nothing, Val{1}(), Val{(2,)}(), (+)(ˍ₋arg1[2], (^)(ˍ₋arg1[1], 2)), (+)(ˍ₋arg1[1], (^)(ˍ₋arg1[2], 2)))
#           end
#       end
#   end), :(function (ˍ₋out, ˍ₋arg1)
#       begin
#           begin
#               #= C:\Users\Braam\.julia\packages\SymbolicUtils\H684H\src\code.jl:399 =# @inbounds begin
#                       ˍ₋out[1] = (+)(ˍ₋arg1[2], (^)(ˍ₋arg1[1], 2))
#                       ˍ₋out[2] = (+)(ˍ₋arg1[1], (^)(ˍ₋arg1[2], 2))
#                       nothing
#                   end
#           end
#       end
#   end))
```

:::{.callout-note}
The `Base.remove_linenums!()` call just removes a lot of additional line number information form the result to make it more readable. You would not normally bother with this.
:::

Don't worry if this looks unlike anything related to Julia code you have ever seen. What is returned is a Julia expression string - this is how Julia code is stored internally. It is also what you would generate if you wrote a Julia macro (meta-programming). A macro in Julia is a piece of code that, instead of returning a value, returns another piece of code that is then evaluated. Macros in Julia are normally identified by the `@` symbol, e.g. `@variables`. This is a topic for another chapter.

So, what is going on here? The first thing to note is that the expression contains a tuple that holds two functions. The first starts with `function (ˍ₋arg1,)`, while the second starts with `function (ˍ₋out, ˍ₋arg1)`. If you look more closely at the code, you will see that the functions (we'll call then `func1` and `func2!` here) are equivalent to:

```julia
function func1(u)
    return u[2] + u[1]^2, u[1] + u[2]^2
end 

function func2!(z, u)
    z[1] = u[2] + u[1]^2
    z[2] = u[1] + u[2]^2
end
```
Both functions will do the same calculations, but `func1` returns the values, which requires allocating an array/tuple to store it in, while `func2!` mutates the first parameter to return the value. These are simply two version of the same function. The first is called an *out-of-place* function and the second, an *in-place* function. Sound familiar? We saw these in the chapter on differential equations.

How do we use them? We need to tell Julia to evaluate the expression to generate the code:

```julia
myf1 = eval(f_expr[1])
# #7 (generic function with 1 method)

myf1([1, 2])
# 2-element Vector{Int64}:
#  3
#  5

myf2! = eval(f_expr[2])
# #9 (generic function with 1 method)

z = zeros(Int, 2)
# 2-element Vector{Int64}:
#  0
#  0

myf2!(z, [1, 2])

z
# 2-element Vector{Int64}:
#  3
#  5
```

This is the key functionality from Symbolics we want to use. But we won't use it directly. Rather, we shall use the [ModelingToolkit](https://docs.sciml.ai/ModelingToolkit/stable/) package, that builds on Symbolics and makes it easy to specify systems of equations, differential or non-linear, and then solve them with numerical solvers.

## Modeling Toolkit
