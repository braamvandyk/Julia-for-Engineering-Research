[
  {
    "objectID": "01_Getting_started_with_Julia.html",
    "href": "01_Getting_started_with_Julia.html",
    "title": "Getting Started with Julia",
    "section": "",
    "text": "There are a vast number of articles on the internet on the topic of why you would want to use Julia. I’ll briefly explain why I prefer programming in Julia and think you may too.\nEveryone who either programs seriously, or merely dabbles in code, likely has a personal favourite programming language. It may be that they only know one language. Professional programmers often have more than one language they work in, and often prefer a certain tool for specific tasks. It is a simple fact that some languages are better for certain tasks than others for various reasons.\nJulia was conceived with technical programming in mind. It has its origins in academia, being developed at MIT, and is still mostly used by researchers, in natural and engineering sciences, computer science, mathematics, machine learning and many other fields. Commercial software written in Julia is available, e.g., Pumas for pharmaceutical drug discovery, or TIM for automatically building predictive models from time-series data. The bulk of work done in Julia, however, is in research and development, in academia, but also at approximately 10,000 companies and institutions world-wide, including AstraZeneca, BlackRock, Google, Intel, Microsoft, Moderna, Pfizer, NASA, the Federal Aviation Administration and the Federal Reserve Bank of New York to name a few. Julia is taught in over 1,500 universities, including MIT, Stanford and UC Berkley.\nJulia was designed to solve the so-called two language problem. This is where a researcher develops algorithms in a high-level dynamic language, such as Python, Matlab or R, where it is easy to interact with the code and change things around with little effort. At some point however, they find the need to speed up the code as it becomes more complex. This often results in a rewrite of the program in a fast, low-level language, such as C or Fortran. Julia is a dynamic language but generates code as fast as anything you can do in C, without the arcane syntax and multiple built-in ways to shoot yourself in the foot. This doesn’t imply that your Julia code is always fast. It is possible to write slow code in any language. It is just a whole lot easier to write fast code in Julia. When you run into speed problems in Python or R, the only solution is to call libraries written in C, with Python or R wrappers. In Julia, your fast code is usually 100% Julia code - you don’t need to know a second, fast language. In addition, Julia plays well with C, Python and R and you can call code written in any of these directly from Julia and vice versa.\nJulia is open-source and free. There are thousands of packages available in Julia - also open-sourced and free. Since Julia was developed for technical programming, most of these packages similarly are for solving technical problems. There are however also many others, from web development to animation and just about anything in between. Linear algebra is baked right into the language, including working with sparse matrices, so is parallel programming - multithreading and multiprocessing. There are very powerful differential equation solvers, non-linear equation solvers, optimisers, machine learning libraries, and even thermodynamic property libraries readily and freely available.\nJulia’s syntax borrows the best parts from Matlab, Python and Lisp. A lot of effort has gone into making it easier to learn the syntax. That said, there is always some learning curve when venturing into a new programming language. Like you can only learn to ride a bicycle by climbing on one and starting to pedal, the only way to learn programming and programming languages is to write code."
  },
  {
    "objectID": "01_Getting_started_with_Julia.html#why-julia",
    "href": "01_Getting_started_with_Julia.html#why-julia",
    "title": "Getting Started with Julia",
    "section": "",
    "text": "There are a vast number of articles on the internet on the topic of why you would want to use Julia. I’ll briefly explain why I prefer programming in Julia and think you may too.\nEveryone who either programs seriously, or merely dabbles in code, likely has a personal favourite programming language. It may be that they only know one language. Professional programmers often have more than one language they work in, and often prefer a certain tool for specific tasks. It is a simple fact that some languages are better for certain tasks than others for various reasons.\nJulia was conceived with technical programming in mind. It has its origins in academia, being developed at MIT, and is still mostly used by researchers, in natural and engineering sciences, computer science, mathematics, machine learning and many other fields. Commercial software written in Julia is available, e.g., Pumas for pharmaceutical drug discovery, or TIM for automatically building predictive models from time-series data. The bulk of work done in Julia, however, is in research and development, in academia, but also at approximately 10,000 companies and institutions world-wide, including AstraZeneca, BlackRock, Google, Intel, Microsoft, Moderna, Pfizer, NASA, the Federal Aviation Administration and the Federal Reserve Bank of New York to name a few. Julia is taught in over 1,500 universities, including MIT, Stanford and UC Berkley.\nJulia was designed to solve the so-called two language problem. This is where a researcher develops algorithms in a high-level dynamic language, such as Python, Matlab or R, where it is easy to interact with the code and change things around with little effort. At some point however, they find the need to speed up the code as it becomes more complex. This often results in a rewrite of the program in a fast, low-level language, such as C or Fortran. Julia is a dynamic language but generates code as fast as anything you can do in C, without the arcane syntax and multiple built-in ways to shoot yourself in the foot. This doesn’t imply that your Julia code is always fast. It is possible to write slow code in any language. It is just a whole lot easier to write fast code in Julia. When you run into speed problems in Python or R, the only solution is to call libraries written in C, with Python or R wrappers. In Julia, your fast code is usually 100% Julia code - you don’t need to know a second, fast language. In addition, Julia plays well with C, Python and R and you can call code written in any of these directly from Julia and vice versa.\nJulia is open-source and free. There are thousands of packages available in Julia - also open-sourced and free. Since Julia was developed for technical programming, most of these packages similarly are for solving technical problems. There are however also many others, from web development to animation and just about anything in between. Linear algebra is baked right into the language, including working with sparse matrices, so is parallel programming - multithreading and multiprocessing. There are very powerful differential equation solvers, non-linear equation solvers, optimisers, machine learning libraries, and even thermodynamic property libraries readily and freely available.\nJulia’s syntax borrows the best parts from Matlab, Python and Lisp. A lot of effort has gone into making it easier to learn the syntax. That said, there is always some learning curve when venturing into a new programming language. Like you can only learn to ride a bicycle by climbing on one and starting to pedal, the only way to learn programming and programming languages is to write code."
  },
  {
    "objectID": "01_Getting_started_with_Julia.html#why-julia-code-is-fast",
    "href": "01_Getting_started_with_Julia.html#why-julia-code-is-fast",
    "title": "Getting Started with Julia",
    "section": "Why Julia code is fast",
    "text": "Why Julia code is fast\nThe defining paradigm in Julia is multiple dispatch. Unless you are a computer scientist, that probably doesn’t mean much to you. I’ll try to explain simply with some examples.\nHere is a little Julia code. Don’t worry if you don’t know the syntax yet. We are just defining a function that takes two inputs a and b and returns 2b + a. Note that we don’t need a multiplication sign between the 2 and b in Julia - the language attempts to follow standard mathematical syntax where possible. You can also use any Unicode symbols, like Greek letters, subscripts and superscripts for variable names. Just don’t get carried away with those1.\nfunction myfunc(a, b)\n    return 2b + a\nend\nWe enter the code at the Julia REPL (we’ll get to this soon) and call it with some values for a and b:\nfunction myfunc(a, b)\n    return 2b + a\nend\n# myfunc (generic function with 1 method)\n\nmyfunc(1, 2)\n# 5\n\nmyfunc(1.0, 2.0)\n# 5.0\nThe first thing to notice is that, unlike in languages like C, Basic, Pascal or Fortran, we never specified the types of the variable, i.e., whether they are integers or floating-point values (numbers with fractional parts). There are times when you want to do this, but generally you would not. However, when we called the function with two integers, the answer was returned as an integer. When we called the code with two floating-point values, the answer was returned as a floating-point value.\nWhat happened behind the scenes? Julia infers the types of all of the inputs and generates the optimal code for that collection of input types. We can see this in action by asking Julia to show us the code it generated2:\n@code_llvm myfunc(1, 2)\n\n;  @ REPL[1]:1 within `myfunc`\n; Function Attrs: uwtable\ndefine i64 @julia_myfunc_172(i64 signext %0, i64 signext %1) #0 {\ntop:\n;  @ REPL[1]:2 within `myfunc`\n; ┌ @ int.jl:88 within `*`\n   %2 = shl i64 %1, 1\n; └\n; ┌ @ int.jl:87 within `+`\n   %3 = add i64 %2, %0\n; └\n  ret i64 %3\n}\nMost of what you see here is going to look like hieroglyphics, but don’t worry. You can ignore any line that starts with a semi-colon. These are automatically generated comments. The first line of actual code is:\ndefine i64 @julia_myfunc_172(i64 signext %0, i64 signext %1) #0 {\nThis defines a function (with a unique name - you’ll understand later why this is done) that returns a type i64, a 64-bit integer, and accepts two inputs, %0 and %1, both of type i64.\nThe next line is:\n%2 = shl i64 %1, 1\nThis shifts the value in %1 left by one bit and stores the result in a new variable, %2. If you know binary numbers3, you will know that this means the value is multiplied by two, just like shifting a decimal number left by one position multiplies the value by ten.\nThe next line is:\n%3 = add i64 %2, %0\nThis creates a new variable, %3 and writes into this variable the result of adding %2 and %0.\nFinally, we have\nret i64 %3\nThis returns the value in %3, as an i64, a 64-bit integer.\nWithout breaking your head about the details, you should appreciate that this is code that is optimised for the case where we passed two integers, including using a shl (shift left) operation, rather than the machine multiplication instruction, as the former is faster.\nNow let’s see what we get when we pass to 64-bit floating-point values.\n@code_llvm myfunc(1.0, 2.0)\n# ;  @ REPL[1]:1 within `myfunc`\n# ; Function Attrs: uwtable\n# define double @julia_myfunc_191(double %0, double %1) #0 {\n# top:\n# ;  @ REPL[1]:2 within `myfunc`\n# ; ┌ @ promotion.jl:389 within `*` @ float.jl:385\n#    %2 = fmul double %1, 2.000000e+00\n# ; └\n# ; ┌ @ float.jl:383 within `+`\n#    %3 = fadd double %2, %0\n# ; └\n#   ret double %3\n# }\nThe function definition looks similar to the previous case, expect that we now have variables of type double, rather than i64.\nThe next line:\n%2 = fmul double %1, 2.000000e+00\nSince we can’t simply shift a floating-point value left by one bit to multiply it by two, the fmul instruction, floating-point multiplication, is used to multiply the value in %1 by 2.0. Then, in the next line, the fadd (floating-point addition) instruction adds the result from the multiplication to %0:\n%3 = fadd double %2, %0\n\n\n\n\n\n\nNote\n\n\n\nThe important thing to learn from this is that Julia built optimised versions of the function for each case. Similarly, if we pass an integer and a floating-point value, or vice versa, or any two other appropriate types of values, new versions of the function will be constructed and each will be optimised for that combination of types passed.\n\n\nIt goes even further.\nA = [1 2;\n     3 4]\n# 2×2 Matrix{Int64}:\n#  1  2\n#  3  4\n\nB = [5 6;\n     7 8]\n# 2×2 Matrix{Int64}:\n#  5  6\n#  7  8\n\nmyfunc(A, B)\n# 2×2 Matrix{Int64}:\n#  11  14\n#  17  20\nHere we defined to 2x2 matrices of 64-bit integers and passed those to our function. And it just works! More so, the code was again optimised for handling these types of variables.\nThis is how Julia generates fast code. The original function we defined without specifying variable types is called a generic function. Julia then builds specialised version of the function based on the types of the variables we passed. Whenever we call the function, Julia checks if it has already compiled an appropriate version and then calls that version. If not, it compiles a new, specialised version to use.\nThis allows you to generate the fastest possible code, but for large pieces of code, this also results in a delay while the code is compiled. This is called TTFX (Time to First X) or often just Time to First Plot, as this is especially noticeable when calling the various plotting libraries in Julia. The first time to call a plotting function, there is a considerable delay. Every time after that, the plotting is lightning fast.\n@time using Plots\n  # 6.401451 seconds (8.83 M allocations: 612.705 MiB, 2.67% gc time, 11.00% compilation time: 3% of which was recompilation)\n\n@time scatter(randn(10), randn(10))\n  # 1.152227 seconds (93.64 k allocations: 4.612 MiB, 99.65% compilation time)\n\n@time scatter(randn(10), randn(10))\n  # 0.000392 seconds (414 allocations: 43.344 KiB)\nIt takes 6.4 seconds to import the Plots package. The first time we call scatter to generate a scatter plot, the code is compiled, which takes 1.15 seconds. The next time however, the compiled code is already available, and it takes 0.4 milliseconds to generate the plot. Every subsequent call to scatter, with the same types of values passed to it, will also be fast.\nIn every new version of the Julia compiler, some work is included to reduce he latency of TTFX. The latest version of Julia at the time of writing, v1.9, includes several new features to significantly reduce the problem. This is not magic though, merely a tool set that allows package authors to increase the amount of code that is precompiled when the package is installed. This will only help if the tools are used. Since the Julia community is generally very enthusiastic about speed, it is reasonable to expect most, if not all of them will indeed do so."
  },
  {
    "objectID": "01_Getting_started_with_Julia.html#julia-for-people-in-a-hurry",
    "href": "01_Getting_started_with_Julia.html#julia-for-people-in-a-hurry",
    "title": "Getting Started with Julia",
    "section": "Julia for people in a hurry",
    "text": "Julia for people in a hurry\nSome of the people reading this document will be experienced programmers and some will be masters of numerical methods. Most of you won’t be either, but still want to solve a technical problem. Here Julia is your friend.\nAny commonly used numerical methods you are likely to want to use, are likely already available in a package, generally written by people with PhDs in the relevant field and optimised to the nth degree by researchers who needed this before you did, and contributed to the openly available source code. Sometimes, the methods are already built into Julia, as is the case for linear algebra.\nLet’s say you want to factorise a matrix. You could pull your linear algebra textbook and your numerical methods notes off the shelf and remind yourself which factorisation methods are best suited to your type of matrix and how those methods work, then code your own copy. Or you could just let Julia take care of it for you:\nA = rand(5, 5) #create a random matrix\n# 5×5 Matrix{Float64}:\n#  0.80492   0.282962  0.470656  0.947669   0.185726\n#  0.201024  0.65166   0.827719  0.759129   0.597441\n#  0.391872  0.829147  0.437748  0.0278852  0.0868745\n#  0.583262  0.934832  0.187209  0.771838   0.373839\n#  0.424062  0.973599  0.7794    0.917351   0.0827884\nB = A*A' #create a symmetric matrix by multiplying A with its transpose\n# 5×5 Matrix{Float64}:\n#  1.88205   1.56614  0.798632  1.62299  1.86838\n#  1.56614   2.0834   1.0545    1.69067  2.11067\n#  0.798632  1.0545   1.041     1.13963  1.34739\n#  1.62299   1.69067  1.13963   1.98464  2.0424\n#  1.86838   2.11067  1.34739   2.0424   2.58357\n\nfactorize(A)\n# LU{Float64, Matrix{Float64}, Vector{Int64}}\n# L factor:\n# 5×5 Matrix{Float64}:\n#  1.0       0.0        0.0        0.0       0.0\n#  0.526837  1.0        0.0        0.0       0.0\n#  0.724621  0.885107   1.0        0.0       0.0\n#  0.486846  0.83853    0.379704   1.0       0.0\n#  0.249744  0.70464   -0.537792  -0.110424  1.0\n# U factor:\n# 5×5 Matrix{Float64}:\n#  0.80492  0.282962   0.470656   0.947669   0.185726\n#  0.0      0.824524   0.531441   0.418083  -0.0150591\n#  0.0      0.0       -0.62422   -0.284911   0.252587\n#  0.0      0.0        0.0       -0.675877  -0.0868263\n#  0.0      0.0        0.0        0.0        0.68792\n\nfactorize(B)\n# Cholesky{Float64, Matrix{Float64}}\n# U factor:\n# 5×5 UpperTriangular{Float64, Matrix{Float64}}:\n#  1.37188  1.1416    0.582145  1.18304   1.36191\n#   ⋅       0.883262  0.441459  0.385059  0.62939\n#   ⋅        ⋅        0.712192  0.394468  0.38853\n#   ⋅        ⋅         ⋅        0.53026   0.0671023\n#   ⋅        ⋅         ⋅         ⋅        0.420928\nFor the sake of examples, we create a random 5x5 matrix, A and then multiply it by its transpose to create a symmetric matrix, B. We then ask Julia to factorise both, by calling the factorize() function (note the American spelling!).\nFor the square, random matrix, LU decomposition is the most appropriate method and that is what we get. For the symmetric matrix, Cholesky’s methods is the most efficient and hence that is what Julia uses. It will also use other specialised methods for other specific matrix types. See the manual for details. When you use the factorised matrix in computations, further specialised, optimised methods will be used, depending on the factorisation that was used. You can of course just call specific factorisation methods, such as lu() or qr() as well.\nAlso note that the Cholesky factorisation returns a specialised type of matrix, UpperTriangular{Float64, Matrix{Float64}}, which also has specialised calculations methods that take advantage of knowledge of the structure of the matrix.\nIn a similar fashion, when solving differential equations, the DifferentialEquations.jl package can easily switch between algorithms, and automatically detect stiffness and switch to an implicit solver as needed. You can help it along by supplying a hint that the problem is stiff, or you can specify which methods you want to use. For stiff problems, several implicit methods are available, and the package will use automatic differentiation to generate the higher level derivatives needed for these with low overheads.\nThese things don’t happen through magic, although it may look like it. The code, either in the Julia standard library or in a user-supplied package, was simply written by experts in the field. This means you can get away with knowing a little less about the intricacies of the mathematics than you would be able to if you had to write everything yourself. This by no means implies you shouldn’t learn more about the mathematics and numerical methods! More knowledge will always give better results."
  },
  {
    "objectID": "01_Getting_started_with_Julia.html#powerful-plotting-and-data-processing",
    "href": "01_Getting_started_with_Julia.html#powerful-plotting-and-data-processing",
    "title": "Getting Started with Julia",
    "section": "Powerful plotting and data processing",
    "text": "Powerful plotting and data processing\nJulia has several powerful plotting libraries available for data visualisation. You can use Plots.jl as a unified front-end for several plotting engines, like GR, Plotly or PyPlot. You may prefer to use Makie - a Julia-specific plotting library with that gives you extreme control over every aspect of the plot, including interactivity. You may prefer to add statistical analyses to the plot via StatsPlots.jl, GadFly.jl or AlgebraOfGraphics.jl.\n\n\n\nA Makie generated plot.\n\n\n\n\n\nAn AlgebraOfGraphics generated plot.\n\n\nJulia has one of the fastest tools for reading data files, in CSV.jl, or you can prefer to manipulate your Excel files directly from Julia with XLSX.jl. Tabular data can be easily handled with DataFrames.jl and you can even execute SQL-like queries on the data via Query.jl. If you need to add units to your numbers, then Unitful.jl is for you."
  },
  {
    "objectID": "01_Getting_started_with_Julia.html#and-much-much-more",
    "href": "01_Getting_started_with_Julia.html#and-much-much-more",
    "title": "Getting Started with Julia",
    "section": "And much, much more",
    "text": "And much, much more\nThere are likely Julia packages for any task you wish to attempt. And if there isn’t a Julia-specific package, there is probably a wrapper for a Python or C library.\nBecause of Julia’s generic code, code re-use in Julia is much more common than in any other language, as was illustrated when we passed matrices to your little example function before. It is often possible to combine packages that have little if anything to do with each other to solve a problem.\nWriting generic code is encouraged in the Julia ecosystem specifically to enable this. Rather than needing some all-encompassing package to solve your problem, you simply combine a few smaller, simpler and more easily optimised packaged to get the result you need."
  },
  {
    "objectID": "01_Getting_started_with_Julia.html#when-not-to-use-julia",
    "href": "01_Getting_started_with_Julia.html#when-not-to-use-julia",
    "title": "Getting Started with Julia",
    "section": "When NOT to use Julia",
    "text": "When NOT to use Julia\nThere are of course instances where Julia is not the optimal choice.\nIf you want to compile a model to a binary file, Julia is likely not the best tool. While it is perfectly possible to compile Julia code to, e.g., a DLL file, the dynamic nature of Julia means that the entire Julia run-time is included in the file. This means a VERY large file is produced. This is an area of active development, and it is possible in some cases to compile small files, but at this time, there are better tools.\nIf you want to distribute your code to other people, but do not want to give them access to the source code, Julia may not be your first choice. It is again possible, and one way of doing this is by running your code on a server and giving the users access via a web page or Excel front-end, but it is not as simple as just compiling a DLL or EXE file in C or Visual Basic.\nIf you need to create a user interface with minimal effort, Excel is probably a better choice, especially if you intend to distribute the code. It is however possible (and not too difficult) to use Excel as a front-end for Julia code too."
  },
  {
    "objectID": "01_Getting_started_with_Julia.html#footnotes",
    "href": "01_Getting_started_with_Julia.html#footnotes",
    "title": "Getting Started with Julia",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nConsider how easily one can confuse p and ρ in code. Obviously, if ρ is a standard symbol, like for density, it is less likely to be confusing to someone used to the use of the Greek letter, but using it for some random variable in your code is inviting trouble.↩︎\nJulia generates LLVM code and then uses LLVM to generate code optimised for your specific CPU. LLVM is somewhat similar to an assembler, for those familiar with the term.↩︎\nThere are 10 types of people in the world. Those who understand binary and those who don’t.↩︎"
  },
  {
    "objectID": "02_Installing_Julia.html",
    "href": "02_Installing_Julia.html",
    "title": "Installing Julia",
    "section": "",
    "text": "To use Julia, you need two things:\nIt is also recommended that you consider a few additional tools, although they are optional."
  },
  {
    "objectID": "02_Installing_Julia.html#windows-terminal",
    "href": "02_Installing_Julia.html#windows-terminal",
    "title": "Installing Julia",
    "section": "Windows Terminal",
    "text": "Windows Terminal\nWhile not strictly required, installing Windows Terminal is highly recommended. Windows Terminal is a much more modern replacement for the venerable Windows command prompt. It has the same features as a typical Linux terminal and will make your experience of the Julia REPL a lot more pleasant.\nIf you are going to use Windows Terminal, install it first, from the Microsoft Store. If you then install Julia or Git, they will automatically configure themselves in Windows Terminal."
  },
  {
    "objectID": "02_Installing_Julia.html#the-julia-compiler",
    "href": "02_Installing_Julia.html#the-julia-compiler",
    "title": "Installing Julia",
    "section": "The Julia compiler",
    "text": "The Julia compiler\nThere are several ways to install Julia on your machine, whether or not you have local administrator rights. Julia will happily run from a user-only installation, or you can install it for all users on your machine. You can also use a portable (not installed) version.\n\nDirect download and install\nYou can download and install Julia from the official homepage. The 64-bit version is recommended, unless you have a specific reason to want a 32-bit version.\n\n\nMicrosoft Store\nThe recommended way of installing Julia, if this is an option for you, is via the Microsoft Store. Installing Julia this way actually installs JuliaUp, an installation manager for Julia.\nJuliaUp allows you to have multiple installations of Julia, e.g., the current release version as well as the current development (pre-release) version.\nYou can easily switch between them with a single command-line instruction. JuliaUp will also automatically keep your Julia installation updated when a new version is released.\nYou can install from the Microsoft Store application, or from the command-line with:\nwinget install julia -s msstore\nYou can then add and manage various Julia installations using the JuliaUp tool, e.g.\njuliaup add release         # add the current release channel\njuliaup add rc              # add current release candidate channel\njuliaup add beta            # add current beta channel\njuliaup st                  # get status of installed versions\njuliaup default release     # set the version to use\njulia --help                # see the help options\nYou can also directly launch a specific installed channel, e.g.\njulia +rc"
  },
  {
    "objectID": "02_Installing_Julia.html#visual-studio-code",
    "href": "02_Installing_Julia.html#visual-studio-code",
    "title": "Installing Julia",
    "section": "Visual Studio Code",
    "text": "Visual Studio Code\nThe recommended code editor for Julia is Visual Studio Code (VSCode). This is a Microsoft project that is free and partially open-sourced. You can download and install it from the official homepage or via the Microsoft Store.\nVSCode will prompt you to install updates, so there is less reason to want to install this from the Microsoft Store. New releases are typically available monthly.\n\nThe Julia Add-in for VSCode\nVSCode is a general-purpose code editor. To use it with Julia, you need to install the Julia add-in from within VSCode. You can also install Python, R, C, Fortran and many other add-ins.\nIf you are adventurous, you can install the insider version of the Julia add-in, but this is not recommended for for typical end-users. The insider version is the pre-release version with newer, but not yet fully tested features.\nThe Julia add-in not only links Julia to VSCode seamlessly, but it also provides a debugger and many other tools, like compiling system images for quicker start-up.\nSee the documentation for more information.\n\n\nOther Useful Add-ins\nSome add-ins recommended for everyday use are:\n\nEdit CSV\nRainbow CSV\nSandDance for VSCode\nSVG\n\nEdit CSV allows for easy editing CSV (Comma-Separated Values) files right within VSCode, so you don’t need to go back to Excel for small edits.\nRainbow CSV colour-codes the columns in CSV files, making it much easier to work with them.\nSandDance generates plots of the data in a CSV for quick data exploration.\nSVG allows you to preview SVG (Scalable Vector Graphics) files inside VSCode. Most of the plotting packages can save plots as SVG files, which is recommended, since you can zoom in or out infinitely without loss of quality. Microsoft Office can include SVG files in, e.g., Word and PowerPoint.\nFor writing technical documents that include running code, e.g., to generate the plots, and to publish these to web pages, .PDF or DOCX documents, among others, consider Quarto (this will require the installation of the Quarto program as well as the VSCode add-in)"
  },
  {
    "objectID": "02_Installing_Julia.html#fonts",
    "href": "02_Installing_Julia.html#fonts",
    "title": "Installing Julia",
    "section": "Fonts",
    "text": "Fonts\nJulia can make full use of Unicode fonts. This means you can use Greek letters, emojis or anything else as variable names. Julia will also use common mathematical symbols, although there are alternatives for those who prefer to stick to ASCII. For examples:\nmass = 1.23\nvol = 2.56\n\nρ = mass/vol\nif 0.1 ≤ ρ ≤ 1.0\n    if ρ ≈ 0.48\n        println(\"Correct\")\n    end\nend\nThis reads a lot more like what you would normally write out by hand, e.g., using ρ instead of rho. In the place of ≈, you can use the isapprox() function, which has a few more options.\nIf you are using a font that supports font ligatures, you may see ≤ symbols instead of &lt;, followed by =. This is entirely optional as well. You simply type a &lt; followed by =, and with the correct fonts installed, this will automatically be rendered as ≤ without changing the contents of the actual source code file. If you don’t like that, just change the option in VSCode that allows use of font ligatures.\nTo make use of the Unicode abilities in you need a font installed that can handle ligatures and has a decent coverage of Unicode symbols. The following are recommended - JetBrains Mono - JuliaMono - Fira Code\nVSCode uses fall-back fonts, so if the first font specified in the settings does not include the character it should render, it will look in the next font until it finds the glyph, or runs out of fonts to look in. You can therefore install all three these fonts and then add them to the from of the list of specified fonts.\nYou use Unicode characters by typing, e.g., \\rho and pressing the &lt;tab&gt; key. If you find a character in someone’s code that you don’t know how to type, simply copy it and paste it next to the help1 prompt in Julia:\nhelp?&gt; ℱ\n\"ℱ\" can be typed by \\scrF&lt;tab&gt;\nThere is a comprehensive list available in the manual."
  },
  {
    "objectID": "02_Installing_Julia.html#git",
    "href": "02_Installing_Julia.html#git",
    "title": "Installing Julia",
    "section": "Git",
    "text": "Git\nGit is a version control software. No, more accurately, Git is THE version control software. You do not need to use Git, but it will most certainly make your life a lot easier if you are either working in a team or working on large projects.\nGit is integrated into VSCode, but it is often handy to have the command-line version. You can get it from the Git homepage. Like Julia and VSCode, Git is free and open-sourced.\nIt is worth your time to learn at least the basics of Git. There is a free book, available on-line, to assist you: Pro Git"
  },
  {
    "objectID": "02_Installing_Julia.html#footnotes",
    "href": "02_Installing_Julia.html#footnotes",
    "title": "Installing Julia",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nYou access the help mode by typing ? at the REPL prompt.↩︎"
  },
  {
    "objectID": "03_Running_Julia.html",
    "href": "03_Running_Julia.html",
    "title": "Running Julia",
    "section": "",
    "text": "When you open up Julia, you will be presented with the REPL (Read Execute Print Loop). This is basically a command prompt that Reads your input, Executes the instructions, Prints the results and then Loops back to waiting for a new input.\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.9.1 (2023-06-07)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia&gt;\nYou can enter code directly at the julia&gt; prompt, but since none of this will be saved, it is probably not the preferred way of coding.\nA better way would be to save your code into a file, e.g. myscript.jl, and then execute this script by using the include() command. For example, if the file myscript.jl includes the following:\nusing UnicodePlots\n\nbarplot([\"A\", \"B\", \"C\"], rand(3))\nthen my can run the script as follows:\ninclude(\"myscript.jl\")\n  #    ┌                                        ┐\n  #  A ┤■■■■■■■■■■■■■■■■■■■ 0.479201\n  #  B ┤■■■■■■■■■■■■■■■■ 0.394627\n  #  C ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.754307\n  #    └                                        ┘\nYou can also run the script from the command line with:\njulia myscript.jl\nThe REPL has a few modes. You can access the package manager by pressing ] at the julia&gt; prompt. To access the help mode, use ? (also inside the package manager). You can also access the underlying shell with ;, but unless you are running Julia inside Windows Terminal, very little will work in Shell Mode.\nWhile it is good to be familiar with the REPL, realistically speaking, the most common thing the average user will do in the REPL is to access the package manager. This is where to install or remove packages and update installed packages.\nYou can use Unicode characters in the REPL, but unless you are using Windows Terminal, most non-ASCII characters won’t display properly.\n\n\nThe REPL has command line completion. For example, if you typed:\ninclude(\"myscript.jl\")\nin the previous example, then typing inc and pressing the up cursor will repeat the previous line that started with inc, i.e. include(\"myscript.jl\").\nYou could also start typing a command and hit &lt;tab&gt; to get full command suggestions with some intelligence built-in. E.g., type prin and hit &lt;tab&gt;. Julia will complete the command to print. Hit &lt;tab&gt; again, and you get:\njulia&gt; print\nprint        println      printstyled\njulia&gt; print\nSince there are more than one command that starts with print, Julia lists them all, creates a new prompt and starts off with the letters print, so you can complete the line.\nYou can clear the REPL with ctrl-L and close it with ctrl-D on an empty line."
  },
  {
    "objectID": "03_Running_Julia.html#the-repl",
    "href": "03_Running_Julia.html#the-repl",
    "title": "Running Julia",
    "section": "",
    "text": "When you open up Julia, you will be presented with the REPL (Read Execute Print Loop). This is basically a command prompt that Reads your input, Executes the instructions, Prints the results and then Loops back to waiting for a new input.\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.9.1 (2023-06-07)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia&gt;\nYou can enter code directly at the julia&gt; prompt, but since none of this will be saved, it is probably not the preferred way of coding.\nA better way would be to save your code into a file, e.g. myscript.jl, and then execute this script by using the include() command. For example, if the file myscript.jl includes the following:\nusing UnicodePlots\n\nbarplot([\"A\", \"B\", \"C\"], rand(3))\nthen my can run the script as follows:\ninclude(\"myscript.jl\")\n  #    ┌                                        ┐\n  #  A ┤■■■■■■■■■■■■■■■■■■■ 0.479201\n  #  B ┤■■■■■■■■■■■■■■■■ 0.394627\n  #  C ┤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ 0.754307\n  #    └                                        ┘\nYou can also run the script from the command line with:\njulia myscript.jl\nThe REPL has a few modes. You can access the package manager by pressing ] at the julia&gt; prompt. To access the help mode, use ? (also inside the package manager). You can also access the underlying shell with ;, but unless you are running Julia inside Windows Terminal, very little will work in Shell Mode.\nWhile it is good to be familiar with the REPL, realistically speaking, the most common thing the average user will do in the REPL is to access the package manager. This is where to install or remove packages and update installed packages.\nYou can use Unicode characters in the REPL, but unless you are using Windows Terminal, most non-ASCII characters won’t display properly.\n\n\nThe REPL has command line completion. For example, if you typed:\ninclude(\"myscript.jl\")\nin the previous example, then typing inc and pressing the up cursor will repeat the previous line that started with inc, i.e. include(\"myscript.jl\").\nYou could also start typing a command and hit &lt;tab&gt; to get full command suggestions with some intelligence built-in. E.g., type prin and hit &lt;tab&gt;. Julia will complete the command to print. Hit &lt;tab&gt; again, and you get:\njulia&gt; print\nprint        println      printstyled\njulia&gt; print\nSince there are more than one command that starts with print, Julia lists them all, creates a new prompt and starts off with the letters print, so you can complete the line.\nYou can clear the REPL with ctrl-L and close it with ctrl-D on an empty line."
  },
  {
    "objectID": "03_Running_Julia.html#running-julia-inside-vscode",
    "href": "03_Running_Julia.html#running-julia-inside-vscode",
    "title": "Running Julia",
    "section": "Running Julia inside VSCode",
    "text": "Running Julia inside VSCode\nOne of the most common ways of working with Julia is from inside VSCode. If everything is set up correctly, simply do the following\n\nCreate a folder for your project\nRight click inside the folder in Windows Explorer and select Open with Code. This will start up VSCode and open the folder inside the editor.\nAdd a file to contain your code. Be sure to give it a .jl extension, so VSCode can identify it as Julia code.\n\nNow you can enter code.\nTo execute the code, either click the run button to execute the whole file, or click on a line you want to execute and hit Shift-Enter to execute the code block. A code block is intelligently identified, so if the line you are on is inside a function definition, for example, the function will be compiled.\nOnce you are executing code, a Julia REPL will be open in the Terminal inside VSCode. Anything you can do in the REPL can be done here. The Julia add-in also provides more features, like listing all existing variables in the current scope and their values, as well as a plot pane and many other useful tools, such as debugger and a profiler."
  },
  {
    "objectID": "03_Running_Julia.html#jupyter-and-pluto",
    "href": "03_Running_Julia.html#jupyter-and-pluto",
    "title": "Running Julia",
    "section": "Jupyter and Pluto",
    "text": "Jupyter and Pluto\nThere are two more useful tools for running Julia. Jupyter notebooks and Pluto notebooks.\nThese run inside your browser. Code is entered in cells and results displayed below (Jupyter) or above (Pluto) the cell after it is executed.\nThe main difference between the two is that Jupyter cells are static - they only run when you execute them manually, while Pluto is reactive. If a cell in Pluto assigns a value to a variable and is edited, then Pluto will also execute all other cells that use this variable. To enable this, you should limit Pluto cells to single statements, or wrap code in a begin..end block, but still limit it to a single assignment per cell.\nJupyter can be used with Python and R as well as Julia (the name Jupyter is from Julia, Python and R) as well as ~40 other languages. Pluto is only for Julia.\n\nInstalling Jupyter\nThe easiest way to install Jupyter is to add the IJulia.jl package to Julia from within the REPL. Julia will install a private copy of Python as well as all the add-ins it needs. To launch Jupyter, do the following from within Julia:\nusing IJulia\nnotebook(dir = \".\") # sets the starting folder to the current folder\nThis will open up your default browser and start Jupyter with the Julia kernel selected.\n\n\nInstalling Pluto\nPluto is installed as a Julia package, so just open the package manager and add Pluto.\nTo launch Pluto, then do the following:\nusing Pluto\nPluto.run()\nThis will open your default browser and start Pluto."
  },
  {
    "objectID": "04_An_Overview_of_the_Language.html",
    "href": "04_An_Overview_of_the_Language.html",
    "title": "An Overview of the Language",
    "section": "",
    "text": "This section is meant to give you a running start in using Julia. The ultimate reference for all things regarding the language is the official manual, where you will find much more information."
  },
  {
    "objectID": "04_An_Overview_of_the_Language.html#package-management",
    "href": "04_An_Overview_of_the_Language.html#package-management",
    "title": "An Overview of the Language",
    "section": "Package Management",
    "text": "Package Management\nJulia will open up in the default environment, e.g., @v1.9. You can add packages to this environment, and they will be available to load as soon as you open Julia. Be very careful about doing this, as this can very often lead to what is lightly called dependency hell. This is what happens when a package you want to update depends on another package that can’t update, sometime because it depends on a specific version of yet another package. The more packages you have in the current environment, the more often this will happen. The correct solution is to create a new environment for each project and add only the packages you are actually using in the project.\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.9.1 (2023-06-07)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\ncd(\"./Dummy\")\n\npwd()\n# \"D:\\\\JuliaCode\\\\Dummy\"\n\n(@v1.9) pkg&gt; activate .   #type ] to activate package manager in REPL\n  # Activating project at `D:\\JuliaCode\\Dummy`\n\n(Dummy) pkg&gt; add UnicodePlots\n  #   Updating registry at `C:\\Users\\Braam\\.julia\\registries\\General.toml`\n  #  Resolving package versions...\n  #   Updating `D:\\JuliaCode\\Dummy\\Project.toml`\n  # [b8865327] + UnicodePlots v3.4.1\n  #   Updating `D:\\JuliaCode\\Dummy\\Manifest.toml`\n  # [d360d2e6] + ChainRulesCore v1.15.7\n  # [9e997f8a] + ChangesOfVariables v0.1.6\n  # [35d6a980] + ColorSchemes v3.20.0\n  # .\n  # .\n  # .\n\n(Dummy) pkg&gt; st\n# Status `D:\\JuliaCode\\Dummy\\Project.toml`\n#   [b8865327] UnicodePlots v3.4.1\nHere we changed the current directory to the Dummy sub-folder. Note the use of a forward slash. Backslashes are used for special characters, , \\n for a new line and must themselves be escaped by typing a double backslash: cd(\".\\\\Dummy\"). Or you can use a raw string: cd(raw\".\\Dummy\"). The forward slash however works just as well in Linux and MaxOS, so is preferred.\npwd() is a function that replicates the Unix (Linux) command for print working directory and simply returns the name of the current folder.\nThe package manager is then activated with ] and the current folder is activated as a project with activate ., where . means the current directory (.. means the parent directory).\nFinally, we add a registered package, UnicodePlots.jl, and once the installation is done, check which packages and versions are currently installed with the st command (short for status).\nOnce a package is installed, it can be loaded by issuing the using command:\nusing UnicodePlots\nIn the Dummy folder, Julia creates two files: project.toml and manifest.toml. These hold the record of the specific versions of packages that have been installed for this project. The packages directly installed are in the project.toml file, while the version numbers of dependencies are tracked in manifest.toml. These two files mean that someone else can reinstate the exact environment you developed your code in by activating the project and issuing the instantiate command to the package manager. This will install the same versions of the packages and dependencies as listed in the *.toml files.\nEach project should be in its own folder, with its own *.toml files. This means different projects can potentially use different versions of the same package, depending on what other packages are in use.\nTo update the packages and dependencies to the latest versions (as allowed for by the specified versions of dependencies for each package), use the up command of the package manager. This updates packages for the current project only."
  },
  {
    "objectID": "04_An_Overview_of_the_Language.html#using-vs-import",
    "href": "04_An_Overview_of_the_Language.html#using-vs-import",
    "title": "An Overview of the Language",
    "section": "Using vs Import",
    "text": "Using vs Import\nThere are two ways to load a Julia package: using and import\nIf you use using, all methods and variables exported by a package are brought into the current namespace. You can call them directly:\nusing Plots\n\nscatter(rand(10), rand(10))\nThis does mean that several functions and variables you are not using are now also in the namespace and you cannot define a new function with the same name or use another package that exports a function with the same name. For those cases, you can use import. If a package is imported, you need to prepend each function call with the package name.\nimport Plots\nimport GLMakie\n\nPlots.scatter(rand(10), rand(10))\nGLMakie.scatter(rand(10), rand(10))\n\n\n\n\n\n\nTry this\n\n\n\nSee what happens when you use using for the previous example.\n\n\nYou can load specific functions or variables from a package:\nusing Plots: scatter\nimport GLMakie: lines\nNone of the other exported variables or functions will become available. When loading a single item, you can also rename it using the as keyword:\nimport Plots.scatter as ps\nimport GLMakie: scatter as ms\n\nps(rand(10), rand(10))\nms(rand(10), rand(10))\nor even rename the package during import:\nimport BenchmarkTools as bt\n\nbt.@benchmark sin.(1:1_000_000)\n# BenchmarkTools.Trial: 400 samples with 1 evaluation.\n#  Range (min … max):  11.751 ms … 24.278 ms  ┊ GC (min … max): 0.00% … 49.13%\n#  Time  (median):     12.043 ms              ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   12.515 ms ±  2.246 ms  ┊ GC (mean ± σ):  3.56% ±  9.50%\n\n#   ▆█▅\n#   ████▆▁▄▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▁▅▇▆ ▆\n#   11.8 ms      Histogram: log(frequency) by time        24 ms &lt;\n\n#  Memory estimate: 7.63 MiB, allocs estimate: 2."
  },
  {
    "objectID": "04_An_Overview_of_the_Language.html#variables",
    "href": "04_An_Overview_of_the_Language.html#variables",
    "title": "An Overview of the Language",
    "section": "Variables",
    "text": "Variables\nThere is no programming without variables. In Julia, there is no need to pre-declare a variable (although you can) and variables can be reassigned to a value of another type:\nx = 1\n# 1\n\ntypeof(x)\n# Int64\n\nx = 2.4\n# 2.4\n\ntypeof(x)\n# Float64\n\nx = \"Hello, World\"\n# \"Hello, World\"\n\ntypeof(x)\n# String\nWhen assigning a value to the variable x, Julia infers the type of the value, e.g., Int64 and then associates the name, x, with that value.\nAs illustrated, the function typeof() will return the type of the variable or value. While you don’t have to specify the types of variables, Julia is a strongly typed language, just like C or Fortran. The type of a variable is just automatically inferred whenever possible.\nSince variables can be reassigned in the global scope, this makes it difficult for the compiler to generate optimised code - the type of the variable could change. If you want fast code, then avoid using global variables, or if you absolutely have to use them, declare them as const.\nconst MyConst = 1\n# 1\n\ntypeof(MyConst)\n# Int64\n\nMyConst = 2\n# WARNING: redefinition of constant MyConst. This may fail, cause incorrect answers, or produce other errors.\n# 2\n\nMyConst = 2.0\n# ERROR: invalid redefinition of constant MyConst\n# Stacktrace:\n#  [1] top-level scope\n#    @ REPL[4]:1\nDeclaring a variable as const freezes the type of the variable, allowing more optimisations. It is possible, but not recommended, to change the value, but not the type. It is expected that changes to the values will also be prevented in future versions of Julia.\nThe best practice, however, is to put your code inside functions.\n\nStrings and Characters\nText values are stored as either strings (\"This is a string\", type String) or single characters ('c', type Char). Note the use of double and single quotation marks for String vs Char. A string can be just one character long: \"A\". Strings can also include multiple lines, and quotation marks, when enclosed with triple quotation marks:\ns = \"\"\"\n    This is my\n    very long\n    string with \"quotes\"\n\"\"\"\n# \"This is my \\nvery long\\nstring with \\\"quotes\\\"\\n\"  \n\ns[5]\n# ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n\ns[5:10]\n# \" is my\"\nNote how new lines are indicated with '\\n', which is itself a character (n is short for new line).\nNumerical values can be converted to strings using the string() function:\nstring(123)\n# \"123\"\nStrings and characters in Julia are encoded in UTF-8 Unicode. This allows all kinds of characters, from mathematical symbols to Chinese characters and emojis to be used. It also means that not all glyphs take the same amount of memory to store. This can be confusing when processing strings. If you intend to work with strings, read the relevant sections of the manual carefully.\nA somewhat unintuitive feature of Julia is that string concatenation is done via the * operator. This does have the advantage that multiple copies of a string can be concatenated via the exponentiation (^) operator:\nstr = \"lala\"\n# \"lala\"\n\nstr*str\n# \"lalalala\"\n\nstr^5\n# \"lalalalalalalalalala\"\nJulia includes a vast number of string processing functions. These are discussed in detail in the manual.\n\nString Interpolation\nYou can interpolate a value from a variable or expression into a string, using the $ character:\nvalue = 1.0\n# 1.0\n\nkey = \"myvar\"\n# \"myvar\"\n\nprintln(\"The key is: $key and the value is: $value.\")\n# The key is: myvar and the value is: 1.0.\n\nprintln(\"Twice the value is: $(2*value)\")\n# Twice the value is: 2.0\n\n\n\nIntegers and Floating-point Values\nJulia has the usual selection of variable types for integers and floating-point values. There are signed and unsigned versions of 8, 16, 32, 64 and 128-bit integers. See the manual for details.\nThere is also a Bool type that holds either true (1) or false (0).\nFor floating-point values, there is Float16, Float32 and Float64.\nThe default integer, Int is equivalent to Int64 for 64-bit Julia and Int32 for 32-bit Julia. Generally, you would want to use Float64 for floating-point numbers, unless there is a specific reason not to. Calculations on a GPU (via e.g., CUDA.jl) should be done using Float32, unless you have a very expensive1 GPU capable of processing 64-bit floating point calculations.\n\nA Word on Floating-Point Values\nFloating-point values are stored in a limited number of bits (typically 64 bits - a.k.a. double precision) and hence have a limited precision. The result is that most values cannot be precisely stored in a Float64 variable. As a simple example, 1/10, which is clearly precisely equal to 0.1, is actually calculated as 0.1000000000000000055511151231257827021181583404541015625 with 256-bit precision.\nThe smallest positive value that can be stored in a Float64, is 2.220446049250313e-16. You can calculate this in Julia using the eps() function e.g., eps(Float64). The value epsilon is an indication of the precision you can expect. It is the smallest value you can add to the floating-point value that will cause it to result in a new value. Anything smaller may as well be zero. Obviously, epsilon depends on the magnitude of the values you are working with, and you can again use the eps() function: eps(100) = 1.4210854715202004e-14, so adding a smaller amount to 100 will not change the value.\nWhile you can safely ignore this for many, if not most engineering calculations, it can sometimes become an issue when you least expect it. Consider adding up a very large number of small values. The larger the difference between the running total and the next value you are adding, the larger the rounding error will become. At some point in this exercise, the value you are adding to the running total will be in the order of the relative epsilon and the running total will stop increasing, no matter how many more values you add. The solution to this is actually fairly simple and implemented in the Julia sum() function.\nThe list of values is split into pairs and the pairs are added to each other, then this is repeated over and over until there is only one value left - the answer. The algorithm works under the inherent assumption that the values are fairly equally sized and so adding similar values results in minimal rounding error. Once the pairs have been summed, the new values should also be similarly sized and so the process repeats, with a minimum rounding error at each step.\nSomething else to consider, which much more often trips up new programmers, is that you will very rarely find two identical floating-point values through calculations. Directly comparing values that are realistically speaking equal, will very often result in the wrong part of an if statement executing. When comparing floating-point values, always use a check for approximate equality. This is done either via the ≈ operator (\\approx&lt;tab&gt;), or the isapprox() function, which allows you to specify absolute and relative tolerances. The ≈ operator calls isapprox() with default tolerances.\nThe internal storage of floating-point values is standardised by the IEEE 754 standard, which is used in just about every programming language. This is important, since it means you can pass values between Julia and code running in R or Python or compiled in C.\n\n\n\nBigInt and BigFloat\nSometimes, you may find a need for additional precision. Arbitrary-precision integer and floating-point types are available as BigInt and BigFloat.\nThere are several ways to specify that you are using big numbers, but the simplest is via the big() function:\nx = big(10.0)\n# 10.0\n\ntypeof(x)\n# BigFloat\nThe precision again comes at the cost of performance. See the manual for more details. You only need to specify that one variable/number in a calculation is big - the rest will be converted automatically by Julia.\n\n\nComplex Numbers\nJulia has built-in types for complex numbers, which depend on the integer or floating-point type used to store the real and imaginary parts, e.g.\ntypeof(1 + 2im)\n# Complex{Int64}\n\ntypeof(1.0 + 2.0im)\n# ComplexF64 (alias for Complex{Float64})\nAs you will notice, a complex type is specified as Complex{T} where T is an integer or floating-point type. Any of the integer and floating-point types mentioned before could be used, including BigInt and BigFloat. Simply define the value as:\nz = big(10.0) + 1.0im\n# 10.0 + 1.0im\n\ntypeof(z)\n# Complex{BigFloat}\n\nz = big(10) + im\n# 10 + 1im\n\ntypeof(z)\n# Complex{BigInt}\nThe imaginary part of the number is indicated by adding im directly behind the number - no space! As shown in the example, the 1 is optional in the imaginary part - you can just specify im for 1im.\nThe expected functions for use with complex numbers are available, including:\nz = 1 + 1im\n# 1 + 1im\n\nreal(z) # real part\n# 1\n\nimag(z) # imaginary part\n# 1\n\nconj(z) # complex conjugate\n# 1 - 1im\n\nabs(z) # absolute value - distance from zero\n# 1.4142135623730951\n\nabs2(z) # squared absolute value\n# 2\n\nangle(z) # phase angle (radians)\n# 0.7853981633974483\n\nangle(z) * 360/2π # convert to degrees\n# 45.0\n\n√z\n# 1.09868411346781 + 0.45508986056222733im\n\nsqrt(z)\n# 1.09868411346781 + 0.45508986056222733im\n\n\nRational Numbers\nYou can also work with rational numbers.\na = 1//2 + 3//8\n# 7//8\n\nfloat(a)\n# 0.875\n\nrationalize(0.875)\n# 7//8\nThis eliminates rounding losses, but at a loss of performance:\nfunction myfunc(x)\n    sum = zero(x)\n    for i in 1:10_000\n        sum += x * i\n    end\n    return sum\nend\n\n# myfunc (generic function with 1 method)\n\nusing BenchmarkTools\n\n@benchmark myfunc(1.0)\n# BenchmarkTools.Trial: 10000 samples with 3 evaluations.\n#  Range (min … max):  8.500 μs …  73.733 μs  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     8.700 μs               ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   8.704 μs ± 966.620 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#   ▅  █  ▆  ▃         █  █   ▅  ▂  ▁   ▁  ▁                    ▂\n#   █▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁█▁▁▁▇▁▁█▁▁▇▁▁▄ █\n#   8.5 μs       Histogram: log(frequency) by time       9.1 μs &lt;\n\n#  Memory estimate: 0 bytes, allocs estimate: 0.\n\n@benchmark myfunc(1//1)\n# BenchmarkTools.Trial: 7295 samples with 1 evaluation.\n#  Range (min … max):  663.600 μs …  1.234 ms  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     680.100 μs              ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   682.504 μs ± 29.021 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#   ▇█▆▃▂▃██▅▄▃▃▃▂▃▁▁▁▁       ▁                                  ▂\n#   ███████████████████████▇▇████▇▇█▆▆▇▇▇▅▆▆▅▆▅▅▅▃▅▅▄▆▅▃▅▅▄▄▁▃▃▅ █\n#   664 μs        Histogram: log(frequency) by time       811 μs &lt;\n\n#  Memory estimate: 0 bytes, allocs estimate: 0.\nSo, floating-point calculations are about 78x faster than with rational numbers. What about integers?\n@benchmark myfunc(1)\n# BenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n#  Range (min … max):  1.900 ns … 27.200 ns  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     2.000 ns              ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   1.976 ns ±  0.530 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#   ▄                                                        █\n#   █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▂\n#   1.9 ns         Histogram: frequency by time           2 ns &lt;\n\n#  Memory estimate: 0 bytes, allocs estimate: 0.\n1.9 nanoseconds?!? That sounds too good to be true, doesn’t it? Let’s see what type of code Julia generated to make that possible.\n@code_llvm myfunc(1)\n\n;  @ REPL[6]:1 within `myfunc`\n; Function Attrs: uwtable\ndefine i64 @julia_myfunc_739(i64 signext %0) #0 {\ntop:\n;  @ REPL[6]:3 within `myfunc`\n  %1 = mul i64 %0, 50005000\n;  @ REPL[6]:6 within `myfunc`\n  ret i64 %1\n}\nWe can again ignore any line starting with a semi-colon. The one line that matters is this:\n  %1 = mul i64 %0, 50005000\nThe Julia compiler could analyse the code well enough to see that the answer to our function is simply 50005000 times the input value and that is exactly what it returned!\nWith floating-point and rational values, there were type conversions required before multiplying the integer value of the loop counter with the input value. This “hid” the true nature of the calculation enough that the compiler could not see the short-cut. There is however continuous development in the compiler, and we can reasonably expect this to also be optimised in a future version of Julia.\n\n\nArrays, Tuples and Ranges\n\nArrays\nIn most code, you will find it convenient to deal with a collection of values at the same time. There are several ways of doing this.\nThe most common collection of values is an Array. In mathematics, you will be familiar with vectors and matrices. These are simply one- and two-dimensional arrays. You can have arrays with any number of dimensions (tensors). The keywords Vector and Matrix are also available as synonyms for Array in the special cases of one and two dimensions.\n\n\n\n\n\n\nNote\n\n\n\nSimple one-dimensional arrays are treated as column vectors for use in linear algebra calculations.\n\n\nSome examples:\na = [1, 2, 3]   # use commas to specify column vectors\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nb = [1 2 3]   # use spaces to specify row vectors\n# 1×3 Matrix{Int64}:\n#  1  2  3\n\na * b \n# 3×3 Matrix{Int64}:\n#  1  2  3\n#  2  4  6\n#  3  6  9\n\nA = [1 2 3;   # directly specify a 2D array a.k.a. a matrix\n     4 5 6;\n     7 8 9]\n# 3×3 Matrix{Int64}:\n#  1  2  3\n#  4  5  6\n#  7  8  9\n\nB = zeros(3, 3, 3)   # zeros() and ones() fill the array of the specified size\n# 3×3×3 Array{Float64, 3}:\n# [:, :, 1] =\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n\n# [:, :, 2] =\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n\n# [:, :, 3] =\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0 \n\nC = zeros(Int64, 2, 2) # You can specify the type - Float64 is the default\n# 2×2 Matrix{Int64}:\n#  0  0\n#  0  0\n\nD = [1;2;;3;4;;;5;6;;7;8;;;9;10;;11;12]  # ; separates in first dimension, ;; in second dimension, ;;; in third etc.\n# 2×2×3 Array{Int64, 3}:\n# [:, :, 1] =\n#  1  3\n#  2  4\n\n# [:, :, 2] =\n#  5  7\n#  6  8\n\n# [:, :, 3] =\n#   9  11\n#  10  12\n\nE = Float64[]   # an empty 1D array of Float64\n# Float64[]\nThe individual entries of an array are accessed via [], e.g.,\nA[2, 3]\n# 6\nIn the background, [] calls getindex() and setindex() to retrieve or modify the entries of the array. If you define your own array-like type, you will need to supply the appropriate getindex() and setindex() functions.\nYou can concatenate arrays horizontally and vertically with hcat() and vcat(), or using the syntax above with spaces or semi-colons:\nA = [1, 2, 3]\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nB = [4, 5, 6]\n# 3-element Vector{Int64}:\n#  4\n#  5\n#  6\n\n[A; B]\n# 6-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n#  6\n\n[A B]\n# 3×2 Matrix{Int64}:\n#  1  4\n#  2  5\n#  3  6\n\nvcat(A, B)\n# 6-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n#  6\n\nhcat(A, B)\n# 3×2 Matrix{Int64}:\n#  1  4\n#  2  5\n#  3  6\n\n\nTuples\nTuples are functionally similar to arrays. They are specified with commas and (optional) parentheses. They are intimately linked with passing parameters to functions and returning values from functions, e.g.\nfunction myfunc(a, b)\n    return a*b, a+b\nend\n# myfunc (generic function with 1 method)\n\nmyfunc(1, 2)\n# (2, 3)\n\ntypeof(myfunc(1, 2))\n# Tuple{Int64, Int64}\nWe pass the parameters to the function as a tuple, (a, b). The results are returned as a tuple, (2, 3). Other than passing parameters to functions, what is the use of tuples? They are fairly widely used in Julia. The main differences from arrays are that while arrays are heap-allocated, tuples are stack-allocated. This is some more computer jargon, but what it means in practise is that tuples can be accessed faster than arrays but cannot be as large.\nTuples are also immutable, meaning once created, they cannot be modified. The entries of an array can always be modified. This is important to keep in mind when writing functions in Julia. The only way you can modify a parameter passed to a function is if that parameter is an array. And then only the individual entries of the array can be changed - you cannot replace the array with another one (more detail later).\nSome examples:\na = (1, 2, 3)\n# (1, 2, 3)\n\ntypeof(a)\n# Tuple{Int64, Int64, Int64}\n\nb = (1., 2., 3, 1//2)\n# (1.0, 2.0, 3, 1//2)\n\ntypeof(b)\n# Tuple{Float64, Float64, Int64, Rational{Int64}}\n\na[2]\n# 2\n\nc = (1,) # A tuple with only one value - note the trailing comma!\n# (1,)\n\ntypeof(c)\n# Tuple{Int64}\n\nd = 1,2,3  # the parentheses are optional\n# (1, 2, 3)\n\ntypeof(d)\n# Tuple{Int64, Int64, Int64}\nWe again use [] to access the individual entries.\na = (1, 2, 3)\n# (1, 2, 3)\n\na[2]\n# 2\nTuples can be unpacked into variables:\na\n# (1, 2, 3)\n\nx, y, z = a\n# (1, 2, 3)\n\nx\n# 1\n\ny\n# 2\n\nz\n# 3\nAnd since the parentheses are optional in the direct specification of tuples, we can do this:\nx = 1\n# 1\n\ny = 2\n# 2\n\ny, x = x, y\n# (1, 2)\n\nx\n# 2\n\ny\n# 1\nHere we defined a tuple (x, y) and then unpacked it into the variables y and x, swapping their values.\nSince tuples have superior performance to arrays, there exists a package that builds small arrays-like structures from tuples - StaticArrays.jl. This is commonly used for maximum performance, but only for smallish arrays, typically less than 200-300 entries. More than that and you run out of space on the stack, which has a limited size.\n\n\nNamed Tuples\nYou can also name the entries in a tuple and access them via the names instead of indexes:\nnt = (a = 1, b = 2, c = \"Bob\")\n# (a = 1, b = 2, c = \"Bob\")\n\ntypeof(nt)\n# NamedTuple{(:a, :b, :c), Tuple{Int64, Int64, String}}\n\nnt.a\n# 1\n\nnt[2]\n# 2\n\nnt.c\n# \"Bob\"\n\nnt.c === nt[3] # The values are \"egal\", i.e. not just equal, but the actual same bits in memory\n# true\nNote that the entries in a tuple or named tuple needn’t be all of the same type. This is also true for arrays, but in that case the array will be of type Any and performance will be hugely impacted. Avoid this whenever possible!\n\n\nRanges\nThe third collection type we are considering are ranges. There are several ways to specify a range:\na = 1:10   # start : stop with default step of one, hence a unit range\n# 1:10\n\ntypeof(a)\n# UnitRange{Int64}\n\nb = 1:2:20   # start : step : stop, hence a step range\n# 1:2:19\n\ntypeof(b)\n# StepRange{Int64, Int64}\n\nc = 1.0:0.5:5.0 # with floating-point steps, we get a StepRangeLen\n# 1.0:0.5:5.0\n\ntypeof(c)\n# StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}\n\nd = range(2.0, step=5.3, length=5)  # instead of colon notation, you can call the function with more options\n# 2.0:5.3:23.2\n\ntypeof(d)\n# StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}\n\n\n\n\n\n\nNote\n\n\n\nThe Base.TwicePrecision{Float64} part may be confusion. Directly from the Julia help (type ?Base.TwicePrecision at the REPL prompt:\n\nTwicePrecision is an internal type used to increase the precision of floating-point ranges, and not intended for external use. If you encounter them in real code, the most likely explanation is that you are directly accessing the fields of a range. Use the function interface instead, step(r) rather than r.step\n\n\n\nAnd just like before, we access the entries with []:\na[2]\n# 2\n\nb[3]\n# 5\n\nc[4]\n# 2.5\n\nd[5]\n# 23.2\nThe main difference is that, while arrays and tuples consist of values stored in memory, ranges are lazy. The values are only calculated when they are requested and no matter the length of the range, it takes up the same amount of memory - just enough to store the start, step and stop/length values that are needed to calculate any entry and know when you have run through the whole range.\nYou can change a range into an array, with the collect() function:\ncollect(1:10)\n# 10-element Vector{Int64}:\n#   1\n#   2\n#   3\n#   4\n#   5\n#   6\n#   7\n#   8\n#   9\n#  10\n\n\nIterables\nArrays, tuples and ranges (and strings) are all iterable types, meaning you can iterate through their entries:\na = [1, 5, 10]\n# 3-element Vector{Int64}:\n#   1\n#   5\n#  10\n\nfor i in a\n    println(i)\nend\n# 1\n# 5\n# 10\n\nfor j in 1:3\n    println(j*2)\nend\n# 2\n# 4\n# 6\n\nt = (1, 2, 3)\n# (1, 2, 3)\n\nfor k in t\n    println(k)\nend\n# 1\n# 2\n# 3\n\n\n\n\n\n\nNote\n\n\n\nYou can also use the Unicode symbol ∈ (\\in&lt;tab&gt;) in place of the word in.\n\n\nFrom a programmer’s point of view, iterable types all behave the same. We can therefore write a function that can handle any iterable type. The only requirement for this example is that the item passed should have at least two entries, or there will be an error.\nfunction mycomp(a)\n    if a[1] &gt; a[2]\n        return true\n    else\n        return false\n    end\nend\n# mycomp (generic function with 1 method)\n\nar = [1, 2]\n# 2-element Vector{Int64}:\n#  1\n#  2\n\nt = (2, 1)\n# (2, 1)\n\nr = 10:-1:1\n# 10:-1:1\n\nmycomp(ar)\n# false\n\nmycomp(t)\n# true\n\nmycomp(r)\n# true\nFor each case, the Julia compiler will generate optimised code depending on the type of the variable passed.\n\n\nIndexing\nIn the examples above, we used one-dimensional arrays and there was really no choice in how to index into the structure. The entries are all in a row in memory.\nIn the case if multi-dimensional arrays, the entries are still sequential in memory - that is how RAM works! Here, however, there are better and worse options for accessing a given entry in the array.\nThis is because of how the values are stored in memory. It is faster to sequentially access values that are stored next to each other than to jump around in memory. Julia is column major, meaning that the values in the first column of a matrix are stored next to each other in memory, followed by the values of the second column etc. For higher dimensions, the sequence is similar: each subsequent index follows the next. This is then the fastest way of iterating through the whole array.\nA = rand(10_000, 10_000);  # the _ is ignored - it is just to make reading easier. The ; at the end suppresses output of the result\n\nfunction myfunc(A)\n    mysum = 0.0\n    m, n = size(A)\n    for i = 1:m, j = 1:n  # we are running through the matrix a row at a time\n        mysum += A[i, j]\n    end\n    return mysum\nend\n# myfunc (generic function with 1 method)\n\nfunction myfunc2(A)\n    mysum = 0.0\n    m, n = size(A)\n    for j = 1:n, i = 1:m  # we are running through the matrix a column at a time\n        mysum += A[i, j]\n    end\n    return mysum\nend\n# myfunc2 (generic function with 1 method)\n\nusing BenchmarkTools\n\n@btime myfunc(A)\n#   644.754 ms (1 allocation: 16 bytes)\n# 4.99959369384022e7\n\n@btime myfunc2(A)\n#   94.296 ms (1 allocation: 16 bytes)\n# 4.999593693838226e7\nSo, in our 10,000 x 10,000 random matrix, summing up the values row-wise takes 644.754ms, while column-wise it takes only 96.449ms. Quite the improvement! If you are worried you won’t remember the correct way of iterating through a structure, Julia has you covered. Use eachindex() to get the optimal sequence:\nfunction myfunc3(A)\n    mysum = 0.0\n    m, n = size(A)\n    for i in eachindex(A)\n        mysum += A[i]\n    end\n    return mysum\nend\n# myfunc3 (generic function with 1 method)\n\n@btime myfunc3(A)\n#   96.394 ms (1 allocation: 16 bytes)\n# 5.000090241950418e7\neachindex() returns a linear index, no matter what the dimensionality of the array is and sequences it for the fastest sequential access.\nAnother useful indexing function is enumerate(). It returns an iterator of tuples, each containing an index and value pair. The indexes are linear, not cartesian.\nA = rand(2,2)\n# 2×2 Matrix{Float64}:\n#  0.488632  0.177813\n#  0.221677  0.559213\n\nfor (index, value) in enumerate(A)\n    println(\"$index $value\")\nend\n# 1 0.4886321057630626\n# 2 0.22167740760406662\n# 3 0.17781317540395236\n# 4 0.5592126504604934\nFor more information, see the manual.\n\n\n\n\n\n\nNote\n\n\n\nJulia also provides the keywords begin and end to directly index the first and last entries in an array:\na = [1, 2, 3]\n# 3-element Vector{Int64}: …\n\na[begin]\n# 1\n\na[end]\n# 3\n\na[end-1] # second last entry\n# 2\n\n\n\n\nArray Assignments\nThe array variable is a pointer2 that holds the address of the memory space where the contents is kept (on the heap). This is not an implementation detail - it is an important thing to keep in mind, as there is a difference between modifying the entries of the array (the values in the memory the array variable points to) and changing the array variable (which memory it points to):\na = collect(1:5)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = a\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb[2] = -1\n# -1\n\na\n# 5-element Vector{Int64}:\n#   1\n#  -1\n#   3\n#   4\n#   5\n\na[2] = 10\n# 10\n\nb\n# 5-element Vector{Int64}:\n#   1\n#  10\n#   3\n#   4\n#   5\nHere we created an array variable, a. Then we assigned a to b. The result is a new array variable that points to the same memory space. If we change the contents of b, we also change the contents of a, and vice versa.\nIf you want an independent copy of a, then use the copy() function:\na = collect(1:5)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = copy(a)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb[2] = -1\n# -1\n\na\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb\n# 5-element Vector{Int64}:\n#   1\n#  -1\n#   3\n#   4\n#   5\n\n\nArray Comprehensions\nThis is a quick, flexible way of creating arrays with specific values, best illustrated by example:\na = [sin(i^2) for i in 0:0.1:2π]\n# 63-element Vector{Float64}:\n#   0.0\n#   0.009999833334166666\n#   0.03998933418663417\n#   0.08987854919801107\n#   0.159318206614246\n#   0.24740395925452294\n#   ⋮\n#   0.7940962483324946\n#  -0.24980688359658182\n#  -0.9917788534431158\n#  -0.4698420526176865\n#   0.6749435215575963\n\n[1/(x+y) for x in 1:3, y in 1:3]\n# 3×3 Matrix{Float64}:\n#  0.5       0.333333  0.25\n#  0.333333  0.25      0.2\n#  0.25      0.2       0.166667\n\n[1/(x+y) for x in 1:3 for y in 1:3] # A second `for` keyword and no comma!\n# 9-element Vector{Float64}:\n#  0.5\n#  0.3333333333333333       \n#  0.25\n#  0.3333333333333333\n#  0.25\n#  0.2\n#  0.25\n#  0.2\n#  0.16666666666666666 \nTake note of the subtle difference between the second and third examples. This is not terribly intuitive!\n\n\nBroadcasting\nYou can process each entry in an iterable in a loop, or you can use the built-in broadcasting (a.k.a. dot notation). The following are equivalent:\na = collect(1:5) # create an array\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = 2:2:10 # create a range\n# 2:2:10\n\nc = similar(a) # create an uninitialised array with the same size and type as a\n# 5-element Vector{Int64}:\n#                0\n#  140734236573968\n#  140734236545296\n#                0\n#                0\n\nfor i in 1:length(a)\n    c[i] = a[i] + b[i]\nend\n\nc\n# 5-element Vector{Int64}:\n#   3\n#   6\n#   9\n#  12\n#  15\n\nd = a .+ b # element-wise addition\n# 5-element Vector{Int64}:\n#   3\n#   6\n#   9\n#  12\n#  15 \n\ne = sqrt.(d) # works for any function (note the . is between the name and the open parenthesis)\n# 5-element Vector{Float64}:\n#  1.7320508075688772\n#  2.449489742783178\n#  3.0\n#  3.4641016151377544\n#  3.872983346207417\n\n\n\nThe Type Hierarchy\nThe built-in types have a hierarchy:\n\n\n\nThe type hierarchy - Image from https://thautwarm.github.io/\n\n\nThis consists of abstract and concrete types. You can only instantiate a variable of a concrete type, but the abstract types are useful to specify groups of types that would behave similarly, e.g., Float64 and Int64 could both the added and multiplied. This is true for all the Number types, be they Real or Complex. We could specify allowed groups of types, via the &lt;: operator, or specific types, via ::, e.g.\nfunction f(x::T) where T &lt;: Number\n    #do something\nend\nHere, Julia will allow us to call f(x) with any sub-type of the Number abstract type, such as Float64, Int32 or ComplexF64. Calling f(x) with a String type will give an error, rather than try to compile a specialised version of f().\nWe can also use this to have alternative versions of a function for different types of inputs, via multiple dispatch:\nfunction addthem(a::T, b::S) where {T&lt;:Number, S&lt;:Number}\n    return a + b\nend\n\nfunction addthem(a::T, b::T) where T&lt;:AbstractString\n    return a * b\nend\n\naddthem(1, 2)\n#3\n\naddthem(2, 2.0)\n#4.0\n\naddthem(\"One\", \"Two\")\n#OneTwo\n\n\n\n\n\n\nNote\n\n\n\nNote that in the first function we use T and S, both sub-types of Number. If both variables where T&lt;:Number, then calling the function with an integer and a floating point value - the second example - would have given an error, as the two variables are not of the same type.\nWe also used AbstractString for the second function, so any type that acts like a String should work, as long as they have the * operator defined.\n\n\n\n\nStructs\nStructs are use-defined complex types that can contain multiple fields. They are defined using the struct keyword:\nstruct PersonData\n    name::String\n    address::String\n    ID::Int64\nend\n\ncustomers = PersonData[] # empty array of PersonData structs\n# PersonData[]\n\ntypeof(customers)\n# Vector{PersonData} (alias for Array{PersonData, 1})\n\nbob = PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456) # create a variable of type PersonData by calling the constructor\n# PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\npush!(customers, bob) # push an entry into the array - will increase the length by one\n# 1-element Vector{PersonData}:\n#  PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\ncustomers[1]\n# PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\nbob.name # access the values via the field names\n# \"Robert Smith\"\n\ncustomers[1].name\n# \"Robert Smith\"\nBy default, a struct is immutable, meaning it cannot be changed once created:\nbob.name = \"Joe Bloggs\"\n# ERROR: setfield!: immutable struct of type PersonData cannot be changed\n# Stacktrace:\n#  [1] setproperty!(x::PersonData, f::Symbol, v::String)\n#    @ Base .\\Base.jl:39\n#  [2] top-level scope\n#    @ REPL[31]:1\nTo make a struct mutable, simply add the keyword mutable to the definition.\nmutable struct PersonData2\n    name::String\n    address::String\n    ID::Int64\nend\n\nbob = PersonData2(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n# PersonData2(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\nbob.name\n# \"Robert Smith\"\n\nbob.name = \"Joe Bloggs\"\n# \"Joe Bloggs\"\n\nbob\n# PersonData2(\"Joe Bloggs\", \"2 Cypress Lane\", 123456)\nThe struct is immutable by default to allow additional compiler optimisations. Mutable structs will therefore have worse performance, but more flexibility.\n\nConstructors\nJulia automatically creates a constructor for each struct you define. This is a function that takes the values of the fields, creates a new structure in memory and assigns the specified values to the fields.\nYou can also create additional constructors. There are two types:\n\nOuter constructors and\nInner constructors\n\nThe default constructor is an outer constructor. You can also specify additional outer constructors that e.g., have default values for some fields, or calculate some values from others:\nstruct PersonData\n    name::String\n    address::String\n    ID::Int64\nend\n\nbob = PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n# PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\nfunction PersonData(name, ID)\n    # Call the default constructor to do the allocations and assignments\n    PersonData(name, \"No known address\", ID) \nend\n# PersonData\n\nsally = PersonData(\"Sally Jones\", 123)\n# PersonData(\"Sally Jones\", \"No known address\", 123)\n\nsally.address\n# \"No known address\"\n\ntom = PersonData(\"Tom Jones\", \"Las Vegas\", 34556) # The default is still available\n# PersonData(\"Tom Jones\", \"Las Vegas\", 34556\nInner constructors are defined as part of the struct definition and are used to validate the entries for the struct before creating the instance.\nstruct OnlyNegatives\n    val::Float64\n    OnlyNegatives(val) = val &gt; 0 ? error(\"Non-negative value!\") : new(val)\nend\n\nOnlyNegatives(-1)\n# OnlyNegatives(-1.0)\n\nOnlyNegatives(1)\n# ERROR: Non-negative value!\n# Stacktrace:\n#  [1] error(s::String)\n#    @ Base .\\error.jl:35\n#  [2] OnlyNegatives(val::Int64)\n#    @ Main .\\REPL[7]:3\n#  [3] top-level scope\n#    @ REPL[9]:1\nInner constructors have access to a special local function, new(), which acts like the default outer constructor would.\n\n\n\n\n\n\nImportant\n\n\n\nIf you define an inner constructor, NO default constructors are created. You need to handle all cases via your inner constructors."
  },
  {
    "objectID": "04_An_Overview_of_the_Language.html#loops",
    "href": "04_An_Overview_of_the_Language.html#loops",
    "title": "An Overview of the Language",
    "section": "Loops",
    "text": "Loops\nJulia provides two types of loops:\n\nfor loops for iterating over an iterable construct, like a range or array with a known length\nwhile loops for iterating until a logical criterium is met, with an initially unknown number of iterations\n\na = zeros(5)\n# 5-element Vector{Float64}:\n#  0.0\n#  0.0\n#  0.0\n#  0.0\n#  0.0\n\nfor i in 1:length(a)\n    a[i] = 2*i^2\nend\n\na\n# 5-element Vector{Float64}:\n#   2.0\n#   8.0\n#  18.0\n#  32.0\n#  50.0\n\nwhile a[i] &lt;= 10\n    println(i, \"\\t\", a[i])\n    i += 1\nend\n# 1       2.0\n# 2       8.0\nIn a while loop, it is critical to manually implement a step (i += 1 in the example), or the loop will execute indefinitely!"
  },
  {
    "objectID": "04_An_Overview_of_the_Language.html#logic-and-flow-control",
    "href": "04_An_Overview_of_the_Language.html#logic-and-flow-control",
    "title": "An Overview of the Language",
    "section": "Logic and Flow Control",
    "text": "Logic and Flow Control\nAt some point in your code, you will want to execute different instructions depending on some criteria. The most basic form of flow control is the if statement:\nif a &lt; 0\n    println(\"Negative\")\nelseif a == 0\n    println(\"Zero\")\nelse\n    println(\"Positive\")\nend\nThe elseif and else blocks are optional. You can have multiple elseif blocks with different criteria. You can also nest if statements. The end statement is a requirement. Unlike many other languages, there is no then keyword (if…then…else…end).\nJulia also offers a short-cut alternative for for simple if statements. The following two statements will both print the value Negative if a &lt; 0.\na &lt; 0 && println(\"Negative\")\na &gt;= 0 || println(\"Negative\")\nThis looks a little arcane. It works as follows:\nThe && operator is a logical and. For an and statement to be true, both criteria must be true, so if the first statement (before the &&) is false, Julia won’t bother to evaluate the second statement (after the &&), since the whole cannot be true. This is called short-circuiting evaluation. This means the println() is only executed if a is indeed less than zero.\nThe || operator is a logical or. For an or statement to be true, either of the two criteria must be true, so if the first statement is true, there is no need need to also evaluate the second - the whole is already true. The println() will therefore not be executed if a is larger than or equal to zero.\n\n\n\n\n\n\nTip\n\n\n\nTo help you remember how short-circuiting evaluations work, try this:\na &lt; 0 && println(\"Negative\") reads as a &lt; 0 AND then println()\na &gt;= 0 || println(\"Negative\") reads as a &gt;= 0 OR else println()\n\n\nYou may very well choose to stick to more readily understandable if statements in your code, but these short-circuit notations are commonly used and you will encounter them often in other people’s code\nFinally, when you are only assigning values to a variable based on some criterium, there is the so-called ternary operator:\na\n# -1\n\nb = a &gt; 0 ? \"Positive\" : \"Not positive\"\n# \"Not positive\"\nThese can be nested as well:\nb = a &gt; 0 ? \"Positive\" : (a == 0 ? \"Zero\" : \"Negative\")\n# \"Negative\"\nThe parentheses around the final statement are optional, but significantly improves readability."
  },
  {
    "objectID": "04_An_Overview_of_the_Language.html#functions",
    "href": "04_An_Overview_of_the_Language.html#functions",
    "title": "An Overview of the Language",
    "section": "Functions",
    "text": "Functions\nFunctions are the core of any Julia program. Inputs are passed as parameters and any number and type of values can be returned as a tuple. You can also modify the values of array parameters passed to the function. In this case, the function is called mutating and it is accepted practise in Julia to end the function name with an exclamation mark (or a bang, if you are American), to indicate that the function mutates one or more parameters. Typically, it would be the first parameter that is mutated.\n\n\n\n\n\n\nNote\n\n\n\nMost people use the terms parameter and argument interchangeably as they refer to functions. If you want to be strictly formal, then a function is defined to accept parameters and you pass specific argument values when you call the function. Here, we won’t be formal - feel free to use either term.\n\n\nThere are four ways to declare a function:\n\nFull declaration\n\nfunction myfunc(a, b)\n    return a + b\nend\nThe keyword return is optional, but it significantly improves readability. In the absence of a return statement, Julia will return the last calculated result. You can also have multiple return statements in, e.g., an if block. When a return is executed (evaluated in Julia parlance), the function will return the specified value and exit.\n\nShort-cut for single-line functions\n\nmyfunc(a, b) = a + b\n\nAnonymous functions, typically used when passing a single-use function to a higher-level function (a function that takes another function as input)\n\nmysum = sum(x -&gt; x^2 + √x, somearray)\nHere Julia will apply the function x -&gt; x^2 + √x to each entry in the array somearray and then add up the results.\nYou technically can pass only one parameter to an anonymous function, but since that parameter can be a tuple (and tuples can contain scalars. arrays or even other tuples), there is practically no limit to the number of parameters passed, e.g.\nf = (x, y) -&gt; 2x/y^2\nHere we also assign the result of the function definition to a variable, f, which means we can later call f(x, y). There is really no reason to do this. Rather use the short-cut function definition above.\n\nDo blocks (similar to anonymous functions, but for multi-line functions)\n\nopen(\"myfile.txt\", \"w\") do io\n    write(io, \"Hello world!\")\nend\nHere, there are a few things to pay attention to:\n\nWe are calling the higher-level function open(), which takes another function as its first parameter. The do block ALWAYS passes the specified (anonymous) function to the first parameter of the calling function. The nominal syntax for open() is open(f::Function, args...; kwargs...). The function, f is specified by the do block.\nWe pass the parameter io to the function be specifying io next to the keyword do. This is similar to the x -&gt; ... in an anonymous function, here we effectively have io -&gt; ...\n\n\nPassing Values to Functions and Returning Results\nIn all of the examples so far, we have passed values to the functions. These values are called parameters or arguments3 and there are two types of parameters in Julia: positional parameters and keyword arguments.\n\nPositional parameters\nPositional parameters are parameters where Julia knows which local (to the function) variable to assign the value to, based on the parameter’s position in the list of arguments. If we have a function f(x, y), and we call it with f(1, 2), Julia will assign the value of 1 to x and 2 to y.\nPositional parameters can have default values: f(x, y=2). We can now either call the function with f(2, 4), in which case x will be assigned a value of 2 and y a value of 4, or we can omit the value for y and call f(2), in which was x will be assigned a value of 2 and y will use its default value, also 2.\nMultiple parameters can have default values, e.g. f(x, y=2, z = 3). If we now call f(2), y and z use their default values. What happens when we call f(2, 10)?\nfunction f(x, y=2, z=4)\n    println(x)\n    println(y)\n    println(z)\nend\n\nf(2)\n# 2\n# 2\n# 4\n\nf(2, 10)\n# 2\n# 10\n# 4\nWe see that the second value is passed to y, since it is the second positional parameter. Positional values are always assigned left to right, then default values are used for what is left. So how would we pass values for x and z and have y use its default value? The answer is keyword arguments.\n\n\nKeyword arguments\nKeyword arguments (a.k.a. keyword parameters, a.k.a. kwargs4) are identified by name when passing values to a function. To define them, we first list the positional parameters, then a semi-colon, then the keyword arguments. Keyword arguments must all have default values assigned to them.\nfunction f(x; y=2, z=4)\n    println(x)\n    println(y)\n    println(z)\nend\n\nf(2)\n# 2\n# 2\n# 4\nSo, as expected, y and z are using their default values. We can now decide to override the defaults for y, z or both:\nf(2, z=3)\n# 2       \n# 2\n# 3\n\nf(2, y=5, z=10)\n# 2\n# 5\n# 10\nSince x is a positional parameters, a value must always be passed for it, or we get an error:\nf(y=5, z=10)\n# ERROR: MethodError: no method matching f(; y::Int64, z::Int64)\n\n# Closest candidates are:\n#   f(::Any; y, z)\n#    @ Main d:\\JuliaCode\\Julia4ER\\Julia for Engineering Research\\scrathpad.jl:42\n\n\n\n\n\n\nNote\n\n\n\nIt is common to find that positional and keyword arguments are separated with a semi-colon at the point where the function is called, e.g. f(2; y=3, z=5). This is just done to emphasise that the parameters after the semi-colon are kwargs, but it is not required. A comma will do just fine.\n\n\n\n\nReturning Results\nAs mentioned above, to return values from a function, there are two preferred options:\n\nUse the keyword return\nMutate (modify) an array passed as parameter to the function\n\nFunctions in Julia will always return a value. Either there is an explicit return statement, or the last calculated value is automatically returned. It is good practise to always explicitly return a value. If your function returns nothing, then use return nothing to prevent an unexpected and unintended value from being returned.\nYou can have multiple return statements, but the first one to execute will terminate the function and return to the line after the call to the function.\nfunction isnotnegative(x)\n    if x &gt;= 0\n        return true\n    else\n        return false\n    end\nend\nor more concisely\nfunction isnotnegative(x)\n    return x &gt;= 0\nend\nThis is more understandable than the equivalent:\nfunction isnotnegative()\n    x &gt;= 0\nend\nJulia uses pass-by-sharing for parameters passed to functions. If you don’t know what that means, you are in good company.\nThe practical implications however are fairly simply to understand. Parameters are immutable - you cannot modify them:\nfunction trychangeing(x)\n    println(\"Passed value: $x\")\n    x = 10\n    println(\"Local value: $x\")\nend\n\nx = -1\ntrychangeing(x)\n# Passed value: -1\n# Local value: 10\n\nprintln(\"Value at call site: $x\")\n# Value at call site: -1\n\na = [1]\ntrychangeing(a)\n# Passed value: [1]\n# Local value: 10\n\nprintln(\"Value at call site: $a\")\n# Value at call site: [1]\nWhat happens is that Julia creates a new, local variable in the scope of the function, and assigns it the value of the argument that was passed. You can change the values of the parameters, but that does not affect the variables that were passed to the function - x and a in the examples above.\nHow do you then mutate an argument? You cannot change scalar values at all. Neither can you change an array. But the value of an array is just a pointer to some data that it contains, and you can change that data:\nfunction canchange!(x)\n    println(\"Passed value: $x\")\n    x[1] = -10\n    println(\"Local value: $x\")\nend\n\na = [1, 2, 3]\ncanchange!(a)\n# Passed value: [1, 2, 3]\n# Local value: [-10, 2, 3]\n\nprintln(a)\n[-10, 2, 3]\n\n\n\n\n\n\nNote\n\n\n\nNote the addition of the exclamation mark (or “bang”, for our American friends) to the name of the function. This is not a Julia requirement, just good manners. We inform the user of the code that one or parameter will be mutated. By convention, this will be the first parameter.\n\n\nA function returns only one value. What then if you need to return more than one result? Simply return them as a tuple and unpack them at the call site:\nfunction sqr_two(a, b)\n    return a^2, b^2 # The parentheses around the tuple are optional\nend\n\na2, b2 = sqr_two(2, 3) # Unpack the returned tuple into the two variables, a2 and b2\nprintln(\"a2 = $a2 and b2 = $b2.\"\n# a2 = 4 and b2 = 9.\n\n\nSlurping and Splatting - Variable number of positional arguments\nJulia uses the ... operator to slurp and splat values. Slurping means combining multiple scalar values into an array or tuple (slurping them up) and splatting means breaking an array or tuple into a number of scalar values. While this is sometimes used in other places, the most common application is to allow a variable number of parameters to be passed to a function.\nfunction confused(a, b, c...)\n    println(\"a is $a\")\n    println(\"b is $b\")\n    println(\"c is $c\")\nend\n\nconfused(1, 2, 3, 4, 5)\n# a is 1  \n# b is 2\n# c is (3, 4, 5)\nSplatting allows an array to be passed to a function that expects a number of scalars:\nfunction confused2(a, b, c)\n    println(\"a is $a\")\n    println(\"b is $b\")\n    println(\"c is $c\")\nend\n\nx = [1, 2, 3]\nconfused2(x...)\n# a is 1  \n# b is 2\n# c is 3\n\nx = [1, 2, 3, 4]\nconfused2(x...)\n# ERROR: MethodError: no method matching confused2(::Int64, ::Int64, ::Int64, ::Int64)\n\n# Closest candidates are:\n#   confused2(::Any, ::Any, ::Any)\n# ...\nThe last example results in an error, as there is no version of the function that accepts four parameters."
  },
  {
    "objectID": "04_An_Overview_of_the_Language.html#type-stability-and-fast-code",
    "href": "04_An_Overview_of_the_Language.html#type-stability-and-fast-code",
    "title": "An Overview of the Language",
    "section": "Type Stability and Fast Code",
    "text": "Type Stability and Fast Code\nBeing able to change the type of a variable can be useful, but it does also open the door to something that can cause slowdown in your code: type instability. This is when the type of x changes during the execution of your code, making many of the optimisations Julia could do, impossible. Instead, additional code is required to handle the type changes. Keep a look-out for something like this:\nfunction myfunc(n)\n    sum = 0\n    for i in 1:n\n        sum += 1.5\n    end\n    return sum\nend\nAt first glance, there is nothing strange about this code. If you take a closer look however, you will see that sum is created as an integer via sum = 0, but then we assign floating-point values to it.\nJulia has a lot of code analyses tools. One of which is @code_warntype:\n@code_warntype myfunc(5)\n\nMethodInstance for myfunc(::Int64)\n  from myfunc(n) in Main at REPL[20]:1\nArguments\n  #self#::Core.Const(myfunc)\n  n::Int64\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  sum::Union{Float64, Int64}\n  i::Int64\nBody::Union{Float64, Int64}\n1 ─       (sum = 0)\n│   %2  = (1:n)::Core.PartialStruct(UnitRange{Int64}, Any[Core.Const(1), Int64])\n│         (@_3 = Base.iterate(%2))\n│   %4  = (@_3 === nothing)::Bool\n│   %5  = Base.not_int(%4)::Bool\n└──       goto #4 if not %5\n2 ┄ %7  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Int64\n│         (sum = sum + 1.5)\n│         (@_3 = Base.iterate(%2, %9))\n│   %12 = (@_3 === nothing)::Bool\n│   %13 = Base.not_int(%12)::Bool\n└──       goto #4 if not %13\n3 ─       goto #2\n4 ┄       return sum\nLike when we looked at the LLVM code generated for a function, this may seem intimidating, but the important bits are these:\nsum::Union{Float64, Int64}\nand\nBody::Union{Float64, Int64}\n\n\n\n\n\n\nNote\n\n\n\nIn the REPL these are helpfully printed in red to draw your attention.\n\n\nJulia indicates that the variable sum is not type stable. It is assigned both Int64 and Float64values. This limits the amount of optimisation that is allowed and ends up in slower code.\nTo learn more about type stability and many other useful tips to help you write faster code, refer to the Performance Tips section in the manual.\nThe main things to consider, if you want fast code are:\n\nThe fastest code is code that you don’t need to execute. Better algorithms always trump more optimised code\nAvoid type instability in your code.\nAvoid unnecessary memory allocation by re-using arrays where possible.\n\nOnce you have these issues under control, learning to properly benchmark your code (using BenchmarkTools.jl) will allow you to fine tune the performance of your code. Writing fast code is mostly about not writing slow code."
  },
  {
    "objectID": "04_An_Overview_of_the_Language.html#footnotes",
    "href": "04_An_Overview_of_the_Language.html#footnotes",
    "title": "An Overview of the Language",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAn Nvidia Tesla A100 costs about US$7400 in mid-2023↩︎\nA pointer is just a memory address - computer guys like their jargon.↩︎\nSee the previous comment on this - the terms are often used interchangeably↩︎\nIn the spirit of computer science (and technical fields in general) the least understandable option - kwargs - is also the most used one. Go figure.↩︎"
  },
  {
    "objectID": "05_Plotting.html",
    "href": "05_Plotting.html",
    "title": "Plotting",
    "section": "",
    "text": "There are several plotting packages available in Julia. We shall focus only on one here - probably the most widely used plotting package in Julia - Plots.jl:\nOther popular plotting packages include Makie (with the AlgebraOfGraphs add-on for statistical analysis plotting) and Gadfly - similar to R’s ggplot, which are left for discovery by the reader.\nPlots.jl is a generic front-end for several plotting back-ends. These can also be used directly, but Plots allows a single front-end and you can switch the back-end with a single line of code without having to modify the actual calls to plotting functions. Plots.jl also has a powerful recipe system, which is widely supported. Package authors can define recipes for plots of the data types defined in their packages, which will then automatically generate sensible plots with the normal plot() function.\n\n\nThe following back-ends are supported:\n\nGR (default). Supports all features. Best choice for speed. Not currently interactive, but this feature is in development.\nPlotly / PlotlyJS. Best choice for interactivity. The plot is generated in a browser. Plotly requires an internet connection, while PlotlyJS runs locally.\nPythonPlot. Julia front-end for PyPlot, the Python front-end for Matplotlib. When installing, this will also install a private Python installation (it will use the same installation as Jupyter).\nUnicodePlots. Plots generated with Unicode (text) characters right in the REPL.\nGaston. A Julia front-end for the GnuPlot back-end.\nInspectDR\nPGFPlotsX. Plotting engine based on TikZ - popular for \\(LaTeX\\) documents\n\n\n\n\nThe Plots.jl package installed as a normal package via the package manager. This will also automatically install the GR.jl package as a dependency. In order to use the other back-ends, they must first be installed individually and then they must be activated, e.g.:\nusing Plots # Will use default back-end: GR\n\nplotlyjs() # Switch to PlotlyJS - previously installed\n# Plots.PlotlyJSBackend()\n\ngr() # Switch back to GR back-end\n# Plots.GRBackend()\n\n\n\nFor detailed documentation on all the features of Plots.jl, see the manual.\nA simple plot is generated with the plot() function. An existing plot can be added to with the plot!() function. If no plot variable is specified, this will add to the last generated plot. There are also mutating functions to add/modify the axis labels, plot title etc:\n\ntitle!()\nxlabel!()\nylabel!()\netc.\n\nYou can combine multiple plots in one. By default, the layout is a simple grid, but there is the option to specify complex layouts.\nYou can save the plot to file. Both *.png and *.svg formats are available and selected simply by specifying the extension in the filename.\nTwo examples:\nusing Plots\n\ndata1 = rand(5)\nx = randn(10)\ny = randn(10)\n\nplot(\n    plot(\n        data1,\n        label = \"some data\",\n        title=\"Line plot\",\n        xlabel=\"sample\",\n        ylabel=\"value\",\n        linecolor = :red,\n        linewidth = 3\n    ),\n    scatter(\n        x, y, \n        title = \"Scatter plot\",\n        label = \"samples\",\n        xlabel=\"x\",\n        ylabel=\"y\",\n        markercolor = :blue,\n        markershape = :diamond\n        )\n)\n\nsavefig(\"plotsexample.svg\")\n\n\n\nA plot generated with Plots.jl\n\n\ndata2 = rand(7)\ndata3 = rand(6)\nplot(data2, label=\"Experiment 2\", linestyle=:dashdotdot)\nplot!(data3, label= \"Experiment 3\", linewidth = 2)\ntitle!(\"Two series in a plot\")\nxlabel!(\"Sample number\")\nylabel!(\"Sample size\")\n\nsavefig(\"plotsexample2.svg\")\n\n\n\nAnother plot generated with Plots.jl\n\n\n\n\n\nYou can also generate contour and surface plots:\nf(x, y) = x*sin(x) - y^2 * cos(y)\nx = range(0, 5, length=100)\ny = range(0, 3, length=50)\nz = @. f(x', y)\ncontour(z)\nsavefig(\"img/plotscontour.svg\")\nsurface(x, y, z)\nsavefig(\"img/plotssurface.svg\")\n\n\n\nPlots.jl contour plot\n\n\n\n\n\nPlots.jl surface plot\n\n\nThe Plots.jl package has a LOT more features than is shown here. This includes histograms, heatmaps and many more. See the Plots.jl manual for details.\n\n\n\n\n\n\nNote\n\n\n\nThose paying attention may have seen the @. in the previous example. This means every operator and function call in the line is broadcast automatically. I prefer explicitly broadcasting for clarity, but this is commonly used.\n\n\n\n\n\nThe StatsPlots.jl package is an extension of Plots.jl that adds typical statistics plots, like box plots, violin plots, kernel density plots etc. Refer to its manual for more information."
  },
  {
    "objectID": "05_Plotting.html#available-plotting-packages",
    "href": "05_Plotting.html#available-plotting-packages",
    "title": "Plotting",
    "section": "",
    "text": "There are several plotting packages available in Julia. We shall focus only on one here - probably the most widely used plotting package in Julia - Plots.jl:\nOther popular plotting packages include Makie (with the AlgebraOfGraphs add-on for statistical analysis plotting) and Gadfly - similar to R’s ggplot, which are left for discovery by the reader.\nPlots.jl is a generic front-end for several plotting back-ends. These can also be used directly, but Plots allows a single front-end and you can switch the back-end with a single line of code without having to modify the actual calls to plotting functions. Plots.jl also has a powerful recipe system, which is widely supported. Package authors can define recipes for plots of the data types defined in their packages, which will then automatically generate sensible plots with the normal plot() function.\n\n\nThe following back-ends are supported:\n\nGR (default). Supports all features. Best choice for speed. Not currently interactive, but this feature is in development.\nPlotly / PlotlyJS. Best choice for interactivity. The plot is generated in a browser. Plotly requires an internet connection, while PlotlyJS runs locally.\nPythonPlot. Julia front-end for PyPlot, the Python front-end for Matplotlib. When installing, this will also install a private Python installation (it will use the same installation as Jupyter).\nUnicodePlots. Plots generated with Unicode (text) characters right in the REPL.\nGaston. A Julia front-end for the GnuPlot back-end.\nInspectDR\nPGFPlotsX. Plotting engine based on TikZ - popular for \\(LaTeX\\) documents\n\n\n\n\nThe Plots.jl package installed as a normal package via the package manager. This will also automatically install the GR.jl package as a dependency. In order to use the other back-ends, they must first be installed individually and then they must be activated, e.g.:\nusing Plots # Will use default back-end: GR\n\nplotlyjs() # Switch to PlotlyJS - previously installed\n# Plots.PlotlyJSBackend()\n\ngr() # Switch back to GR back-end\n# Plots.GRBackend()\n\n\n\nFor detailed documentation on all the features of Plots.jl, see the manual.\nA simple plot is generated with the plot() function. An existing plot can be added to with the plot!() function. If no plot variable is specified, this will add to the last generated plot. There are also mutating functions to add/modify the axis labels, plot title etc:\n\ntitle!()\nxlabel!()\nylabel!()\netc.\n\nYou can combine multiple plots in one. By default, the layout is a simple grid, but there is the option to specify complex layouts.\nYou can save the plot to file. Both *.png and *.svg formats are available and selected simply by specifying the extension in the filename.\nTwo examples:\nusing Plots\n\ndata1 = rand(5)\nx = randn(10)\ny = randn(10)\n\nplot(\n    plot(\n        data1,\n        label = \"some data\",\n        title=\"Line plot\",\n        xlabel=\"sample\",\n        ylabel=\"value\",\n        linecolor = :red,\n        linewidth = 3\n    ),\n    scatter(\n        x, y, \n        title = \"Scatter plot\",\n        label = \"samples\",\n        xlabel=\"x\",\n        ylabel=\"y\",\n        markercolor = :blue,\n        markershape = :diamond\n        )\n)\n\nsavefig(\"plotsexample.svg\")\n\n\n\nA plot generated with Plots.jl\n\n\ndata2 = rand(7)\ndata3 = rand(6)\nplot(data2, label=\"Experiment 2\", linestyle=:dashdotdot)\nplot!(data3, label= \"Experiment 3\", linewidth = 2)\ntitle!(\"Two series in a plot\")\nxlabel!(\"Sample number\")\nylabel!(\"Sample size\")\n\nsavefig(\"plotsexample2.svg\")\n\n\n\nAnother plot generated with Plots.jl\n\n\n\n\n\nYou can also generate contour and surface plots:\nf(x, y) = x*sin(x) - y^2 * cos(y)\nx = range(0, 5, length=100)\ny = range(0, 3, length=50)\nz = @. f(x', y)\ncontour(z)\nsavefig(\"img/plotscontour.svg\")\nsurface(x, y, z)\nsavefig(\"img/plotssurface.svg\")\n\n\n\nPlots.jl contour plot\n\n\n\n\n\nPlots.jl surface plot\n\n\nThe Plots.jl package has a LOT more features than is shown here. This includes histograms, heatmaps and many more. See the Plots.jl manual for details.\n\n\n\n\n\n\nNote\n\n\n\nThose paying attention may have seen the @. in the previous example. This means every operator and function call in the line is broadcast automatically. I prefer explicitly broadcasting for clarity, but this is commonly used.\n\n\n\n\n\nThe StatsPlots.jl package is an extension of Plots.jl that adds typical statistics plots, like box plots, violin plots, kernel density plots etc. Refer to its manual for more information."
  },
  {
    "objectID": "06_Solving_Linear_Systems.html",
    "href": "06_Solving_Linear_Systems.html",
    "title": "Solving Linear Systems",
    "section": "",
    "text": "For solving systems with smaller, dense matrices, you could use Julia’s LinearAlgebra standard library. You can also use the SparseArrays standard library for larger sparse systems. In addition, there are several iterative methods available, such as IterativeSolver.jl for solving very large, sparse systems. Rather than learn how several packages work, however, you can use the SciML LinearSolve.jl package that provides a uniform front-end for all the main linear system packages. You can change the solver algorithm by changing a single line of code, which is very convenient when trying to find the most optimal approach for your system."
  },
  {
    "objectID": "06_Solving_Linear_Systems.html#built-in-methods",
    "href": "06_Solving_Linear_Systems.html#built-in-methods",
    "title": "Solving Linear Systems",
    "section": "Built-in Methods",
    "text": "Built-in Methods\nWe shall start by looking at the methods provided by Julia directly. While it may be more convenient to use LinearSolve.jl for larger problems, using the Julia base methods is still very useful for quick calculations.\n\nLeft Division\nFor dividing scalar values, we use the / (right division) operator. There is however also a left division operator, \\. You can solve a linear system directly as follows:\n\\[Ax = b\\] \\[x = A \\backslash b \\]\nA = [1 0 3;\n    -1 1 0;\n     2 1 1]\n# 3×3 Matrix{Int64}:\n#   1  0  3\n#  -1  1  0\n#   2  1  1\n\nx = [1, 2, 1]\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  1\n\nb = A*x\n# 3-element Vector{Int64}:\n#  4\n#  1\n#  5\n\nx̂=A\\b # Note that the results are not integers\n# 3-element Vector{Float64}:\n#  1.0\n#  2.0\n#  1.0\n\nx ≈ x̂ # Use approximate check with floats\n# true\n\n\n\n\n\n\nTip\n\n\n\nIt may help to read A\\b as “A divides into b”\n\n\nThis is a fairly straightforward way of solving a linear system. For dense systems, it is also quite efficient, if your matrix is well-behaved.\nInternally, there is quite a bit going on. Julia analyses the matrix, A. It then selects an appropriate factorisation methods and uses that to solve the linear system.\nUpper and lower triangular and diagonal systems are solved directly via forward or backward substitution. For non-triangular, square matrices, LU factorisation is used.\nFor rectangular matrices, a minimum norm, least squares solution is calculated using pivoted QR factorisation.\nSimilar approaches are used for sparse matrices, including use of LDLT factorisation for indefinite matrices etc. See the manual section on factorisation for more detail.\nIf you are going to perform more than one calculation with the same matrix, it will be more efficient to store the factorisation result:\nusing LinearAlgebra # to import factorize()\n\nA = [1 0 3;\n    -1 1 0;\n     2 1 1]\n# 3×3 Matrix{Int64}:\n#   1  0  3\n#  -1  1  0\n#   2  1  1\n\nA = factorize(A) # replace A with its factorised form\n# LU{Float64, Matrix{Float64}, Vector{Int64}}\n# L factor:\n# 3×3 Matrix{Float64}:\n#   1.0   0.0       0.0\n#  -0.5   1.0       0.0\n#   0.5  -0.333333  1.0\n# U factor:\n# 3×3 Matrix{Float64}:\n#  2.0  1.0  1.0\n#  0.0  1.5  0.5\n#  0.0  0.0  2.66667\n\nA.U # To access the U part\n# 3×3 Matrix{Float64}:\n#  2.0  1.0  1.0\n#  0.0  1.5  0.5\n#  0.0  0.0  2.66667\n\nA.L # To access the L part\n# 3×3 Matrix{Float64}:\n#   1.0   0.0       0.0\n#  -0.5   1.0       0.0\n#   0.5  -0.333333  1.0\n\nb = [4, 1, 5] # Our first b vector\n# 3-element Vector{Int64}:\n#  4\n#  1\n#  5\n\nA\\b # Solve using specialised methods for LU factorised matrices\n# 3-element Vector{Float64}:\n#  1.0\n#  2.0\n#  1.0\n\nb = [1, 2, 7] # A new b vector\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  7\n\nA\\b # Solve without needing to repeat the factorisation\n# 3-element Vector{Float64}:\n#   1.75\n#   3.75\n#  -0.25000000000000006\n\n\n\n\n\n\nImportant\n\n\n\nYou could of course solve a linear system by multiplying with the inverse of the matrix, and this is fairly straightforward to do, with inv(A). This is however, almost never a good choice, especially with large, sparse matrices, where the inverse is generally dense and may not fit into your computer’s memory.\nFactorisation is always a better choice, and iterative methods often the best choice for large, sparse matrices.\n\n\n\n\nSpecialised Matrix Types\nJulia offers several specialised types for matrices with optimised algorithms. These include:\n\nSymmetric\nHermitian\nUpperTriangular\nLowerTriangular\nTridiagonal\nBidiagonal\nDiagonal\netc.\n\nSee the manual for the full list.\n\n\nSparse Matrices\nModels of physical systems very often result in large, sparse matrices. Instead of using a vast amount of memory to store mostly zeros, Julia has a built-in sparse array type. This allows you to save only the non-zero entries and also uses specialised linear algebra methods for sparse matrices. To access this, import the standard library SparseArrays.\nSparse matrices in Julia are stored in the Compressed Sparse Column format.\nSome useful functions for working with sparse matrices include:\n\nnnz() returns the number of entries in the array. This could include values that have been set to zero.\n\ncount(!iszero, x) will check each entry and count only non-zero values\n\ndropzeros() will drop entries that have been set to zero from the list of stored entries. It returns a new sparse array\n\ndropzeros!() is similar to dropzeros(), but modifies the array directly.\n\nspzeros(m,n) is similar to zeros() for dense arrays. It creates a mxn sparse array with all elements set to zero.\nsparse(I, J, V) creates a sparse array from thee vectors. I is a vector of the row indices, J of column indices and V holds the values of the entries.\n\nsparsevec(I, V) is the vector equivalent of sparse()\nfindnz() is the inverse of sparse() and sparsevec()\n\nissparse() checks is an array is sparse\nblockdiag() concatenates matrices into a sparse block diagonal matrix.\n\nSee the manual for more"
  },
  {
    "objectID": "06_Solving_Linear_Systems.html#linearsolve",
    "href": "06_Solving_Linear_Systems.html#linearsolve",
    "title": "Solving Linear Systems",
    "section": "LinearSolve",
    "text": "LinearSolve\nThe LinearSolve.jl package will use the built-in linear algebra methods when appropriate, but also has many other, specialised methods available from several packages. These include iterative methods that are more efficient for large, sparse matrices. It can also make use of your machines’s GPU is one is available1.\nTo install LinearSolve.jl, simply use the package manager.\nTo illustrate how to use the package, we shall use the same toy examples from before:\nusing LinearSolve\n\nA = Float64[1 0 3; # explicitly define as Float64\n    -1 1 0;\n     2 1 1]\n# 3×3 Matrix{Float64}:\n#   1.0  0.0  3.0\n#  -1.0  1.0  0.0\n#   2.0  1.0  1.0\n\nb = Float64[4, 1, 5] # explicitly define as Float64\n# 3-element Vector{Float64}:\n#  4.0\n#  1.0\n#  5.0\n\nprob = LinearProblem(A, b) # Define problem\n# LinearProblem. In-place: true\n# b: 3-element Vector{Float64}:\n#  4.0\n#  1.0\n#  5.0\n\nsol = solve(prob) # and solve\n# u: 3-element Vector{Float64}:\n#  1.0\n#  2.0\n#  1.0\nSince LinearSolve has to allow for automatic differentiation2, which may require passing dual variables to the function, it will implicitly use the type of the variables as specified in A in b. This will result in an error the inputs are arrays of integers and the if the solution contains fractions. To avoid this, we explicitly define the inputs as Float64.\nYou can also specify which algorithm to use. See the full list and recommendations in the documentation.\nsol = solve(prob, KrylovJL_GMRES()) #GMRES is an iterative solver, from the Krylov.jl package\n# u: 3-element Vector{Float64}:\n#  1.0000000000000004\n#  2.0000000000000004\n#  0.9999999999999998\nIn our example for using built-in methods, we stored the result of the factorisation to re-use this when solving the problem with another b vector. We can do the same with LinearSolve by adding one step:\nusing LinearSolve\n\nA = Float64[1 0 3;\n    -1 1 0;\n     2 1 1]\n# 3×3 Matrix{Float64}:\n#   1.0  0.0  3.0\n#  -1.0  1.0  0.0\n#   2.0  1.0  1.0\n\nb1 = Float64[4, 1, 5]\n# 3-element Vector{Float64}:\n#  4.0\n#  1.0\n#  5.0\n\nprob = LinearProblem(A, b1)\n# LinearProblem. In-place: true\n# b: 3-element Vector{Float64}:\n#  4.0\n#  1.0\n#  5.0\n\nlinsolve = init(prob) # initialize a cache to store the linear system intermediates\n# LinearSolve.LinearCache{Matrix{Float64}, Vector{Float64}, Vector{Float64}, SciMLBase.NullParameters, Nothing, LU{Float64, Matrix{Float64}, Vector{Int64}}, SciMLOperators.IdentityOperator, SciMLOperators.IdentityOperator, Float64, true}([1.0 0.0 3.0; -1.0 1.0 0.0; 2.0 1.0 1.0], [4.0, 1.0, 5.0], [0.0, 0.0, 0.0], SciMLBase.NullParameters(), nothing, LU{Float64, Matrix{Float64}, Vector{Int64}}(Matrix{Float64}(undef, 0, 0), Int64[], 0), true, SciMLOperators.IdentityOperator(3), SciMLOperators.IdentityOperator(3), 1.4901161193847656e-8, 1.4901161193847656e-8, 3, false, LinearSolve.OperatorAssumptions{true}())\n\nsol1 = solve(linsolve) # solve the problem, using the cache\n# u: 3-element Vector{Float64}:\n#  1.0\n#  2.0\n#  1.0\n\nb2 = Float64[1, 2, 7] # another b vector\n# 3-element Vector{Float64}:\n#  1.0\n#  2.0\n#  7.0\n\nlinsolve = LinearSolve.set_b(sol1.cache, b2) # update the cache with the new b vector\n# LinearSolve.LinearCache{Matrix{Float64}, Vector{Float64}, Vector{Float64}, SciMLBase.NullParameters, Nothing, LU{Float64, Matrix{Float64}, Vector{Int64}}, SciMLOperators.IdentityOperator, SciMLOperators.IdentityOperator, Float64, true}([2.0 1.0 1.0; -0.5 1.5 0.5; 0.5 -0.3333333333333333 2.6666666666666665], [1.0, 2.0, 7.0], [1.0, 2.0, 1.0], SciMLBase.NullParameters(), nothing, LU{Float64, Matrix{Float64}, Vector{Int64}}([2.0 1.0 1.0; -0.5 1.5 0.5; 0.5 -0.3333333333333333 2.6666666666666665], [3, 2, 3], 0), false, SciMLOperators.IdentityOperator(3), SciMLOperators.IdentityOperator(3), 1.4901161193847656e-8, 1.4901161193847656e-8, 3, false, LinearSolve.OperatorAssumptions{true}())\n\nsol2 = solve(linsolve) # and solve again\n# u: 3-element Vector{Float64}:\n#   1.75\n#   3.75\n#  -0.25000000000000006"
  },
  {
    "objectID": "06_Solving_Linear_Systems.html#footnotes",
    "href": "06_Solving_Linear_Systems.html#footnotes",
    "title": "Solving Linear Systems",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis generally means you have a CUDA or OpenCL capable GPU with the appropriate drivers installed↩︎\nSpecifically forward mode automatic differentiation. See the relevant section for more detail.↩︎"
  },
  {
    "objectID": "07_Solving_Non-linear_Systems.html",
    "href": "07_Solving_Non-linear_Systems.html",
    "title": "Solving Non-linear Systems",
    "section": "",
    "text": "It is often required to solve systems of non-linear equations in engineering. As for the the case of systems of linear equations, there are multiple options in Julia."
  },
  {
    "objectID": "07_Solving_Non-linear_Systems.html#available-packages",
    "href": "07_Solving_Non-linear_Systems.html#available-packages",
    "title": "Solving Non-linear Systems",
    "section": "Available packages",
    "text": "Available packages\nA popular package is NLsolve.jl. This package provides three methods: Trust region, Newton’s method with optional line search, and Anderson acceleration. It can also solve fixed-point problems.\nAlternatively, you could use JuMP - a very powerful mathematical programming modelling language, built on top of Julia, that can call several free and commercial solvers. In this case, set up a problem with non-linear constraints matching your system and a constant value objective function.\nThere are also several less popular packages available.\nIn the spirit of not wanting to learn several different interfaces to access options for different algorithms, we shall stick to the SciML package for non-linear systems, NonlinearSolve.jl.\nThis package uses the same interface as LinearSolve.jl. It has built-in in algorithms, but is also a unified front-end for other packages, including NLsolve.jl."
  },
  {
    "objectID": "07_Solving_Non-linear_Systems.html#nonlinearsolve",
    "href": "07_Solving_Non-linear_Systems.html#nonlinearsolve",
    "title": "Solving Non-linear Systems",
    "section": "NonlinearSolve",
    "text": "NonlinearSolve\nThe NonlinearSolve.jl package can be used to solve three types of problem:\n\nInterval root-finding (bracketing) problems, where a scalar root is found within a specified interval: find \\(t ∈ [tₗ, tₕ]\\) such that \\(f(t) = 0\\)\n\nSolving a system of non-linear equations, i.e. find \\(\\mathbf{u}\\) such that \\(f(\\mathbf{u}) = \\mathbf{0}\\)\nSolving steady-state problems, i.e. solve \\(u' = f(u, t) = f(u, \\infty) = 0\\)\n\nTo solve a problem, you need to provide a function that defines the system of equations. This can take one of two forms:\n\nA non-mutating function (out-of-place), f(t, p), which returns u\nA mutating function (in-place), f!(u, t, p), which mutates the parameter u\n\nYou then define either an IntervalNonlinearProblem, NonlinearProblem or SteadyStateProblem, depending on which of the three types of problems above you want to solve.\nFinally, you call solve() to get the result.\nAs a simple demonstration, we shall calculate the boiling point of water, using the Antoine correlation with parameters from NIST. We calculate the boiling point by finding the root of a function that is the difference between the vapour pressure at a specified temperature and 1 atm. We do this in two ways, using the Newton-Raphson method from a starting guess and using the regula falsi method to find roots in a specified interval.\nusing NonlinearSolve\n\n\"\"\"\n    Calculate the difference between the vapour pressure and 1atm\n\"\"\"\nfunction f(u, p)\n    A, B, C = p\n    return 10^(A - B/(u + C)) - 1.01325\nend\n\n# Antoine parameters from NIST\n# Stull, 1947\np = (4.6543, 1435.264, -64.848)\n\n# Initial guess for NewtonRaphson\nu0 = 373.15\n\n# Specified span for Falsi\nuspan = (370.0, 380.0);\n\nprob = NonlinearProblem(f, u0, p)\nsol = solve(prob, NewtonRaphson()) # u: 373.6009857758806\n\nf(sol.u, p) # 4.121456953498637e-9\n\nprob2 = IntervalNonlinearProblem(f, uspan, p)\nsol2 = solve(prob2, Falsi()) # u: 373.60098565855054\n\nf(sol2.u, p) # -1.5543122344752192e-15\nWe can also solve for the steady-state solution of a differential equation:\n\\[u'(t) = u(t) - u^2(t)\\]\nwith \\(u(0) = 1.5\\). This ODE will have a steady-state at \\(u = 1\\).\nusing NonlinearSolve, DifferentialEquations\n\nfunction ssode(u, p, t)\n    return u - u^2\nend\n\nu0 = 1.5\nprobss = SteadyStateProblem(ssode, u0, nothing)\nsolss = solve(probss, DynamicSS(Vern6())) # u: 1.0000007379583993\nWhile this is a simple demonstration of how to solve for an ODE’s steady-state, it would have been a lot more efficient to convert the problem to a non-linear equation, rather than using the approach of solving the dynamic ODE problem and running to steady-state."
  },
  {
    "objectID": "08_Solving_Differential_Equations.html",
    "href": "08_Solving_Differential_Equations.html",
    "title": "Solving Differential Equations",
    "section": "",
    "text": "The DifferentialEquations package is a very powerful toolkit for solving differential equations. It has multiple, state of the art solvers for ordinary differential equations. It can also handle stochastic differential equations, random differential equations, delay differential equations, differential algebraic equations, stochastic differential algebraic equations etc.\nShould you wish to solve partial differential equations, you will need to convert the PDE to a set of ODEs. This can be done via the method of lines (MethodOfLines.jl), or via several other advanced tools in Julia, including Trixi.jl or several other finite element methods see JuliaFEM.\nHere we shall focus on the most common applications in process modelling, solving systems of ordinary differential equations. In a later section, we shall look at using the method of lines to solve partial differential equations, along with specifying the equations in symbolic form."
  },
  {
    "objectID": "08_Solving_Differential_Equations.html#available-packages-for-odes-and-pdes",
    "href": "08_Solving_Differential_Equations.html#available-packages-for-odes-and-pdes",
    "title": "Solving Differential Equations",
    "section": "",
    "text": "The DifferentialEquations package is a very powerful toolkit for solving differential equations. It has multiple, state of the art solvers for ordinary differential equations. It can also handle stochastic differential equations, random differential equations, delay differential equations, differential algebraic equations, stochastic differential algebraic equations etc.\nShould you wish to solve partial differential equations, you will need to convert the PDE to a set of ODEs. This can be done via the method of lines (MethodOfLines.jl), or via several other advanced tools in Julia, including Trixi.jl or several other finite element methods see JuliaFEM.\nHere we shall focus on the most common applications in process modelling, solving systems of ordinary differential equations. In a later section, we shall look at using the method of lines to solve partial differential equations, along with specifying the equations in symbolic form."
  },
  {
    "objectID": "08_Solving_Differential_Equations.html#system-of-odes---solving-a-plug-flow-reactor-model",
    "href": "08_Solving_Differential_Equations.html#system-of-odes---solving-a-plug-flow-reactor-model",
    "title": "Solving Differential Equations",
    "section": "System of ODEs - Solving a Plug Flow Reactor Model",
    "text": "System of ODEs - Solving a Plug Flow Reactor Model\nFor our ODE example, we take a simple PFR model and a kinetic model.\n\\[ A + B \\rightarrow C\\]\nwith the reaction proceeding in the gas phase over a catalyst with the following rate equation:\n\\[-r_A = k_o exp \\Big[\\frac{E_a}{R}(1/T - 1/T_o)\\Big] P_A P_B\\] \\[[-r_A] = kmol/h/kg\\]\nWe also have the following data:\n\n\n\nParameter\nValue\n\n\n\n\n\\(k_o\\)\n\\(0.5 \\frac{kmol}{h.kg.bar^2}\\)\n\n\n\\(E_a\\)\n\\(100\\ J/mol\\)\n\n\n\\(T_o\\)\n\\(500\\ K\\)\n\n\n\\(R\\)\n\\(8.314\\ J/mol/K\\)\n\n\n\nThe feed stream entering the reactor has 60kmol/h of A and 40kmol/h of B. The reactor is isothermal at 510K. The inlet pressure is 10bar(abs) and the pressure drop is 1bar. Calculate the composition profile for the reactor.\nIn order to solve the problem, we need to tell the solver what the set of ODEs is for each of the molar flows. We already know the equation for the rate of change for A as it flows over the catalyst. Stoichiometry gives us the rate of change for B and C.\nWe package this information into a function, rates(u, p, t), which is what we will supply to the solver.\nThe differential equation solver will accept two forms of functions:\nrates(u, p, t) is a function that takes the current values of the dependent variable(s), model parameter(s), p and the current value of the independent variable, t, and then returns the differential(s) of the dependent variable(s) at that point.\nu can be a vector or a scalar. p should be any iterable type, but is usually passed as a tuple, since this will give faster code than passing a vector.\nThe alternative form, called the in-place form, is rates!(du, u, p, t). In this case, du is a scalar or vector that holds the derivative(s) and is updated in the function. This in-place version typically results in faster code, as there are fewer memory allocation needed. This should be your default form for specifying ordinary differential equations. The exclamation mark (bang, for our American friends) is just a Julia convention to indicate that this is a mutating function, i.e. it modifies one or more of its parameters. Again by convention, this is will usually be the first parameter, du. You do not have to add the exclamation mark to the function name, but this is definitely the preferred thing to do.\nusing DifferentialEquations, Plots\n\n\"\"\"\nThe reactions rates for A + B -&gt; C\n    u:  array with the molar flows of A, B and C\n    p:  tuple with P and T\n    t:  position in the reactor 0..L\n\"\"\"\nfunction rates!(du, u, p, t)\n    k₀ = 0.50\n    Eₐ = 100.0\n    T₀ = 500.0\n    R = 8.314\n    \n    # Convert molar flows to molar fractions\n    y = u ./ sum(u)\n\n    # Unpack the tuple to get pressure and temperature\n    P₀, ΔP, T, tmax = p\n\n    P = P₀ - t/tmax*ΔP\n    k = k₀ * exp(-Eₐ/R * (1/T - 1/T₀))\n    rA = -k * y[1] * y[2] * P^2\n    rB = rA\n    rC = -rA\n\n    du[1] = rA\n    du[2] = rB\n    du[3] = rC\nend\n\n# Set up the input values and pack into a tuple of parameters\nT = 510.0\nP = 10.0\nΔP = 1.0\ntmax = 20.0\np = (P, ΔP, T, tmax)\n\n# The starting values for the initial value problem\nu₀ = [60.0, 40.0, 0.0]\n\n# The span over which to integrate - here the mass of catalyst\ntspan = (0.0, tmax)\n\n# Create the ODEProblem object\nprob = ODEProblem(rates!, u₀, tspan, p)\n\n# Solve with the default solver\nsol = solve(prob)\n\n# Plot the result - the molar flows vs the mass of catalyst\nplot(sol, leg=:right)\nsavefig(\"img/ODEmol.svg\")\n\n\n\nThe plot of sol.u vs sol.t, generated by `plot(sol)\n\n\nThe default plot recipe (defined by the DifferentialEquations package) will plot each of the dependent variables against the independent variable. All we need to do is call plot(sol). Here, the default placement of the legend was interfering with the lines, so we move it to the right centre, by adding leg = :right) to the call to plot().\nNow we have solved the set of three differential equations and we have the molar flows of each component at various points along the length of the reactor. The points were set by the variable step-size solver. There are many options you can pass the solver, including fixed steps at which to record the values. See the documentation for details.\nPart of what is returned in the sol structure is an interpolator. If we want to have the molar flows at any point in the reactor, we need only call sol(x) to get the values of the dependent variables (sol.u) at a value x of the independent variable (sol.t). sol is a callable structure, sometimes called a functor.\nsol(5.123)\n# 3-element Vector{Float64}:\n#  28.55013685340714\n#   8.550136853407144\n#  31.44986314659286\nThe original question however was for the composition, which is generally interpreted as the fractions of the components, not their flows. Let’s convert the results to molar fractions:\n# Now, we want to plot the molar fractions...\n# Copy over the independent values (sol.t) into our x array (optional)\nx = sol.t\n\n# For each entry in sol.u, sum up the molar flows - we get an array of values\n# with the total molar flow at every point in the reactor\ntotflows = sum.(sol.u)\n\n# Now divide the individual flows with the total. \nfracs = sol.u ./ n\n\n# We get the same structure as sol.u - an array of arrays.\n# We need to flatten this to plot it.\ny = hcat(fracs...)'\nplot(x,y, labels=[\"A\" \"B\" \"C\"])\n\n\n\nThe plot of molar fractions in the reactor profile\n\n\nThe last bit of code in this part will need some explanation. As mentioned above, the solution returned by the ODE solver is a structure, sol with multiple fields, including sol.t for the independent variable. This will hold the values for each step taken by the solver. The results for the dependent variables, u[...] are in sol.u, for each the steps in t. This means that sol.u is an array of arrays:\nsol.u\n# 17-element Vector{Vector{Float64}}:\n#  [60.0, 40.0, 0.0]\n#  [59.99858583839893, 39.99858583839893, 0.001414161601070281]  \n#  [59.984446697061045, 39.984446697061045, 0.015553302938956699]\n#  [59.84330258351507, 39.84330258351507, 0.15669741648493382]   \n#  [58.45642225894246, 38.45642225894246, 1.543577741057545]     \n#  ⋮\n#  [21.04774569180567, 1.0477456918056731, 38.952254308194334]\n#  [20.551956292857035, 0.5519562928570385, 39.44804370714297]\n#  [20.282897789407816, 0.2828977894078193, 39.71710221059219]\n#  [20.20298976079487, 0.20298976079487502, 39.79701023920513]\nWe can to convert these to molar fractions, which means we need to divide each entry of the sub-arrays by the sum of that sub-array. This is very easy in Julia. We just do this:\ntotflows = sum.(sol.u)\nfracs = sol.u ./ totflows\nWe broadcast the sum() function over sol.u by inserting a period between the function name and the first parenthesis - sum.(). This means the function is applied individually to each element in sol.u. Since each entry of sol.u is an array, we therefore get the an array of the total molar flows at each point in the reactor.\nNow we want to divide each entry in each sub-array in sol.u with this sum to get the molar fractions at each point. We do this by broadcasting again. For functions the period is inserted between the function name and the parenthesis, but for operators, the period is put in front of the operator. The broadcast, or element-wise, division will divide each entry in fracs (an array of molar flows) by the corresponding entry in totflows. The result in an array of arrays, just like sol.u, but with the molar fractions instead of molar flows.\ntotflows = sum.(sol.u)\n# 17-element Vector{Float64}:\n#  100.0\n#   99.99858583839894\n#   99.98444669706105\n#   99.84330258351507\n#   98.45642225894247\n#    ⋮\n#   61.04774569180567\n#   60.55195629285704\n#   60.282897789407826\n#   60.20298976079488\n\nfracs = sol.u ./ totflows\n# 17-element Vector{Vector{Float64}}:\n#  [0.6, 0.4, 0.0]\n#  [0.5999943432736005, 0.3999915149104007, 1.4141815998834358e-5]\n#  [0.5999377771105296, 0.3999066656657945, 0.0001555572236758087]\n#  [0.5993722266294071, 0.3990583399441108, 0.0015694334264820865]\n#  [0.5937288895710717, 0.39059333435660765, 0.015677776072320636]\n#  ⋮\n#  [0.34477515022525834, 0.01716272533788762, 0.6380621244368541]\n#  [0.339410277571518, 0.009115416357277122, 0.6514743060712049]\n#  [0.33646189107006863, 0.0046928366051030585, 0.6588452723248283]\n#  [0.3355811703217333, 0.0033717554826000534, 0.6610470741956666]\nThe plotting library expects you to pass the x-values as an array and when there are multiple y-values, these should be in a matrix where each column is a series. We therefore need to convert the array of arrays into a matrix.\nThis is done with y = hcat(fracs...)', which uses two new Julia concepts.\nThe first is splatting. If a function, say f(a, b, c) takes three scalar parameters, we can splat an array into the function by calling f(d...), where d is an array. The first entry in d will be passed into a, the second into b and the rest of the array into c. If d had only three entries, c will be a scalar, else c will be a tuple.\nThe opposite of splatting is slurping, when multiple scalars are slurped up into a single array parameter. It uses the same syntax of an ellipsis.\nWhat happens here is that the hcat() function (horizontal concatenation) expects a series of values that will be concatenated as the columns of a new array. We pass it the fracs variable, which is an array of arrays, and we splat it. This means that hcat() gets a series of inputs, one for each row in fracs. These are then concatenated as follows:\nhcat(fracs...)\n# 3×17 Matrix{Float64}:\n#  0.6  0.599994    0.599938     0.599372    0.593729   0.574037   0.540935  0.502011  …  0.391779   0.369135  0.354054   0.344775   0.33941     0.336462    0.335581\n#  0.4  0.399992    0.399907     0.399058    0.390593   0.361056   0.311402  0.253017     0.0876678  0.053702  0.0310817  0.0171627  0.00911542  0.00469284  0.00337176       \n#  0.0  1.41418e-5  0.000155557  0.00156943  0.0156778  0.0649074  0.147664  0.244972     0.520554   0.577163  0.614864   0.638062   0.651474    0.658845    0.661047\nWhy use hcat() and not vcat()? Remember that a 1D array in Julia is considered to be a column vector. This means fracs is a column vector where each entry is also a column vector. If we vcat fracs, these individual column vectors get appended to each other in one long column vector and we lose the distinction between the individual points along the reactor:\nvcat(fracs...)\n# 51-element Vector{Float64}:\n#  0.6\n#  0.4\n#  0.0\n#  0.5999943432702689\n#  0.3999915149054033\n#  1.4141824327869601e-5\n#  0.5999377767074147\n#  ⋮\n#  0.33587562016618194\n#  0.00381343024927297\n#  0.6603109495845451\n#  0.33464693236081094\n#  0.0019703985412164293\n#  0.6633826690979727\nBut the hcat(fracs...) call horizontally concatenated the sub-arrays (column vectors), making each series (species) a row of the matrix. We need each series (species) to be a column. We get that by transposing the result with the ' appended to the end. A' is the transposed version of a real matrix, A\n\n\n\n\n\n\nImportant\n\n\n\nA' is technically the adjoint matrix. This means it is the transpose of the matrix of complex conjugates. For real values, however, this makes no difference. For complex values, you need to call transpose(), rather than use the adjoint operator, if you want the transpose.\n\n\ny = hcat(fracs...)'\n# 17×3 adjoint(::Matrix{Float64}) with eltype Float64:\n#  0.6       0.4         0.0\n#  0.599994  0.399992    1.41418e-5\n#  0.599938  0.399907    0.000155557\n#  0.599372  0.399058    0.00156943\n#  0.593729  0.390593    0.0156778\n#  ⋮\n#  0.344775  0.0171627   0.638062\n#  0.33941   0.00911542  0.651474\n#  0.336462  0.00469284  0.658845\n#  0.335581  0.00337176  0.661047\nFinally we get:\ny = hcat(fracs...)'\n# 17×3 adjoint(::Matrix{Float64}) with eltype Float64:\n#  0.6       0.4         0.0\n#  0.599994  0.399992    1.41418e-5\n#  0.599938  0.399907    0.000155558\n#  0.599372  0.399058    0.00156954\n#  0.593725  0.390587    0.015688\n#  0.573817  0.360726    0.0654572\n#  0.540162  0.310243    0.149596\n#  ⋮\n#  0.366919  0.0503788   0.582702\n#  0.352276  0.0284133   0.619311\n#  0.343461  0.0151917   0.641347\n#  0.338506  0.00775872  0.653735\n#  0.335876  0.00381343  0.660311\n#  0.334647  0.0019704   0.663383\n\n\n\n\n\n\nNote\n\n\n\nNote that the type returned is an adjoint(::Matrix{Float64}). This is a lazy structure. It just maps onto the original matrix, rather than recalculate it, for better efficiency.\n\n\nNow we have each series as a column and we pass the series labels as a row vector (with spaces between the entries, not commas), since each series must also be a column in the labels parameter."
  },
  {
    "objectID": "09_Optimisation.html",
    "href": "09_Optimisation.html",
    "title": "Optimisation",
    "section": "",
    "text": "There are many optimisation packages available in Julia, some for general purposes, other for very specific applications. The most commonly used ones include Optim, NLopt, JuMP, Convex, BlackBoxOptim and IntervalOptimisation.\nOptim and NLopt include several local optimisers. This include gradient free methods, such as Nelder-Mead, Particle Swarm and Simulated Annealing. There are gradient-based methods, such as Conjugated Gradient, Gradient Descent and BFGS/LBFGS, and finally methods that require the Hessian, like Newton’s method.\nJuMP and Convex are powerful packages for mathematical programming - linear and non-linear optimisation with linear and/or non-linear constraints. These packages do not include solvers, but allow you to specify the problem and then call one of several external solvers that have to installed separately. This includes both open source and commercial solvers.\nBlackBoxOptim contains a variety of global optimisation algorithms (within the specified bounded area). These are non-gradient methods like Evolution Strategy methods and stochastic searches.\nWhich package you use will depend on the type of problem you are solving and your personal preferences. For typical local optimisations in process engineering, Optim is very suitable. If you are doing a plant-wide optimisation, JuMP is a very powerful tool. If the function your are optimising has many local minima, BlackBoxOptim and IntervalOptimisation are both very robust. IntervalOptimisation also comes with mathematical guarantees of finding the global optimum in the search area.\nUnfortunately, this also implies that you would need to learn how to use several packages. This is were the SciML organisation again is very helpful. Their Optimization1 package provides a unified front-end for several other optimisation packages, including Optim, NLopt, BlackBoxOptim and all of the external solvers available to JuMP and Convex. There full list includes several others as well. Optimizers can also be used with Flux - a deep learning package - to train neural networks.\nAs with the other sections in this tutorial, we shall look only at the unified front-end of Optimisation. For each of the other packages, the documentation linked to above will provide information on how to use the package and several examples."
  },
  {
    "objectID": "09_Optimisation.html#available-packages",
    "href": "09_Optimisation.html#available-packages",
    "title": "Optimisation",
    "section": "",
    "text": "There are many optimisation packages available in Julia, some for general purposes, other for very specific applications. The most commonly used ones include Optim, NLopt, JuMP, Convex, BlackBoxOptim and IntervalOptimisation.\nOptim and NLopt include several local optimisers. This include gradient free methods, such as Nelder-Mead, Particle Swarm and Simulated Annealing. There are gradient-based methods, such as Conjugated Gradient, Gradient Descent and BFGS/LBFGS, and finally methods that require the Hessian, like Newton’s method.\nJuMP and Convex are powerful packages for mathematical programming - linear and non-linear optimisation with linear and/or non-linear constraints. These packages do not include solvers, but allow you to specify the problem and then call one of several external solvers that have to installed separately. This includes both open source and commercial solvers.\nBlackBoxOptim contains a variety of global optimisation algorithms (within the specified bounded area). These are non-gradient methods like Evolution Strategy methods and stochastic searches.\nWhich package you use will depend on the type of problem you are solving and your personal preferences. For typical local optimisations in process engineering, Optim is very suitable. If you are doing a plant-wide optimisation, JuMP is a very powerful tool. If the function your are optimising has many local minima, BlackBoxOptim and IntervalOptimisation are both very robust. IntervalOptimisation also comes with mathematical guarantees of finding the global optimum in the search area.\nUnfortunately, this also implies that you would need to learn how to use several packages. This is were the SciML organisation again is very helpful. Their Optimization1 package provides a unified front-end for several other optimisation packages, including Optim, NLopt, BlackBoxOptim and all of the external solvers available to JuMP and Convex. There full list includes several others as well. Optimizers can also be used with Flux - a deep learning package - to train neural networks.\nAs with the other sections in this tutorial, we shall look only at the unified front-end of Optimisation. For each of the other packages, the documentation linked to above will provide information on how to use the package and several examples."
  },
  {
    "objectID": "09_Optimisation.html#optimization.jl",
    "href": "09_Optimisation.html#optimization.jl",
    "title": "Optimisation",
    "section": "Optimization.jl",
    "text": "Optimization.jl\nTo use the various optimiser packages with Optimization, you must also install and use packages that link the external solvers with the Optimization interface. For example, to use the solvers in Optim, you would need to use the Optimization package along with the OptimizationOptimJL package, and to use BlackBoxOptim, you would use the OptimizationBBO package along with Optimization. These additional packages are used in order to prevent the need for having to install all of the solver packages as dependencies for Optimization. The specific linker packages needed are given in the documentation section for Optimizer Packages.\nFor our example, we use the famous Rosenbrock function. This function is notorious for pushing optimisers to their limit due to its large flat section around the optimum at (1.0, 1.0), as well as steep slopes away from the optimum.\n\\[f(x, y) = (a - x)^2 + b(y - x^2)^2\\] with \\(a = 1\\) and \\(b = 100\\)\n\n\n\nRosenbrock’s function in two dimensions\n\n\nIn this example (taken from the introductory tutorials of Optimization.jl), we use two optimisers, Nelder-Mead from Optim and an Adaptive Differential Evolution method from BlackBoxOptim. We also time both of these solvers using @btime from BenchmarkTools.\nusing Optimization, OptimizationOptimJL, OptimizationBBO, BenchmarkTools\n\nrosenbrock(u, p) = (p[1] - u[1])^2 + p[2] * (u[2] - u[1]^2)^2\nu0 = zeros(2)\np = [1.0, 100.0]\n\n# Use NelderMead from Optim.jl, linked in via OptimizationOptimJL\n\nprob = OptimizationProblem(rosenbrock, u0, p)\n@btime sol = solve(prob, NelderMead())\n\n# 945.400 μs (3309 allocations: 168.98 KiB)\n# u: 2-element Vector{Float64}:\n#  0.9999634355313174\n#  0.9999315506115275\n\n# Use Adaptive Differential Evolution method adaptive_de_rand_1_bin_radiuslimited from\n# BlackBoxOptim.jl, via OptimizationBBO. This method needs a bounded search area.\n\nprob = OptimizationProblem(rosenbrock, u0, p, lb = [-1.0, -1.0], ub = [1.0, 1.0])\nsol = solve(prob, BBO_adaptive_de_rand_1_bin_radiuslimited())\n\n# 13.260 ms (153718 allocations: 5.69 MiB)\n# u: 2-element Vector{Float64}:\n#  0.9999999999999495\n#  0.9999999999998918\nAs we see, both methods could find the optimum for this function, although the genetic algorithm method from BlackBoxOptim took about 14x longer. This is typical for genetic algorithm methods. They are not fast, but they are extremely robust and will often still find the optima where other methods will fail.\nThe benefit of using Optimization.jl as a front-end is indeed in these cases of difficult to optimise functions, since you can easily change algorithms to find the best methods for your specific problem."
  },
  {
    "objectID": "09_Optimisation.html#footnotes",
    "href": "09_Optimisation.html#footnotes",
    "title": "Optimisation",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis package was originally called GalacticOptim to indicate that it includes a galaxy of optimisers, but the name was shortened due to popular demand.↩︎"
  },
  {
    "objectID": "10_Automatic_Differentiation.html",
    "href": "10_Automatic_Differentiation.html",
    "title": "Automatic Differentiation",
    "section": "",
    "text": "Any reader of this document will be familiar with complex numbers:\n\\[z = x + iy\\] where \\(i^2 = -1\\)\nThe concept of dual numbers, proposed by Clifford, in 1873, is closely related:\n\\[z = a + {\\epsilon}b\\] where \\({\\epsilon}^2 = 0, \\epsilon \\ne 0\\)\nIt can be proven that for any analytic1 function,\n\\[f(a + {\\epsilon}b) = f(a) + bf'(a){\\epsilon}\\]\nTherefore, passing a dual number into our generic function, with \\(b = 1\\), will return, with minimal overhead, both the function value and the derivative at \\(a\\). This is the basis of forward mode automatic differentiation.\nIt is important to note that this is not an approximation of the derivative by finite differencing. Finite differencing, will estimate the derivative with two function calls:\n\\[f'(a) \\approxeq \\frac{f(a + h) - f(a)}{h}\\]\nThe problem with this approach is that using too large a value for \\(h\\), give inaccuracies in the estimation, but using too small a value of \\(h\\) give inaccuracies through floating point rounding errors. There is therefore an optimal value of \\(h\\), which will depend on the value of the function at the point of evaluation. This value is generally both unknown and unknowable. Automatic differentiation does not have this problem and also has fewer function calls, so is more efficient as well as more accurate.\nWe can also easily expand the method to multiple dimensions by simply expanding the idea of a dual number:\n\\[z = a + {\\epsilon}_1v_1 + {\\epsilon}_2v_2 + {\\epsilon}_3v_3 + ...\\]\nwhere each \\(v\\) is a basis vector in which direction we wish to calculate a derivative.\n\\[f(z) = f(a) + f'(a)v_1{\\epsilon}_1+ f'(a)v_1{\\epsilon}_1+ f'(a)v_1{\\epsilon}_1\\]\nThis works perfectly well for a simple analytic function. To extend this to more complicated functions, we simply apply the rules for differentiation:\n\\[c = a + b   =&gt;  dc = da + db\\] \\[c = a - b   =&gt;  dc = da - db\\] \\[c = a * b   =&gt;  dc = b*da + a*db\\] \\[dc = a / b    =&gt;  dc = (da*b - a*db)/b^2\\] \\[c = sin(a)    =&gt;  dc = cos(a)*da\\] \\[\\text{etc.}\\]\nThis is implemented by providing Julia with operator overloading for the dual numbers, i.e. telling Julia how to add, subtract etc. with dual numbers.\nAs a simple example, we define a dual number type and tell Julia how to add and divide dual numbers, so we can test it with the Babylonian algorithm for calculating square roots. This is an example given by Prof Alan Edelman, one of the designers of the Julia language in a YouTube video, that is well worth watching.\n# Import the Base functions we are going to extend\nimport Base: +, /, convert, promote_rule\n\n# Define our Dual number type as a sub-type of Number\nstruct Dual &lt;: Number\n    f::Tuple{Float64, Float64}\nend\n\n# Tell Julia how to add and divide with Dual\n+(x::Dual, y::Dual) = Dual(x.f .+ y.f)\n/(x::Dual, y::Dual) = Dual((x.f[1]/y.f[1], (y.f[1]*x.f[2] - x.f[1]*y.f[2])/y.f[1]^2))\n\n# Tell Julia how to deal with type conversions\nconvert(::Type{Dual}, x::Real) = Dual((float(x), 0.0))\npromote_rule(::Type{Dual}, ::Type{&lt;:Number}) = Dual\n\n\"\"\"\nThe Babylonian algorithm for square roots\n-----------------------------------------\nInitial guess is 1, then for each iteration, take the average of the current estimate, a,\nand x/a. If the current estimate is too large, x/a will be too small and vice versa. \nTaking the average of the two brings us closer with each step. Usually, ten iterations is\nmore than enough.\n\"\"\"\nfunction babylonian(x, n = 10)\n    a = (x + 1)/2\n    for i in 2:n\n        a = (a + x/a)/2\n    end\n    return a\nend\n\n# Test our algorithm\nbabylonian(2) # 1.414213562373095\nerr = babylonian(2) - √2 # -2.220446049250313e-16\n\n# Create a dual number, with the epsilon part set to 1, to \"seed\" the derivative for the first variable\nd = Dual((2., 1.)) # Dual((2.0, 1.0))\n\n# Run the same code we just used for real numbers\nres = babylonian(d) # Dual((1.414213562373095, 0.35355339059327373))\n\n# Check the results\nres.f[1] - √2 # -2.220446049250313e-16\nres.f[2] - 0.5/√2 # 0.0\nHere, we have defined the conversion of a constant to a Dual by setting the derivative part to zero, since the derivative of a constant is zero.\nWhen we call the function, however, we set the \\(b\\) (from \\(z = a + {\\epsilon}b\\)) to one, since we want to calculate the derivative with regards to this variable. If this was a multivariate function, we would pick which derivative we wanted by which of the \\(b\\) values we set to one, with the others set to zero."
  },
  {
    "objectID": "10_Automatic_Differentiation.html#dual-numbers---forward-mode-ad",
    "href": "10_Automatic_Differentiation.html#dual-numbers---forward-mode-ad",
    "title": "Automatic Differentiation",
    "section": "",
    "text": "Any reader of this document will be familiar with complex numbers:\n\\[z = x + iy\\] where \\(i^2 = -1\\)\nThe concept of dual numbers, proposed by Clifford, in 1873, is closely related:\n\\[z = a + {\\epsilon}b\\] where \\({\\epsilon}^2 = 0, \\epsilon \\ne 0\\)\nIt can be proven that for any analytic1 function,\n\\[f(a + {\\epsilon}b) = f(a) + bf'(a){\\epsilon}\\]\nTherefore, passing a dual number into our generic function, with \\(b = 1\\), will return, with minimal overhead, both the function value and the derivative at \\(a\\). This is the basis of forward mode automatic differentiation.\nIt is important to note that this is not an approximation of the derivative by finite differencing. Finite differencing, will estimate the derivative with two function calls:\n\\[f'(a) \\approxeq \\frac{f(a + h) - f(a)}{h}\\]\nThe problem with this approach is that using too large a value for \\(h\\), give inaccuracies in the estimation, but using too small a value of \\(h\\) give inaccuracies through floating point rounding errors. There is therefore an optimal value of \\(h\\), which will depend on the value of the function at the point of evaluation. This value is generally both unknown and unknowable. Automatic differentiation does not have this problem and also has fewer function calls, so is more efficient as well as more accurate.\nWe can also easily expand the method to multiple dimensions by simply expanding the idea of a dual number:\n\\[z = a + {\\epsilon}_1v_1 + {\\epsilon}_2v_2 + {\\epsilon}_3v_3 + ...\\]\nwhere each \\(v\\) is a basis vector in which direction we wish to calculate a derivative.\n\\[f(z) = f(a) + f'(a)v_1{\\epsilon}_1+ f'(a)v_1{\\epsilon}_1+ f'(a)v_1{\\epsilon}_1\\]\nThis works perfectly well for a simple analytic function. To extend this to more complicated functions, we simply apply the rules for differentiation:\n\\[c = a + b   =&gt;  dc = da + db\\] \\[c = a - b   =&gt;  dc = da - db\\] \\[c = a * b   =&gt;  dc = b*da + a*db\\] \\[dc = a / b    =&gt;  dc = (da*b - a*db)/b^2\\] \\[c = sin(a)    =&gt;  dc = cos(a)*da\\] \\[\\text{etc.}\\]\nThis is implemented by providing Julia with operator overloading for the dual numbers, i.e. telling Julia how to add, subtract etc. with dual numbers.\nAs a simple example, we define a dual number type and tell Julia how to add and divide dual numbers, so we can test it with the Babylonian algorithm for calculating square roots. This is an example given by Prof Alan Edelman, one of the designers of the Julia language in a YouTube video, that is well worth watching.\n# Import the Base functions we are going to extend\nimport Base: +, /, convert, promote_rule\n\n# Define our Dual number type as a sub-type of Number\nstruct Dual &lt;: Number\n    f::Tuple{Float64, Float64}\nend\n\n# Tell Julia how to add and divide with Dual\n+(x::Dual, y::Dual) = Dual(x.f .+ y.f)\n/(x::Dual, y::Dual) = Dual((x.f[1]/y.f[1], (y.f[1]*x.f[2] - x.f[1]*y.f[2])/y.f[1]^2))\n\n# Tell Julia how to deal with type conversions\nconvert(::Type{Dual}, x::Real) = Dual((float(x), 0.0))\npromote_rule(::Type{Dual}, ::Type{&lt;:Number}) = Dual\n\n\"\"\"\nThe Babylonian algorithm for square roots\n-----------------------------------------\nInitial guess is 1, then for each iteration, take the average of the current estimate, a,\nand x/a. If the current estimate is too large, x/a will be too small and vice versa. \nTaking the average of the two brings us closer with each step. Usually, ten iterations is\nmore than enough.\n\"\"\"\nfunction babylonian(x, n = 10)\n    a = (x + 1)/2\n    for i in 2:n\n        a = (a + x/a)/2\n    end\n    return a\nend\n\n# Test our algorithm\nbabylonian(2) # 1.414213562373095\nerr = babylonian(2) - √2 # -2.220446049250313e-16\n\n# Create a dual number, with the epsilon part set to 1, to \"seed\" the derivative for the first variable\nd = Dual((2., 1.)) # Dual((2.0, 1.0))\n\n# Run the same code we just used for real numbers\nres = babylonian(d) # Dual((1.414213562373095, 0.35355339059327373))\n\n# Check the results\nres.f[1] - √2 # -2.220446049250313e-16\nres.f[2] - 0.5/√2 # 0.0\nHere, we have defined the conversion of a constant to a Dual by setting the derivative part to zero, since the derivative of a constant is zero.\nWhen we call the function, however, we set the \\(b\\) (from \\(z = a + {\\epsilon}b\\)) to one, since we want to calculate the derivative with regards to this variable. If this was a multivariate function, we would pick which derivative we wanted by which of the \\(b\\) values we set to one, with the others set to zero."
  },
  {
    "objectID": "10_Automatic_Differentiation.html#reverse-mode-ad",
    "href": "10_Automatic_Differentiation.html#reverse-mode-ad",
    "title": "Automatic Differentiation",
    "section": "Reverse Mode AD",
    "text": "Reverse Mode AD\nForward mode AD is fairly easy to understand and implement, but it comes with a disadvantage. If we had \\(n\\) input variables, we would need \\(n\\) function calls to calculate the full gradient.\nWhen fitting models to data, we usually do not care about the derivative in terms of the input, but rather in terms of the parameters of the model, of which there can be many. We can apply automatic differentiation here as well, by passing the parameters as dual numbers. For \\(k\\) parameters, we have a \\(k+1\\) dimensional “dual” number and \\(k\\) function calls.\nWhen there are many parameters, it is possible to use a more efficient method than forward mode automatic differentiation.\nConsider fitting a model. Our model has some outputs, \\(w_i\\), and some inputs, \\(u_i\\). We can use the chain rule to write the derivative of output \\(w\\) in terms of some yet-to-be-chosen variable, \\(t\\):\n\\[\\frac{{\\partial}w}{{\\partial}t} = \\sum_i{\\frac{{\\partial}w}{{\\partial}u_i} \\frac{{\\partial}u_i}{{\\partial}t}}\\]\nTo get the derivative in terms of variable \\(x\\), we simply set \\(t = x\\).\nThe chain rule is symmetric - we can change the numerators and denominators around:\n\\[\\frac{{\\partial}s}{{\\partial}u} = \\sum_i{\\frac{{\\partial}w_i}{{\\partial}u} \\frac{{\\partial}s}{{\\partial}w_i}}\\]\nWhere \\(u\\) is still an input, \\(w\\) an output, and \\(s\\) some yet-to-be-chosen variable. This time, however, we are calculating the derivative of \\(s\\) with regards to the input, \\(u\\). We have now reversed the positions: we are calculating the derivative of \\(s\\) with regards to input \\(u\\).\nLet’s look at a simple example:\n\\[z = xy + sin(x)\\]\nWe can define intermediate variables:\n\\[a = xy\\] \\[b = sin(x)\\] \\[z = a + b\\]\nUsing the reverse chain-rule from above:\n\\[\\frac{\\partial s}{\\partial b} = \\frac{\\partial z}{\\partial b} \\frac{\\partial s}{\\partial z} = \\frac{\\partial s}{\\partial z}\\]\n\\[\\frac{\\partial s}{\\partial a} = \\frac{\\partial z}{\\partial a} \\frac{\\partial s}{\\partial z} = \\frac{\\partial s}{\\partial z}\\]\n\\[\\frac{\\partial s}{\\partial y} = \\frac{\\partial a}{\\partial y} \\frac{\\partial s}{\\partial a} = x \\frac{\\partial s}{\\partial a}\\]\n\\[\\frac{\\partial s}{\\partial x} = \\frac{\\partial a}{\\partial x} \\frac{\\partial s}{\\partial a} + \\frac{\\partial b}{\\partial x} \\frac{\\partial s}{\\partial b} = y \\frac{\\partial s}{\\partial a} + cos(x) \\frac{\\partial s}{\\partial b}\\]\nIf we now substitute \\(s = z\\), we get:\n\\[\\frac{\\partial z}{\\partial b} = \\frac{\\partial z}{\\partial z} = 1\\]\n\\[\\frac{\\partial z}{\\partial a} = \\frac{\\partial z}{\\partial z} = 1\\]\n\\[\\frac{\\partial z}{\\partial y} = x \\frac{\\partial z}{\\partial a} = x\\]\n\\[\\frac{\\partial z}{\\partial x} = y \\frac{\\partial z}{\\partial a} + cos(x) \\frac{\\partial z}{\\partial b} = y + cos(x)\\]\nWe have now managed to calculate both derivatives in a single pass! When training a neural network, that can have hundreds (small ANN) to billions of parameters (ChatGPT), being able to get the full gradient of the model output with regards to all of the model parameters in a single pass is a dramatic improvement in efficiency.\nIn general, when a model has many more outputs than inputs, forward mode automatic differentiation will be the more efficient method and when there are many more inputs than outputs, such as in machine learning, reverse mode will be more efficient. If your model is not large, or not called many times (such as when fitting parameters), you may not notice the difference."
  },
  {
    "objectID": "10_Automatic_Differentiation.html#available-packages",
    "href": "10_Automatic_Differentiation.html#available-packages",
    "title": "Automatic Differentiation",
    "section": "Available packages",
    "text": "Available packages\n\nForwardDiff.jl\nOne of the most used automatic differentiation packages in Julia is ForwardDiff.jl. It has a few limitations to its use:\n\nIt only works on Julia code - you cannot use it on C, Python or R code being called from Julia\nTarget functions must take only one input, which may be a vector, and return either a scalar or vector\nThe function must be written generically, i.e. no types must be specified. This is something that can quickly trip you up, when you for example, initialise a variable to 0.0 or 1.0, both of which are Float64. Rather use zero(x) and one(x), which will return a zero or one in the same type as x.\nInput vectors must be a sub-type of AbstractArray, so some custom types may not be supported. Julia built-in arrays and StaticArrays are supported.\n\nThe package provides several functions, including:\nForwardDiff.derivative(f, x::Real): Calculate the derivative of f(x) in variable x at the current value of x\nForwardDiff.gradient(f, x::AbstractArray): Calculate the gradient of f(x) in each of the variables contained in vector x at the current value of x\nForwardDiff.jacobian(f, x::AbstractArray): Calculate the Jacobian matrix, where f(x) returns a vector of function values calculated from input vector x.\nForwardDiff.hessian(f, x::AbstractArray): Calculate the Hessian matrix, where f returns a scalar value, calculated from input vector x.\nA simple example:\nf(x) = 2x^2 - x\n# f (generic function with 1 method)\n\ndf(x) = ForwardDiff.derivative(f, x)\n# df (generic function with 1 method)\n\nf(2)\n# 6\n\ndf(2)\n# 7\nForwardDiff does have the option to handle mutating functions, where the array result is returned in the first parameter. Several packages use ForwardDiff as an option integrated in solvers, including Roots.jl and Optim.jl, and some of the implicit differential equation solvers.\n\n\nZygote.jl\nThe Zygote package was developed as part of Flux.j - a deep learning package in Julia.\nZygote cannot handle mutating functions, try/catch statements for exception handling or calls to “foreign” code, like a C library. It works during the compilation phase, so generates very efficient code, using reverse mode automatic differentiation.\nUsing Zygote is fairly similar to using ForwardDiff.\ngradient() - calculates the derivative of a function, with either scalar or vector inputs\njacobian() - calculates the Jacobian matrix for a system of equations, as well as hessian\nhessian() - calculates the Hessian matrix for an equation with vector of inputs\nThere are also some additional utility functions. See the documentation for details.\n\n\nEnzyme.jl\nEnzyme is the future of automatic differentiation in Julia. It is a point of debate whether it is currently ready for general use, but if you use AD in your code, it will be good to keep an eye on this package.\nForwardDiff works by passing dual numbers to your code and using the ChainRules.jl package to supply the rules for differentiating more complex equations. Zygote goes a level deeper and generates the code for the derivatives during the compilation pass, using a process of source code transformation. The curious / adventurous can read the article for details.\nEnzyme goes another level deeper and works on the LLVM code generated by the Julia compiler. The result is that there are few, if any, limitations on the code that can be differentiated and the resulting code is very, very fast. Enzyme itself is still under development. It is currently available in Julia and Rust. Enzyme can perform both forward and reverse mode differentiation.\nThere are several exported functions, but the ones most likely to be useful are:\ngradient(): Calculates the gradient of am array-input function\ngradient!(): Calculates the gradient of am array-input function and returns it by updating a passed array variable\njacobian(): calculates the Jacobian matrix of a set of equations\nFor all of these, the mode (forward or reverse) can be specified.\nWatch this space!"
  },
  {
    "objectID": "10_Automatic_Differentiation.html#footnotes",
    "href": "10_Automatic_Differentiation.html#footnotes",
    "title": "Automatic Differentiation",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAny function that is locally given by a convergent power series, such as a Taylor series↩︎"
  },
  {
    "objectID": "11_Modelling_Toolkit_and_Symbolics.html",
    "href": "11_Modelling_Toolkit_and_Symbolics.html",
    "title": "Modeling Toolkit and Symbolics",
    "section": "",
    "text": "Up to now, when we needed to solve a system of ODEs or non-linear equations, for example, we have programmed these and passed them to a solver. If you are comfortable with writing code, this is not a problem. There is however a few tools available in Julia that can make the task a lot easier, both for experienced and novice programmers - a modern Computer Algebra System, Symbolics.jl."
  },
  {
    "objectID": "11_Modelling_Toolkit_and_Symbolics.html#symbolics.jl-and-the-symbolics-ecosystem",
    "href": "11_Modelling_Toolkit_and_Symbolics.html#symbolics.jl-and-the-symbolics-ecosystem",
    "title": "Modeling Toolkit and Symbolics",
    "section": "Symbolics.jl and the Symbolics Ecosystem",
    "text": "Symbolics.jl and the Symbolics Ecosystem\nSymbolics allows you to simply specify the equations for your system and then do symbolic manipulations and simplifications to the system. Since Symbolics is written in pure Julia, it interacts seamlessly with normal Julia code and you can do anything with a symbolic variable you would do with any other Julia variable. This gives great flexibility. It doesn’t stop there however - it will also generate a Julia function for you - optimised and parallelised, if specified.\nIn addition, there are several other packages that build on Symbolics:\n\nModelingToolkit: Provides the tools to symbolically specify common numerical systems like ODEs, PDEs, non-linear systems, control problems, causal and acausal modelling etc.\nCatalyst: Provides tools for specifying reaction networks and kinetics\nDataDrivenDiffEq: Automatic identifications of ODEs/DAEs from data\nSymbolicRegression: Genetic programming to find equations from data\nReversePropagation: Source-to-source mode automatic differentiation"
  },
  {
    "objectID": "11_Modelling_Toolkit_and_Symbolics.html#using-symbolics",
    "href": "11_Modelling_Toolkit_and_Symbolics.html#using-symbolics",
    "title": "Modeling Toolkit and Symbolics",
    "section": "Using Symbolics",
    "text": "Using Symbolics\nThis is a very brief introduction to Symbolics. For more detail, refer to the manual.\nAt the simplest level, Symbolics works with symbolic variables and equations. You specify equations with the @variables macro and then simply build equations with these symbolic variables. You can simplify equations, using simplify(), define and calculate derivatives and Jacobians etc. If you are using Symbolics in a Jupyter notebook or in Pluto, the equations will be rendered as \\(LaTeX\\). In the REPL or a script, there will be text output. You can also generate \\(LaTeX\\) expressions with the Latexify package.\nusing Symbolics\n\n@variables x, y\n# 2-element Vector{Num}:\n#  x\n#  y\n\nz = (x + y)*(x - y)\n\nDx = Differential(x)\n# (::Differential) (generic function with 2 methods)\n\nDy = Differential(y)\n# (::Differential) (generic function with 2 methods)\n\nexpand_derivatives(Dx(z))\n# 2x\n\nexpand_derivatives(Dy(z))\n# -2y\n\nsimplify(2x + x^2 - y - x -2x^2)\n# x - y - (x^2)\n\nA = [x x*y y^2;\n     y 2*x*y x^2*y]\n\n# 2×3 Matrix{Num}:\n#  x   x*y      y^2\n#  y  2x*y  y*(x^2)\n\nlatexify(A)\n# L\"\\begin{equation}\n# \\left[\n# \\begin{array}{ccc}\n# x & x y & y^{2} \\\\\n# y & 2 x y & x^{2} y \\\\\n# \\end{array}\n# \\right]\n# \\end{equation}\n# \"\nThe last result, when rendered in \\(LaTeX\\), or in a Jupyter notebook, for example, looks like this:\n\\[\n\\begin{equation}\n\\left[\n\\begin{array}{ccc}\nx & x y & y^{2} \\\\\ny & 2 x y & x^{2} y \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\nSo, we can do basic mathematics and calculus and make pretty equations for reports. What else can we do? Well, a whole lot, as it turns out. Symbolics is a full-featured CAS (Computer Algebra System). Whats more, since it is fully written in Julia, it interacts with the rest of Julia in a pretty seamless manner. Anything you would do with a Julia variable, you can also do with a symbolic (type Num) variable.\nFor example, we can call a normal, generic function:\nf(u) = 2*u[1] - u[2]\n# f (generic function with 1 method)\n\nf([x, y])\n# 2x - y\nWe can also define more complicated systems, where the variables are dependent on each other:\nusing Symbolics, Latexify\n\n@variables t x(t) y(t) # Declare an unknown dependency on t for x and y\n# 3-element Vector{Num}:\n#     t\n#  x(t)\n#  y(t)\n\nz = x*t + y*t^2\n# t*x(t) + (t^2)*y(t)\n\nDt = Differential(t)\n# (::Differential) (generic function with 2 methods)\n\nexpand_derivatives(Dt(z))\n# t*Differential(t)(x(t)) + (t^2)*Differential(t)(y(t)) + 2t*y(t) + x(t)\n\nlatexify(expand_derivatives(Dt(z)))\n# L\"\\begin{equation}\n# t \\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} + t^{2} \\frac{\\mathrm{d} y\\left( t \\right)}{\\mathrm{d}t} + 2 t y\\left( t \\right) + x\\left( t \\right)\n# \\end{equation}\n# \"\nWhere the result from the last line is: \\[\n\\begin{equation}\nt \\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} + t^{2} \\frac{\\mathrm{d} y\\left( t \\right)}{\\mathrm{d}t} + 2 t y\\left( t \\right) + x\\left( t \\right)\n\\end{equation}\n\\]\nIn other words, since we indicated that x and y depend on t, this information was included in the derivative calculation.\nThe final, but most important part of Symbolics is its ability to convert symbolic equations into Julia code.\n\nusing Symbolics\n\n@variables x y\n# 2-element Vector{Num}:\n#  x\n#  y\n\neqs = [x^2 + y, y^2 + x]\n# 2-element Vector{Num}:\n#  y + x^2\n#  x + y^2)\n\nf_expr = build_function(eqs, [x, y])\nBase.remove_linenums!.(f_expr)\n# (:(function (ˍ₋arg1,)\n#       begin\n#           begin\n#               (SymbolicUtils.Code.create_array)(typeof(ˍ₋arg1), nothing, Val{1}(), Val{(2,)}(), (+)(ˍ₋arg1[2], (^)(ˍ₋arg1[1], 2)), (+)(ˍ₋arg1[1], (^)(ˍ₋arg1[2], 2)))\n#           end\n#       end\n#   end), :(function (ˍ₋out, ˍ₋arg1)\n#       begin\n#           begin\n#               @inbounds begin\n#                   ˍ₋out[1] = (+)(ˍ₋arg1[2], (^)(ˍ₋arg1[1], 2))\n#                   ˍ₋out[2] = (+)(ˍ₋arg1[1], (^)(ˍ₋arg1[2], 2))\n#                   nothing\n#               end\n#           end\n#       end\n#   end))\n\n\n\n\n\n\nNote\n\n\n\nThe Base.remove_linenums!() call just removes a lot of additional line number information form the result to make it more readable. You would not normally bother with this.\n\n\nDon’t worry if this looks unlike anything related to Julia code you have ever seen. What is returned is a Julia expression string - this is how Julia code is stored internally. It is also what you would generate if you wrote a Julia macro (meta-programming). A macro in Julia is a piece of code that, instead of returning a value, returns another piece of code that is then evaluated. Macros in Julia are normally identified by the @ symbol, e.g. @variables. This is a topic for another chapter.\nSo, what is going on here? The first thing to note is that the expression contains a tuple that holds two functions. The first starts with function (ˍ₋arg1,), while the second starts with function (ˍ₋out, ˍ₋arg1). If you look more closely at the code, you will see that the functions (we’ll call then func1 and func2! here) are equivalent to:\nfunction func1(u)\n    return u[2] + u[1]^2, u[1] + u[2]^2\nend \n\nfunction func2!(z, u)\n    z[1] = u[2] + u[1]^2\n    z[2] = u[1] + u[2]^2\nend\nBoth functions will do the same calculations, but func1 returns the values, which requires allocating an array/tuple to store it in, while func2! mutates the first parameter to return the value. These are simply two version of the same function. The first is called an out-of-place function and the second, an in-place function. Sound familiar? We saw these in the chapter on differential equations.\nHow do we use them? We need to tell Julia to evaluate the expression to generate the code:\nmyf1 = eval(f_expr[1])\n# #7 (generic function with 1 method)\n\nmyf1([1, 2])\n# 2-element Vector{Int64}:\n#  3\n#  5\n\nmyf2! = eval(f_expr[2])\n# #9 (generic function with 1 method)\n\nz = zeros(Int, 2)\n# 2-element Vector{Int64}:\n#  0\n#  0\n\nmyf2!(z, [1, 2])\n\nz\n# 2-element Vector{Int64}:\n#  3\n#  5\nThis is the key functionality from Symbolics we want to use. But we won’t use it directly. Rather, we shall use the ModelingToolkit package, that builds on Symbolics and makes it easy to specify systems of equations, differential or non-linear, and then solve them with numerical solvers."
  },
  {
    "objectID": "11_Modelling_Toolkit_and_Symbolics.html#modeling-toolkit",
    "href": "11_Modelling_Toolkit_and_Symbolics.html#modeling-toolkit",
    "title": "Modeling Toolkit and Symbolics",
    "section": "Modeling Toolkit",
    "text": "Modeling Toolkit\n\nNon-linear system\nLet’s start with an example of a simple set of non-linear equations:\n\\[y = 2x^{2} - 7\\] \\[y = 10\\sqrt{x}\\]\n\nusing ModelingToolkit, NonlinearSolve\n\n@variables x y\n@parameters a b c\n\neqs = [y ~ a*x^2 - b, y ~ c*√x]\n\n@named nlsys = NonlinearSystem(eqs, [x, y], [a, b, c])\n\ninitial_guess = [x =&gt; 3.5, y =&gt; 20]\nparams = [a =&gt; 2, b =&gt; 7, c =&gt; 10]\n\nprob = NonlinearProblem(nlsys, initial_guess, params)\nsol = solve(prob, NewtonRaphson())\n\n# u: 2-element Vector{Float64}:\n#   3.6045577280701777\n#  18.98567282997952\nHere we load two packages: ModelingToolkit, to set up the problem, and NonlinearSolve, to solve it.\nUsing the Symbolics package (this is re-exported by ModelingToolkit - you don’t need to explicitly load Symbolics), we specify the variables and parameters for the problem. We could hard code the values of a, b and c, but specifying them as parameters allows to change their values easily later.\nWe specify the system of equations as an array, eqs. Note that in each symbolic equation, we use ~ instead of =. This is simply because Julia has rather strong opinions about you overloading the assignment operator, =, in a macro.\nNow, there is one new step: we create a NonlinearSystem. This is effectively the step were we ask ModelingToolkit to create the code for our system of non-linear equations. We pass the array of equations, an array with the variables and an array with the parameters. The latter can also be an empty array, if you hard-coded the parameter values.\nYou may wonder why there is @named in front of this line…\nWe need a variable to refer to the object created by NonlinearSystem. Internally, however ModelingToolkit needs to also know what the name of this variable is. You could handle this by adding a keyword argument name with the same name as the variable (expressed as a Symbol), or you can just use the convenient macro, @named, that will handle it for you.\nNext, we create a NonlinearProblem, just like we did in the chapter on solving non-linear systems. Instead of passing a function that encodes the system of equations, we pass the object created by NonlinearSystem. Then we solve the problem, exactly like before.\n\n\nSolving ODEs\nThe example above was a fairly straightforward problem. ModelingToolkit can however do a lot more for us. To illustrate some of the magic, we’ll look at an example from the ModelingToolkit documentation.\nHere we have a system three of ODEs, the first of which is a second order ODE.\n\\[\\begin{align}\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} =& \\sigma \\left(  - x\\left( t \\right) + y\\left( t \\right) \\right) \\\\\n\\frac{\\mathrm{d} y\\left( t \\right)}{\\mathrm{d}t} =&  - y\\left( t \\right) + \\left( \\rho - z\\left( t \\right) \\right) x\\left( t \\right) \\\\\n\\frac{\\mathrm{d} z\\left( t \\right)}{\\mathrm{d}t} =& x\\left( t \\right) y\\left( t \\right) - \\beta z\\left( t \\right)\n\\end{align}\\]\nusing ModelingToolkit, DifferentialEquations, Plots\n\n@parameters σ ρ β\n@variables t x(t) y(t) z(t)\nD = Differential(t)\n\neqs = [D(D(x)) ~ σ * (y - x),\n    D(y) ~ x * (ρ - z) - y,\n    D(z) ~ x * y - β * z]\n\n@named sys = ODESystem(eqs)\n\nsys = structural_simplify(sys)\n\nu0 = [D(x) =&gt; 2.0,\n    x =&gt; 1.0,\n    y =&gt; 0.0,\n    z =&gt; 0.0]\n\np = [σ =&gt; 28.0,\n    ρ =&gt; 10.0,\n    β =&gt; 8 / 3]\n\ntspan = (0.0, 100.0)\nprob = ODEProblem(sys, u0, tspan, p, jac = true)\nsol = solve(prob, Tsit5())\n\nplot(sol, idxs = (x, y))\nJust like before, we specify the variables and parameters. We then, again, specify an array of equations. As discussed above in the section on Symbolics, we use Differential to specify the derivatives. A second (or higher) derivative is simply a nested call of this function.\nLike in our previous example, we now need to ask ModelingToolkit to build the code for our system of ODEs. This is done with a call to ODESystem. This time, the call to ODESystem looks a lot simpler. Where are the specifications for the variables and parameters?\nAs it happens, the full call would be:\n@named sys = ODESystem(eqs, t, [x, y, z], [σ, ρ, β])\nThe parameters are the equations, the independent variables, the dependent variables and the parameters. ModelingToolkit is clever enough to figure out which is which for ODESystems. This doesn’t work for NonlinearSystems yet, but one would image this functionality is on its way.\nThe next part is where the magic happens:\nsys = structural_simplify(sys)\nWe call the all-singing, all-dancing structural_simplify(), which is really the heart of ModelingToolkit. It will do a whole host of transformations of your system, using everything available in Symbolics. Let’s look at the intermediate results to understand what it is doing for us:\n@named sys = ODESystem(eqs, t, [x, y, z], [σ, ρ, β])\n\n# Model sys with 3 equations\n# States (3):\n#   x(t)\n#   y(t)\n#   z(t)\n# Parameters (3):\n#   σ\n#   ρ\n#   β\n\nsys = structural_simplify(sys)\n\n# Model sys with 4 equations\n# States (4):\n#   y(t)\n#   z(t)\n#   x(t)\n#   xˍt(t)       \n# Parameters (3):\n#   σ\n#   ρ\n#   β\n# Incidence matrix:4×9 SparseArrays.SparseMatrixCSC{Num, Int64} with 13 stored entries:\n#  ×  ×  ×  ⋅  ⋅  ⋅  ×  ⋅  ⋅\n#  ×  ×  ×  ⋅  ⋅  ⋅  ⋅  ×  ⋅\n#  ⋅  ⋅  ⋅  ×  ⋅  ×  ⋅  ⋅  ⋅\n#  ×  ⋅  ×  ⋅  ⋅  ⋅  ⋅  ⋅  ×\n\nequations(sys)\n\n# 4-element Vector{Equation}:\n#  Differential(t)(y(t)) ~ (ρ - z(t))*x(t) - y(t)\n#  Differential(t)(z(t)) ~ x(t)*y(t) - β*z(t)\n#  Differential(t)(x(t)) ~ xˍt(t)\n#  Differential(t)(xˍt(t)) ~ xˍtt(t)\nFrom the results of each line, you can see that structural_simplify() has converted our system of two first- and one second-order ODEs into a system of four first order ODEs. We can inspect these equations with the equations() function, and get the pretty versions with latexify():\n\\[\\begin{align}\n\\frac{\\mathrm{d} y\\left( t \\right)}{\\mathrm{d}t} =&  - y\\left( t \\right) + \\left( \\rho - z\\left( t \\right) \\right) x\\left( t \\right) \\\\\n\\frac{\\mathrm{d} z\\left( t \\right)}{\\mathrm{d}t} =& x\\left( t \\right) y\\left( t \\right) - \\beta z\\left( t \\right) \\\\\n\\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} =& xˍt\\left( t \\right) \\\\\n\\frac{\\mathrm{d} xˍt\\left( t \\right)}{\\mathrm{d}t} =& xˍtt\\left( t \\right)\n\\end{align}\\]\nWait a minute! Aren’t we missing some details on the last two equations? What is x_tt(t) defined as? For reasons that are as clear as mud, you need to also call observed(sys) to see the missing bits:\nobserved(sys)\n# 1-element Vector{Equation}:\n#  xˍtt(t) ~ σ*(y(t) - x(t))\nThe rest of the code should be familiar. We specify the initial values and the time span for the integration, create an ODEProblem and call the solver. The only part that will be new is in the call to ODEProblem:\nprob = ODEProblem(sys, u0, tspan, p, jac = true)\nWe have added the keyword parameter jac = true. This tells the ODE solver that we have also specified the Jacobian matrix of the system, which was done automatically, and symbolically, for you by ModelingToolkit. This can greatly enhance the solving of difficult systems.\nThen we solve the problem and finally, we plot the results:\n\nThis was a very short introduction to Symbolics and ModelingToolkit. There is a lot more to learn in the documentation, including several tutorials."
  },
  {
    "objectID": "12_Working_with_Files.html",
    "href": "12_Working_with_Files.html",
    "title": "Working with Files",
    "section": "",
    "text": "There are many, many different libraries to manipulate various formats of text and binary files. Here we shall look only at the built-in Julia methods, and the most popular package for reading in large amounts of data - CSV.jl.\nFor cases where you may want to store binary data (such as storing variables to file), the JLD21 package is very convenient.\nFor processing the data, there are again a near-infinite number of options. The most popular, and extremely powerful, choice is to put the data in a DataFrame object. We shall look at DataFrames in more detail in the next section.\n\n\nYou can do simple file access through the base Julia commands open, read/readline(s) and write:\nTo open a file in write mode:\nf = open(\"filename.txt\", \"w\")\n# IOStream(&lt;file filename.txt&gt;)\n\nwrite(f, \"Hello world.\\n\")\n# 13\n\nclose(f)\n\n\n\n\n\n\nNote\n\n\n\nNote that, unlike when printing to the console, there is no print() and println() versions that do or do not add a new line. When writing to a file, you explicitly add the newline (\\n) in the string you are writing.\n\n\nTo open a file in read mode:\nf = open(\"filename.txt\", \"r\")\n# IOStream(&lt;file filename.txt&gt;)\ns = readlines(f)\n# 1-element Vector{String}:\n#  \"Hello world.\"\nTo open a file in append mode:\nf = open(\"filename.txt\", \"a\")\n# IOStream(&lt;file filename.txt&gt;)\nwrite(f, \"Hello back.\\n\")\n# 12\nclose(f)\nf = open(\"filename.txt\", \"r\") # or just f = open(\"filename.txt\")\n# IOStream(&lt;file filename.txt&gt;)\ns = readlines(f)\n2-element Vector{String}:\n#  \"Hello world.\"\n#  \"Hello back.\"\nOpening a file in read, write and append mode is fairly straight-forward. The object returned is an IOStream. There are several ways to interact with this object.\n\nreadline(): Reads the next line in a file and return it as a String\nreadlines(): This reads the entire file, interprets the contents as Strings and returns an array with each line a separate entry.\nread(): This reads the entire file, interprets the contents as data (UInt8, single byte values), e.g.\n\nss = read(f)\n# 25-element Vector{UInt8}:\n#  0x48\n#  0x65\n#  0x6c\n#  0x6c\n#  0x6f\n#  0x20\n#  0x77\n#  0x6f\n#  0x72\n#  0x6c\n#  0x64\n#  0x2e\n#  0x0a\n#  0x48\n#  0x65\n#  0x6c\n#  0x6c\n#  0x6f\n#  0x20\n#  0x62\n#  0x61\n#  0x63\n#  0x6b\n#  0x2e\n#  0x0a\n\nChar.(ss) # Convert the UInt8 data to Char to get better display in Julie\n# 25-element Vector{Char}:\n#  'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n#  'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n#  ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n#  'w': ASCII/Unicode U+0077 (category Ll: Letter, lowercase)\n#  'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n#  'r': ASCII/Unicode U+0072 (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n#  '.': ASCII/Unicode U+002E (category Po: Punctuation, other)\n#  '\\n': ASCII/Unicode U+000A (category Cc: Other, control)\n#  'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n#  'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n#  ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n#  'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n#  'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n#  'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n#  'k': ASCII/Unicode U+006B (category Ll: Letter, lowercase)\n#  '.': ASCII/Unicode U+002E (category Po: Punctuation, other)\n#  '\\n': ASCII/Unicode U+000A (category Cc: Other, control)\n\nwrite(): Write a string to the file.\n\n\n\n\n\n\n\nImportant\n\n\n\nA reminder again, that you need to explicitly add new lines characters, \\n. A call to write(f, \"Line 1\", \"Line 1\") will write the text “Line 1Line 2” to a single line in the file.\n\n\nThe use of open() is optional for reading and overwriting a file (not appending). You could simply supply the filename to read()/readline()/readlines() and write():\nwrite(\"filename.txt\", \"This is some text.\\n\")\n# 19\n\nreadlines(\"filename.txt\")\n# 1-element Vector{String}:\n#  \"This is some text.\"\nWhere open() comes in handy, is when you want to manipulate the contents of the file with a function. Combining open() with a do block is the most common way of doing this:\nas = collect(1:10)\n# 10-element Vector{Int64}:\n#   1\n#   2\n#   3\n#   4\n#   5\n#   6\n#   7\n#   8\n#   9\n#  10\n\nopen(\"data.txt\", \"w\") do f\n    for a in as\n        write(f, string(a)*\"/n\")\n    end\nend\n\nb = Int64[]\n# Int64[]\n\nopen(\"data.txt\", \"r\") do f\n    for l in eachline(f)\n        push!(b, parse(Int64, l))\n    end\nend\n\nb\n# 10-element Vector{Int64}:\n#   1\n#   2\n#   3\n#   4\n#   5\n#   6\n#   7\n#   8\n#   9\n#  10\nSome new things to note in this example: eachline() returns an iterator that contains the lines of the file. We can loop through the lines using this and the lines only get read when needed - very useful for extremely large files.\nparse(), interprets a string as the type that is passed as the first parameter - Int64 in this case. It will error if the interpretation is not possible:\nparse(Float64, \"this is not a numeric value\")\n# ERROR: ArgumentError: cannot parse \"this is not a numeric value\" as Float64\nFor more information, see the manual\n\n\n\nWhile using the built-in file I/O functions are useful for simple text files, we more often work with larger files containing data. The DelimitedFiles package is useful for working with small to medium (in the Mb range, not Gb) files that contain rows and columns of data. This package was a Julia standard library up to v1.9.0, when it was spun out as a separate package. The intent is to do this with more of the standard libraries to allow them to be developed faster and updated in-between Julia versions.\nThe benefit of DelimitedFiles over alternatives, like CSV is that it is lightweight. It does not have the functionality of CSV, nor the speed with larger files. When you only want to read in a small file, however, the additional compile time for CSV is more of a burden than a blessing. This is where DelimitedFiles shines.\nThere are only two function in the package:\n\nreaddlm(): Read a delimited file\nwritedlm(): Write a delimited file\n\nIn order to accommodate a large number of optional parameters, the package declares several versions of readdlm:\nreaddlm(source, delim::AbstractChar, T::Type, eol::AbstractChar; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=false, comment_char='#')\nreaddlm(source, delim::AbstractChar, eol::AbstractChar; options...)\nreaddlm(source, delim::AbstractChar, T::Type; options...)\nreaddlm(source, delim::AbstractChar; options...)\nreaddlm(source, T::Type; options...)\nreaddlm(source; options...)\nThese parameters do the following:\n\nsource: The source filename as a string, or a stream object.\ndelim: The character used as a delimiter, such as ',', or '\\t' (a tab character). Note the single quotes indicating a Char, not a String.\nT: The type of the data. If not specified, the function will interpret the data to identify the type and may return a heterogeneous array. If T is a numeric type, non-numeric entries will be interpreted as NaN for floating point types, or zero.\neol: The end-of-line character, typically '\\n'.\nheader: If true, the first row is read as column headings and the function returns a tuple (data_cells, header_cells), rather than just data_cells\nskipstart: An integer value, indicating the number of lines to skip at the start\nskipblanks: If true, skip blank lines\nuse_mmap: Use a memory map to access the file. This could speed up large file access, but must be used with caution on Windows - only when reading once and never when writing to the file.\nquotes: If true, column entries that are enclosed in double quotes may contain end-of-line and delimiter characters. Double quote characters inside the quote must be escaped with another double quote(\"\")\ndims: A tuple, (rows, columns), that estimated the size of the data. This can speed up things for large files as sufficient memory is allocated in a single block.\ncomments and comment_char: If comments is true, lines starting with comment_char and text after a comment_char in a line are ignored.\n\nThe write option is a lot simpler and only takes the file to write to, the data, the delimiter and then the keyword arguments from readdlm():\nwritedlm(f, A, delim='\\t'; opts)\nHere, the only option that is currently used, is quotes to indicate that quoted strings can contain end-of-line and delimiter characters.\nSome examples:\na = collect(1:5)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = collect(2:2:10)\n# 5-element Vector{Int64}:\n#   2\n#   4\n#   6\n#   8\n#  10\n\nwritedlm(\"data.csv\", [a b], ',')\n\nreadlines(\"data.csv\")\n# 5-element Vector{String}:\n#  \"1,2\"\n#  \"2,4\"\n#  \"3,6\"\n#  \"4,8\"\n#  \"5,10\"\n\ndata = readdlm(\"data.csv\", ',')\n# 5×2 Matrix{Float64}:\n#  1.0   2.0\n#  2.0   4.0\n#  3.0   6.0\n#  4.0   8.0\n#  5.0  10.0\n\ndata = readdlm(\"data.csv\", ',', Int64)\n# 5×2 Matrix{Int64}:\n#  1   2\n#  2   4\n#  3   6\n#  4   8\n#  5  10\n\n\n\nThe FileIO package is a common framework for reading and writing files that is used by many other packages, such as JLD2.\nFileIO supplies load and save and will identify the file’s type from the extension. The actual code for a given file type is implemented by the package that uses FileIO.\nThere is a long list of file types and the packages that implement load and save for them in the FileIO documentation. You can simply use FileIO and the package will call the correct package to save or load your data or file. That package must of course also be installed in your project.\nOne of these packages is JLD2. It implements save and load from FileIO for generic Julia variables. JLD2 replaces the original JLD and is often hugely faster. JLD is still around, but you probably don’t want to use it.\n\n\nFor consistency over many file types, we shall look at the FileIO interface implemented by JLD2. You can either just install and use JLD2 or you can install both FileIO and JLD2, then just use FileIO. If you are only going to deal one or two file types, then you may prefer only installing the specific packages, rather than deal with FileIO. Each package will support load and save functions in addition to their internal functions.\n\n\nThe FileIO specification requires you to supply a name for each variable you save. This can either by via creating a Dict2, or by passing the names and variables sequentially as parameters:\nusing JLD2\n\nstruct MyData\n    x\n    y\nend\n\ndata = MyData(rand(5), rand(5))\n# MyData([0.41915922256751215, 0.36513861729204666, 0.922892254146376, 0.12902554672750943, 0.2285766214336168], [0.8030027668439638, 0.2007295612353277, 0.6996873161379902, 0.7449547510169909, 0.5305104381235525])\n\nv = rand(10)\n# 10-element Vector{Float64}:\n#  0.7689384578959101\n#  0.7408163205271128\n#  0.9655957120143325\n#  0.3581479242990463\n#  0.28719219030844134\n#  0.6645105539839383\n#  0.8936175723328116\n#  0.22088721590210036\n#  0.3338736118785931\n#  0.6492950330159202\n\nsave(\"data.jld2\", Dict(\"data\" =&gt; data, \"vector\" =&gt; v))\nsave(\"data2.jld2\", \"data\", data, \"vector\", v)\nThe last two statements are equivalent.\nTo read the file, you can either read the whole dictionary, or specify the entries you want (using the name you specified when saving):\nload(\"data.jld2\")\n# Dict{String, Any} with 2 entries:\n#   \"vector\" =&gt; [0.768938, 0.740816, 0.965596, 0.358148, 0.287192, 0.664511, 0.893618, 0.220887, 0.333874, 0.649295]\n#   \"data\"   =&gt; MyData([0.419159, 0.365139, 0.922892, 0.129026, 0.228577], [0.803003, 0.20073, 0.699687, 0.744955, 0.5305…\n\ndat = load(\"data.jld2\", \"data\")\nMyData([0.41915922256751215, 0.36513861729204666, 0.922892254146376, 0.12902554672750943, 0.2285766214336168], [0.8030027668439638, 0.2007295612353277, 0.6996873161379902, 0.7449547510169909, 0.5305104381235525])\n\ndata.x == dat.x #Check against the original object created earlier\n# true\n\ndata.y == dat.y\n# true\nHere the struct, MyData is already defined, but if you read a data file in a fresh instance of Julia without defining it, you will see that JLD2 reconstructs the custom type for you:\nusing JLD2\n\ndata = load(\"data.jld2\", \"data\")\n# ┌ Warning: type Main.MyData does not exist in workspace; reconstructing\n# └ @ JLD2 C:\\Users\\Braam\\.julia\\packages\\JLD2\\ryhNR\\src\\data\\reconstructing_datatypes.jl:495\n# JLD2.ReconstructedTypes.var\"##Main.MyData#292\"([0.41915922256751215, 0.36513861729204666, 0.922892254146376, 0.12902554672750943, 0.2285766214336168], [0.8030027668439638, 0.2007295612353277, 0.6996873161379902, 0.7449547510169909, 0.5305104381235525])\n\ntypeof(data)\n# JLD2.ReconstructedTypes.var\"##Main.MyData#292\"\nYou won’t be able to create new objects of the type, however, as the constructors are not also recreated. You will however be able to access the data.\ndata.x\n# 5-element Vector{Float64}:\n#  0.41915922256751215\n#  0.36513861729204666\n#  0.922892254146376\n#  0.12902554672750943\n#  0.2285766214336168\n\ndata.y\n# 5-element Vector{Float64}:\n#  0.8030027668439638\n#  0.2007295612353277\n#  0.6996873161379902\n#  0.7449547510169909\n#  0.5305104381235525\n\n\n\n\n\nCSV, or comma separated values files are a very common way of storing data. You can save an Excel worksheet as a CSV file, and then process that further in Julia.\nThe CSV package is one of the fastest (often the fastest, but things can change with new versions of other packages) ways of reading large (VERY large) CSV files in any language3.\nThe CSV package has a multitude of features. We are only going to look at the most commonly used ones here. You would however spend your time well in reading the full documentation to see other options, like reading data directly from a zip or g-zipped file.\nWe are also going to assume the most common use case, that your data is read into or written from a DataFrame object. There is a separate section on DataFrames.\n\n\nWriting a DataFrame to a CSV file is simple. You just call CSV.write(filename, dataframe, keyword options)\nusing CSV, DataFrames\n\ndf = DataFrame(a = rand(10), b = rand(10))\n# 10×2 DataFrame\n#  Row │ a           b\n#      │ Float64     Float64\n# ─────┼──────────────────────\n#    1 │ 0.48043     0.94456\n#    2 │ 0.0665074   0.677552\n#    3 │ 0.789794    0.396974\n#    4 │ 0.0412975   0.987218\n#    5 │ 0.456003    0.789401\n#    6 │ 0.295094    0.985048\n#    7 │ 0.837373    0.654643\n#    8 │ 0.378567    0.632108\n#    9 │ 0.890707    0.700569\n#   10 │ 0.00709744  0.637061\n\nCSV.write(\"data.csv\", df)\n# \"data.csv\"\nThere are many options that can be passed as keyword arguments. We shall look at only the more commonly used ones:\n\ndelim: A character (or string) that specifies the delimiter character. Default to a comma.\nquotechar: A character that specifies what quote character should be used to wrap strings that contain end-of-line, delimiting characters.\nmissingstring: A string that will be written in the place of missing values.\ndateformat: A date format string for Date and DateTime values.\nappend: If true, will append to an existing file. Defaults to false.\nheader: A list of column names to replace those of the input table or DataFrame\ndecimal: The character to use for decimals, Defaults to '.'.\n\nThere are several more in the documentation.\n\n\n\nThe easiest way to read a CSV file is via CSV.read(). This function allows you to specify a sink - the type the data should be cast into.\nusing CSV, DataFrames\n\ndf = CSV.read(\"data.csv\", DataFrame)\n# 10×2 DataFrame\n#  Row │ a           b\n#      │ Float64     Float64\n# ─────┼──────────────────────\n#    1 │ 0.48043     0.94456\n#    2 │ 0.0665074   0.677552\n#    3 │ 0.789794    0.396974\n#    4 │ 0.0412975   0.987218\n#    5 │ 0.456003    0.789401\n#    6 │ 0.295094    0.985048\n#    7 │ 0.837373    0.654643\n#    8 │ 0.378567    0.632108\n#    9 │ 0.890707    0.700569\n#   10 │ 0.00709744  0.637061\nYou can also pass keyword options, like for CSV.write():\n\nheader:\n\nWhen passed an integer, this is the number of the line that contains the column names. Lines before this are considered comments.\nIf a vector of integers are passed, these rows will be concatenated to determine the column names. - A vector of names (either strings or symbols) can also be passed to specify the names. Don’t do this if there are names in the file, unless you skip that line with skipto\nheader can be set to either zero or false to auto-generate column names (Column1, Column2…).\nIf commented or empty rows are present, counting starts at the first non-commented/non-empty row.\n\nnormalizenames:\n\nWhen set to true, this will replace spaces in names with underscores and any other processing that is needed to generate valid Julia identifiers.\nDefaults to false.\n\nskipto:\n\nJump to the specified line (an integer) and start reading there.\nCan be used to skip the column names and replace them with names specified in header.\nNote that commented and empty rows (if ignoreemptyrows is specified) are not counted.\n\nfooterskip:\n\nSkip the specified number of lines at the end of the file.\nCommented rows do not count, nor empty rows if skipemptyrows is specified.\n\ntranspose:\n\nTranspose the file - rows become columns etc.\n\ncomment:\n\nA string that specifies which rows are commented in the file. Any row beginning with this is considered a comment.\n\nignoreemptyrows:\n\nIf true, empty lines will be skipped.\nNote that this can influence the count in skipto and header.\nDefaults to true.\n\nselect:\n\nPass a vector of integers, symbols, strings or Bools to indicate which columns to read.\nCan also pass a predicate function (i, name) -&gt; keep::Bool Only functions for which the function returns true are kept.\n\ndrop:\n\nThe inverse of select. Indicate which columns to skip.\n\nlimit:\n\nThe maximum number of rows to read.\nCombine with skipto to only read a part of the file.\n\nmissingstring:\n\nSpecifies a string that indicates missing values. Often this will be NA when the data file was generated by R.\n\ndelim:\n\nA character used to separate the columns.\nDefaults to ','.\n\nignorerepeated:\n\nIf true, consecutive delimiters are treated as a single one.\nUse with caution, as consecutive delimiters can also be used to show a missing value from a column. Some files, however, use fixed column widths and pad with delimiters, such as spaces.\n\nquoted:\n\nIndicate whether quoted strings are present\n\nquotechar:\n\nIndicate the character used as quotation mark.\nQuoted strings can include end-of-line and delimiter characters.\n\ndateformat:\n\nA date format string for Date and DateTime columns\nSee Dates.DateFormat in the Julia documentation.\n\ndecimal:\n\nIndicate the decimal character\nDefaults to '.'.\n\ntruestrings / falsestrings\n\nVectors that specify strings that indicate true and false values, like “true”, “TRUE”, “T”, “1”, etc.\n\nskipwhitespace:\n\nIf true, skip leading and trailing white space from values and column names\n\ntypes:\n\nA single type, vector or Dict of types to specify the types of each column, when you want to override the automatic detection of types.\nThe Dict can link a column name (as string or symbol) or index to a type, e.g. Dict(1 =&gt; Int64).\nConsider using validate with types.\n\nvalidate:\n\nCheck that the data and specified types match up.\n\n\nOther parameters specify the number of parallel thread to read in large files and how many lines should be processed to determine the types of each column, etc. Clearly CSV is a complex package with huge flexibility. Unfortunately, this usually means a bit of a learning curve for the users."
  },
  {
    "objectID": "12_Working_with_Files.html#reading-in-data",
    "href": "12_Working_with_Files.html#reading-in-data",
    "title": "Working with Files",
    "section": "",
    "text": "There are many, many different libraries to manipulate various formats of text and binary files. Here we shall look only at the built-in Julia methods, and the most popular package for reading in large amounts of data - CSV.jl.\nFor cases where you may want to store binary data (such as storing variables to file), the JLD21 package is very convenient.\nFor processing the data, there are again a near-infinite number of options. The most popular, and extremely powerful, choice is to put the data in a DataFrame object. We shall look at DataFrames in more detail in the next section.\n\n\nYou can do simple file access through the base Julia commands open, read/readline(s) and write:\nTo open a file in write mode:\nf = open(\"filename.txt\", \"w\")\n# IOStream(&lt;file filename.txt&gt;)\n\nwrite(f, \"Hello world.\\n\")\n# 13\n\nclose(f)\n\n\n\n\n\n\nNote\n\n\n\nNote that, unlike when printing to the console, there is no print() and println() versions that do or do not add a new line. When writing to a file, you explicitly add the newline (\\n) in the string you are writing.\n\n\nTo open a file in read mode:\nf = open(\"filename.txt\", \"r\")\n# IOStream(&lt;file filename.txt&gt;)\ns = readlines(f)\n# 1-element Vector{String}:\n#  \"Hello world.\"\nTo open a file in append mode:\nf = open(\"filename.txt\", \"a\")\n# IOStream(&lt;file filename.txt&gt;)\nwrite(f, \"Hello back.\\n\")\n# 12\nclose(f)\nf = open(\"filename.txt\", \"r\") # or just f = open(\"filename.txt\")\n# IOStream(&lt;file filename.txt&gt;)\ns = readlines(f)\n2-element Vector{String}:\n#  \"Hello world.\"\n#  \"Hello back.\"\nOpening a file in read, write and append mode is fairly straight-forward. The object returned is an IOStream. There are several ways to interact with this object.\n\nreadline(): Reads the next line in a file and return it as a String\nreadlines(): This reads the entire file, interprets the contents as Strings and returns an array with each line a separate entry.\nread(): This reads the entire file, interprets the contents as data (UInt8, single byte values), e.g.\n\nss = read(f)\n# 25-element Vector{UInt8}:\n#  0x48\n#  0x65\n#  0x6c\n#  0x6c\n#  0x6f\n#  0x20\n#  0x77\n#  0x6f\n#  0x72\n#  0x6c\n#  0x64\n#  0x2e\n#  0x0a\n#  0x48\n#  0x65\n#  0x6c\n#  0x6c\n#  0x6f\n#  0x20\n#  0x62\n#  0x61\n#  0x63\n#  0x6b\n#  0x2e\n#  0x0a\n\nChar.(ss) # Convert the UInt8 data to Char to get better display in Julie\n# 25-element Vector{Char}:\n#  'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n#  'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n#  ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n#  'w': ASCII/Unicode U+0077 (category Ll: Letter, lowercase)\n#  'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n#  'r': ASCII/Unicode U+0072 (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n#  '.': ASCII/Unicode U+002E (category Po: Punctuation, other)\n#  '\\n': ASCII/Unicode U+000A (category Cc: Other, control)\n#  'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n#  'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n#  ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n#  'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n#  'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n#  'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n#  'k': ASCII/Unicode U+006B (category Ll: Letter, lowercase)\n#  '.': ASCII/Unicode U+002E (category Po: Punctuation, other)\n#  '\\n': ASCII/Unicode U+000A (category Cc: Other, control)\n\nwrite(): Write a string to the file.\n\n\n\n\n\n\n\nImportant\n\n\n\nA reminder again, that you need to explicitly add new lines characters, \\n. A call to write(f, \"Line 1\", \"Line 1\") will write the text “Line 1Line 2” to a single line in the file.\n\n\nThe use of open() is optional for reading and overwriting a file (not appending). You could simply supply the filename to read()/readline()/readlines() and write():\nwrite(\"filename.txt\", \"This is some text.\\n\")\n# 19\n\nreadlines(\"filename.txt\")\n# 1-element Vector{String}:\n#  \"This is some text.\"\nWhere open() comes in handy, is when you want to manipulate the contents of the file with a function. Combining open() with a do block is the most common way of doing this:\nas = collect(1:10)\n# 10-element Vector{Int64}:\n#   1\n#   2\n#   3\n#   4\n#   5\n#   6\n#   7\n#   8\n#   9\n#  10\n\nopen(\"data.txt\", \"w\") do f\n    for a in as\n        write(f, string(a)*\"/n\")\n    end\nend\n\nb = Int64[]\n# Int64[]\n\nopen(\"data.txt\", \"r\") do f\n    for l in eachline(f)\n        push!(b, parse(Int64, l))\n    end\nend\n\nb\n# 10-element Vector{Int64}:\n#   1\n#   2\n#   3\n#   4\n#   5\n#   6\n#   7\n#   8\n#   9\n#  10\nSome new things to note in this example: eachline() returns an iterator that contains the lines of the file. We can loop through the lines using this and the lines only get read when needed - very useful for extremely large files.\nparse(), interprets a string as the type that is passed as the first parameter - Int64 in this case. It will error if the interpretation is not possible:\nparse(Float64, \"this is not a numeric value\")\n# ERROR: ArgumentError: cannot parse \"this is not a numeric value\" as Float64\nFor more information, see the manual\n\n\n\nWhile using the built-in file I/O functions are useful for simple text files, we more often work with larger files containing data. The DelimitedFiles package is useful for working with small to medium (in the Mb range, not Gb) files that contain rows and columns of data. This package was a Julia standard library up to v1.9.0, when it was spun out as a separate package. The intent is to do this with more of the standard libraries to allow them to be developed faster and updated in-between Julia versions.\nThe benefit of DelimitedFiles over alternatives, like CSV is that it is lightweight. It does not have the functionality of CSV, nor the speed with larger files. When you only want to read in a small file, however, the additional compile time for CSV is more of a burden than a blessing. This is where DelimitedFiles shines.\nThere are only two function in the package:\n\nreaddlm(): Read a delimited file\nwritedlm(): Write a delimited file\n\nIn order to accommodate a large number of optional parameters, the package declares several versions of readdlm:\nreaddlm(source, delim::AbstractChar, T::Type, eol::AbstractChar; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=false, comment_char='#')\nreaddlm(source, delim::AbstractChar, eol::AbstractChar; options...)\nreaddlm(source, delim::AbstractChar, T::Type; options...)\nreaddlm(source, delim::AbstractChar; options...)\nreaddlm(source, T::Type; options...)\nreaddlm(source; options...)\nThese parameters do the following:\n\nsource: The source filename as a string, or a stream object.\ndelim: The character used as a delimiter, such as ',', or '\\t' (a tab character). Note the single quotes indicating a Char, not a String.\nT: The type of the data. If not specified, the function will interpret the data to identify the type and may return a heterogeneous array. If T is a numeric type, non-numeric entries will be interpreted as NaN for floating point types, or zero.\neol: The end-of-line character, typically '\\n'.\nheader: If true, the first row is read as column headings and the function returns a tuple (data_cells, header_cells), rather than just data_cells\nskipstart: An integer value, indicating the number of lines to skip at the start\nskipblanks: If true, skip blank lines\nuse_mmap: Use a memory map to access the file. This could speed up large file access, but must be used with caution on Windows - only when reading once and never when writing to the file.\nquotes: If true, column entries that are enclosed in double quotes may contain end-of-line and delimiter characters. Double quote characters inside the quote must be escaped with another double quote(\"\")\ndims: A tuple, (rows, columns), that estimated the size of the data. This can speed up things for large files as sufficient memory is allocated in a single block.\ncomments and comment_char: If comments is true, lines starting with comment_char and text after a comment_char in a line are ignored.\n\nThe write option is a lot simpler and only takes the file to write to, the data, the delimiter and then the keyword arguments from readdlm():\nwritedlm(f, A, delim='\\t'; opts)\nHere, the only option that is currently used, is quotes to indicate that quoted strings can contain end-of-line and delimiter characters.\nSome examples:\na = collect(1:5)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = collect(2:2:10)\n# 5-element Vector{Int64}:\n#   2\n#   4\n#   6\n#   8\n#  10\n\nwritedlm(\"data.csv\", [a b], ',')\n\nreadlines(\"data.csv\")\n# 5-element Vector{String}:\n#  \"1,2\"\n#  \"2,4\"\n#  \"3,6\"\n#  \"4,8\"\n#  \"5,10\"\n\ndata = readdlm(\"data.csv\", ',')\n# 5×2 Matrix{Float64}:\n#  1.0   2.0\n#  2.0   4.0\n#  3.0   6.0\n#  4.0   8.0\n#  5.0  10.0\n\ndata = readdlm(\"data.csv\", ',', Int64)\n# 5×2 Matrix{Int64}:\n#  1   2\n#  2   4\n#  3   6\n#  4   8\n#  5  10\n\n\n\nThe FileIO package is a common framework for reading and writing files that is used by many other packages, such as JLD2.\nFileIO supplies load and save and will identify the file’s type from the extension. The actual code for a given file type is implemented by the package that uses FileIO.\nThere is a long list of file types and the packages that implement load and save for them in the FileIO documentation. You can simply use FileIO and the package will call the correct package to save or load your data or file. That package must of course also be installed in your project.\nOne of these packages is JLD2. It implements save and load from FileIO for generic Julia variables. JLD2 replaces the original JLD and is often hugely faster. JLD is still around, but you probably don’t want to use it.\n\n\nFor consistency over many file types, we shall look at the FileIO interface implemented by JLD2. You can either just install and use JLD2 or you can install both FileIO and JLD2, then just use FileIO. If you are only going to deal one or two file types, then you may prefer only installing the specific packages, rather than deal with FileIO. Each package will support load and save functions in addition to their internal functions.\n\n\nThe FileIO specification requires you to supply a name for each variable you save. This can either by via creating a Dict2, or by passing the names and variables sequentially as parameters:\nusing JLD2\n\nstruct MyData\n    x\n    y\nend\n\ndata = MyData(rand(5), rand(5))\n# MyData([0.41915922256751215, 0.36513861729204666, 0.922892254146376, 0.12902554672750943, 0.2285766214336168], [0.8030027668439638, 0.2007295612353277, 0.6996873161379902, 0.7449547510169909, 0.5305104381235525])\n\nv = rand(10)\n# 10-element Vector{Float64}:\n#  0.7689384578959101\n#  0.7408163205271128\n#  0.9655957120143325\n#  0.3581479242990463\n#  0.28719219030844134\n#  0.6645105539839383\n#  0.8936175723328116\n#  0.22088721590210036\n#  0.3338736118785931\n#  0.6492950330159202\n\nsave(\"data.jld2\", Dict(\"data\" =&gt; data, \"vector\" =&gt; v))\nsave(\"data2.jld2\", \"data\", data, \"vector\", v)\nThe last two statements are equivalent.\nTo read the file, you can either read the whole dictionary, or specify the entries you want (using the name you specified when saving):\nload(\"data.jld2\")\n# Dict{String, Any} with 2 entries:\n#   \"vector\" =&gt; [0.768938, 0.740816, 0.965596, 0.358148, 0.287192, 0.664511, 0.893618, 0.220887, 0.333874, 0.649295]\n#   \"data\"   =&gt; MyData([0.419159, 0.365139, 0.922892, 0.129026, 0.228577], [0.803003, 0.20073, 0.699687, 0.744955, 0.5305…\n\ndat = load(\"data.jld2\", \"data\")\nMyData([0.41915922256751215, 0.36513861729204666, 0.922892254146376, 0.12902554672750943, 0.2285766214336168], [0.8030027668439638, 0.2007295612353277, 0.6996873161379902, 0.7449547510169909, 0.5305104381235525])\n\ndata.x == dat.x #Check against the original object created earlier\n# true\n\ndata.y == dat.y\n# true\nHere the struct, MyData is already defined, but if you read a data file in a fresh instance of Julia without defining it, you will see that JLD2 reconstructs the custom type for you:\nusing JLD2\n\ndata = load(\"data.jld2\", \"data\")\n# ┌ Warning: type Main.MyData does not exist in workspace; reconstructing\n# └ @ JLD2 C:\\Users\\Braam\\.julia\\packages\\JLD2\\ryhNR\\src\\data\\reconstructing_datatypes.jl:495\n# JLD2.ReconstructedTypes.var\"##Main.MyData#292\"([0.41915922256751215, 0.36513861729204666, 0.922892254146376, 0.12902554672750943, 0.2285766214336168], [0.8030027668439638, 0.2007295612353277, 0.6996873161379902, 0.7449547510169909, 0.5305104381235525])\n\ntypeof(data)\n# JLD2.ReconstructedTypes.var\"##Main.MyData#292\"\nYou won’t be able to create new objects of the type, however, as the constructors are not also recreated. You will however be able to access the data.\ndata.x\n# 5-element Vector{Float64}:\n#  0.41915922256751215\n#  0.36513861729204666\n#  0.922892254146376\n#  0.12902554672750943\n#  0.2285766214336168\n\ndata.y\n# 5-element Vector{Float64}:\n#  0.8030027668439638\n#  0.2007295612353277\n#  0.6996873161379902\n#  0.7449547510169909\n#  0.5305104381235525\n\n\n\n\n\nCSV, or comma separated values files are a very common way of storing data. You can save an Excel worksheet as a CSV file, and then process that further in Julia.\nThe CSV package is one of the fastest (often the fastest, but things can change with new versions of other packages) ways of reading large (VERY large) CSV files in any language3.\nThe CSV package has a multitude of features. We are only going to look at the most commonly used ones here. You would however spend your time well in reading the full documentation to see other options, like reading data directly from a zip or g-zipped file.\nWe are also going to assume the most common use case, that your data is read into or written from a DataFrame object. There is a separate section on DataFrames.\n\n\nWriting a DataFrame to a CSV file is simple. You just call CSV.write(filename, dataframe, keyword options)\nusing CSV, DataFrames\n\ndf = DataFrame(a = rand(10), b = rand(10))\n# 10×2 DataFrame\n#  Row │ a           b\n#      │ Float64     Float64\n# ─────┼──────────────────────\n#    1 │ 0.48043     0.94456\n#    2 │ 0.0665074   0.677552\n#    3 │ 0.789794    0.396974\n#    4 │ 0.0412975   0.987218\n#    5 │ 0.456003    0.789401\n#    6 │ 0.295094    0.985048\n#    7 │ 0.837373    0.654643\n#    8 │ 0.378567    0.632108\n#    9 │ 0.890707    0.700569\n#   10 │ 0.00709744  0.637061\n\nCSV.write(\"data.csv\", df)\n# \"data.csv\"\nThere are many options that can be passed as keyword arguments. We shall look at only the more commonly used ones:\n\ndelim: A character (or string) that specifies the delimiter character. Default to a comma.\nquotechar: A character that specifies what quote character should be used to wrap strings that contain end-of-line, delimiting characters.\nmissingstring: A string that will be written in the place of missing values.\ndateformat: A date format string for Date and DateTime values.\nappend: If true, will append to an existing file. Defaults to false.\nheader: A list of column names to replace those of the input table or DataFrame\ndecimal: The character to use for decimals, Defaults to '.'.\n\nThere are several more in the documentation.\n\n\n\nThe easiest way to read a CSV file is via CSV.read(). This function allows you to specify a sink - the type the data should be cast into.\nusing CSV, DataFrames\n\ndf = CSV.read(\"data.csv\", DataFrame)\n# 10×2 DataFrame\n#  Row │ a           b\n#      │ Float64     Float64\n# ─────┼──────────────────────\n#    1 │ 0.48043     0.94456\n#    2 │ 0.0665074   0.677552\n#    3 │ 0.789794    0.396974\n#    4 │ 0.0412975   0.987218\n#    5 │ 0.456003    0.789401\n#    6 │ 0.295094    0.985048\n#    7 │ 0.837373    0.654643\n#    8 │ 0.378567    0.632108\n#    9 │ 0.890707    0.700569\n#   10 │ 0.00709744  0.637061\nYou can also pass keyword options, like for CSV.write():\n\nheader:\n\nWhen passed an integer, this is the number of the line that contains the column names. Lines before this are considered comments.\nIf a vector of integers are passed, these rows will be concatenated to determine the column names. - A vector of names (either strings or symbols) can also be passed to specify the names. Don’t do this if there are names in the file, unless you skip that line with skipto\nheader can be set to either zero or false to auto-generate column names (Column1, Column2…).\nIf commented or empty rows are present, counting starts at the first non-commented/non-empty row.\n\nnormalizenames:\n\nWhen set to true, this will replace spaces in names with underscores and any other processing that is needed to generate valid Julia identifiers.\nDefaults to false.\n\nskipto:\n\nJump to the specified line (an integer) and start reading there.\nCan be used to skip the column names and replace them with names specified in header.\nNote that commented and empty rows (if ignoreemptyrows is specified) are not counted.\n\nfooterskip:\n\nSkip the specified number of lines at the end of the file.\nCommented rows do not count, nor empty rows if skipemptyrows is specified.\n\ntranspose:\n\nTranspose the file - rows become columns etc.\n\ncomment:\n\nA string that specifies which rows are commented in the file. Any row beginning with this is considered a comment.\n\nignoreemptyrows:\n\nIf true, empty lines will be skipped.\nNote that this can influence the count in skipto and header.\nDefaults to true.\n\nselect:\n\nPass a vector of integers, symbols, strings or Bools to indicate which columns to read.\nCan also pass a predicate function (i, name) -&gt; keep::Bool Only functions for which the function returns true are kept.\n\ndrop:\n\nThe inverse of select. Indicate which columns to skip.\n\nlimit:\n\nThe maximum number of rows to read.\nCombine with skipto to only read a part of the file.\n\nmissingstring:\n\nSpecifies a string that indicates missing values. Often this will be NA when the data file was generated by R.\n\ndelim:\n\nA character used to separate the columns.\nDefaults to ','.\n\nignorerepeated:\n\nIf true, consecutive delimiters are treated as a single one.\nUse with caution, as consecutive delimiters can also be used to show a missing value from a column. Some files, however, use fixed column widths and pad with delimiters, such as spaces.\n\nquoted:\n\nIndicate whether quoted strings are present\n\nquotechar:\n\nIndicate the character used as quotation mark.\nQuoted strings can include end-of-line and delimiter characters.\n\ndateformat:\n\nA date format string for Date and DateTime columns\nSee Dates.DateFormat in the Julia documentation.\n\ndecimal:\n\nIndicate the decimal character\nDefaults to '.'.\n\ntruestrings / falsestrings\n\nVectors that specify strings that indicate true and false values, like “true”, “TRUE”, “T”, “1”, etc.\n\nskipwhitespace:\n\nIf true, skip leading and trailing white space from values and column names\n\ntypes:\n\nA single type, vector or Dict of types to specify the types of each column, when you want to override the automatic detection of types.\nThe Dict can link a column name (as string or symbol) or index to a type, e.g. Dict(1 =&gt; Int64).\nConsider using validate with types.\n\nvalidate:\n\nCheck that the data and specified types match up.\n\n\nOther parameters specify the number of parallel thread to read in large files and how many lines should be processed to determine the types of each column, etc. Clearly CSV is a complex package with huge flexibility. Unfortunately, this usually means a bit of a learning curve for the users."
  },
  {
    "objectID": "12_Working_with_Files.html#footnotes",
    "href": "12_Working_with_Files.html#footnotes",
    "title": "Working with Files",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe data is stored in a format compatible with the HDF5 standard and the package and read most files created by other programs in HDF5 format. HDF, or Hierarchical Data Format is a standard created by the US National Center for Supercomputing Applications.↩︎\nA dictionary, or a collection of name and value pairs.↩︎\nSee https://www.zdnet.com/article/programming-languages-julia-touts-its-speed-edge-over-python-and-r/ as an example. Here Julia and CSV was up to 22x faster than R’s fread and both R and Julia were faster than Pandas (Python)↩︎"
  },
  {
    "objectID": "13_DataFrames.html",
    "href": "13_DataFrames.html",
    "title": "DataFrames",
    "section": "",
    "text": "In short, a DataFrame is a table of data, where each column has a title and a type. Operations can be performed on a per column or per row basis, and columns and rows can be added or removed easily. The DataFrames package in Julia is the de facto standard for working with tabular data and is integrated in many other packages. In the previous section we have seen that you can read a data file directly into a DataFrame via the CSV package, but this is only one example of other packages integrating with DataFrames.\nThe DataFrames package provides a lot of functionality for manipulating the data contain in a DataFrame. There are also additional packages that provide either more options, or alternative (simpler) syntax for convenience, such as DataFramesMeta and Tidier.\nWe shall look at the basic use of DataFrames and leave these auxiliary packages and some more advanced functionality of DataFrames for self-study.\n\n\nUsually, you would create a DataFrame by reading in data from a file. You can however also create a DataFrame from variables directly:\ndf = DataFrame(X = [1, 2, 3], Y = [2, 3, 4], Z = 2.0)\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Float64\n# ─────┼───────────────────────\n#    1 │     1      2      2.0\n#    2 │     2      3      2.0\n#    3 │     3      4      2.0\nNote that columns X and Y are specified as arrays of integers, and so the columns are typed as Int64. Z is specified as a floating point value and hence the column is types as Float64. The length of Z is also expanded to be the same as the other columns, with a fixed value. The column names, X, Y and Z, are all legal Julia symbols (variable names) and so we can use the assignment operator (=) here.\nYou can also give columns longer names, with spaces, but then instead you need to either use the pair operator, =&gt;, or define a Dict and then convert that to a DataFrame:\ndf = DataFrame(\"X values\" =&gt; [1, 2, 3], \"Y values\" =&gt; [2, 3, 4], \"Z\" =&gt; 2.0)\n# 3×3 DataFrame\n#  Row │ X values  Y values  Z\n#      │ Int64     Int64     Float64\n# ─────┼─────────────────────────────\n#    1 │        1         2      2.0\n#    2 │        2         3      2.0\n#    3 │        3         4      2.0\n\nd = Dict(\"X values\" =&gt; [1, 2, 3], \"Y values\" =&gt; [2, 3, 4], \"Z\" =&gt; 2.0)\n# Dict{String, Any} with 3 entries:\n#   \"Z\"        =&gt; 2.0\n#   \"X values\" =&gt; [1, 2, 3]\n#   \"Y values\" =&gt; [2, 3, 4]\n\ndf = DataFrame(d)\n# 3×3 DataFrame\n#  Row │ X values  Y values  Z\n#      │ Int64     Int64     Float64\n# ─────┼─────────────────────────────\n#    1 │        1         2      2.0\n#    2 │        2         3      2.0\n#    3 │        3         4      2.0\n\n\n\n\n\n\nCaution\n\n\n\nDon’t use strings for column names just because you can. Using a symbol, like :X_values, instead of the string “X values” will give faster results and is just as readable. This does mean you need to use underscores instead of spaces, but all-in-all that is not too high a price to pay.\n\n\nA DataFrame can also be constructed one column at a time:\ndf = DataFrame()\n# 0×0 DataFrame\n\ndf.A = 1:3\n# 1:3\n\ndf.B = 2:2:6\n# 2:2:6\n\ndf\n# 3×2 DataFrame\n#  Row │ A      B\n#      │ Int64  Int64\n# ─────┼──────────────\n#    1 │     1      2\n#    2 │     2      4\n#    3 │     3      6\nOr row by row:\ndf = DataFrame(A=String[], B=Int64[])\n# 0×2 DataFrame\n#  Row │ A       B\n#      │ String  Int64\n# ─────┴───────────────\n\npush!(df, (\"Bob\", 1))\n# 1×2 DataFrame\n#  Row │ A       B\n#      │ String  Int64\n# ─────┼───────────────\n#    1 │ Bob         1\n\npush!(df, (\"Tom\", 5))\n# 2×2 DataFrame\n#  Row │ A       B\n#      │ String  Int64\n# ─────┼───────────────\n#    1 │ Bob         1\n#    2 │ Tom         5\nNote how we forced types of the columns in the creation of the empty DataFrame. This is needed to give the columns names, and tell the empty DataFrame how many columns it will hold. You could specify the types as Any, but that would not lead to good performance.\nLastly, you can also convert a matrix to a DataFrame. This requires you to either allow DataFrames to automatically generate column names, or to pass a vector of names:\nm = rand(5, 5)\n# 5×5 Matrix{Float64}:\n#  0.460589   0.734461   0.771352   0.292767   0.0078547\n#  0.254958   0.153814   0.571355   0.196476   0.739701\n#  0.0799407  0.457583   0.553493   0.25409    0.245967\n#  0.106429   0.435509   0.0184347  0.932008   0.805972\n#  0.0877892  0.0231817  0.435262   0.0187286  0.812151\n\ndf = DataFrame(m, :auto) # Automatically generate names\n# 5×5 DataFrame\n#  Row │ x1         x2         x3         x4         x5\n#      │ Float64    Float64    Float64    Float64    Float64\n# ─────┼───────────────────────────────────────────────────────\n#    1 │ 0.460589   0.734461   0.771352   0.292767   0.0078547\n#    2 │ 0.254958   0.153814   0.571355   0.196476   0.739701\n#    3 │ 0.0799407  0.457583   0.553493   0.25409    0.245967\n#    4 │ 0.106429   0.435509   0.0184347  0.932008   0.805972\n#    5 │ 0.0877892  0.0231817  0.435262   0.0187286  0.812151\n\ndf = DataFrame(m, [:X, :Y, :Z, :W, :Q]) # Specify names\n# 5×5 DataFrame\n#  Row │ X          Y          Z          W          Q\n#      │ Float64    Float64    Float64    Float64    Float64\n# ─────┼───────────────────────────────────────────────────────\n#    1 │ 0.460589   0.734461   0.771352   0.292767   0.0078547\n#    2 │ 0.254958   0.153814   0.571355   0.196476   0.739701\n#    3 │ 0.0799407  0.457583   0.553493   0.25409    0.245967\n#    4 │ 0.106429   0.435509   0.0184347  0.932008   0.805972\n#    5 │ 0.0877892  0.0231817  0.435262   0.0187286  0.812151\n\n\n\nOnce the data is in a DataFrame, you can access column like they are individual vectors1:\ndf.X\n# 5-element Vector{Float64}:\n#  0.460589206535297\n#  0.25495814887990786\n#  0.07994066869519556\n#  0.10642869978604408\n#  0.0877892134158087\nYou can also add columns, even via calculations:\ndf.New = (df.X).^2 .- df.Y\n# 5-element Vector{Float64}:\n#  -0.5223183397440386\n#  -0.08881079559662731\n#  -0.45119243718262425\n#  -0.42418203290738643\n#  -0.015474773743873368\n\ndf\n# 5×6 DataFrame\n#  Row │ X          Y          Z          W          Q          New\n#      │ Float64    Float64    Float64    Float64    Float64    Float64\n# ─────┼───────────────────────────────────────────────────────────────────\n#    1 │ 0.460589   0.734461   0.771352   0.292767   0.0078547  -0.522318\n#    2 │ 0.254958   0.153814   0.571355   0.196476   0.739701   -0.0888108\n#    3 │ 0.0799407  0.457583   0.553493   0.25409    0.245967   -0.451192\n#    4 │ 0.106429   0.435509   0.0184347  0.932008   0.805972   -0.424182\n#    5 │ 0.0877892  0.0231817  0.435262   0.0187286  0.812151   -0.0154748\nNote the use of broadcasting in the first command - using .^ instead of ^ and .- instead of -. This tells Julia to execute these operations in element-wise fashion. The new column, df.New, is added to the DataFrame automatically.\nYou can also access individual entries by specifying the row and column, the latter using either the names or indexes:\ndf[2, 3] # Row 2, Column 3 (Z)\n# 0.5713552793835407\n\ndf[2:3, 3:5]\n# 2×3 DataFrame\n#  Row │ Z         W         Q\n#      │ Float64   Float64   Float64\n# ─────┼──────────────────────────────\n#    1 │ 0.571355  0.196476  0.739701\n#    2 │ 0.553493  0.25409   0.245967\n\ndf[1:3, :W]\n# 3-element Vector{Float64}:\n#  0.29276715395306163\n#  0.19647571959450094\n#  0.25409034700483624\nTo select an entire row or column, the : operator is used, just like in Arrays. This returns a copy of the slice of the DataFrame. When using a !, however, a view to the data is returned. Modifying the view will modify the contents of the DataFrame as well:\ndf = DataFrame(X = [1, 2, 3], Y = [2, 4, 6], Z = [3, 6, 9])\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Int64\n# ─────┼─────────────────────\n#    1 │     1      2      3\n#    2 │     2      4      6\n#    3 │     3      6      9\n\nxvals = df[:, :X]\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nxvals[1] = 100\n# 100\n\ndf\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Int64\n# ─────┼─────────────────────\n#    1 │     1      2      3\n#    2 │     2      4      6\n#    3 │     3      6      9\n\nxview = df[!, :X]\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nxview[1] = 100\n# 100\n\ndf\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Int64\n# ─────┼─────────────────────\n#    1 │   100      2      3\n#    2 │     2      4      6\n#    3 │     3      6      9\nYou can also select just specific rows and columns:\ndf[[1, 3], [1, 3]]\n# 2×2 DataFrame\n#  Row │ X      Z     \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      3\n#    2 │     3      9\n\n\n\nData wrangling is the pre-processing of your data to get it into the form you need for the modelling or analysis you intend to do with it. This can include many steps. DataFrames has a rich feature set to support you in this. We’ll look at several examples here, but if you are going to be doing this type of work often, save yourself a lot of page-turning and download, print and laminate a copy of the Data Wrangling with DataFrames.jl Cheat Sheet.\nWe start off by creating a dataset to work with:\ndf = DataFrame(X = 1:3:1500, Y = repeat(1:100, outer=5), Z = repeat(1:100, inner=5)\n# 500×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      1 \n#    2 │     4      2      1 \n#    3 │     7      3      1 \n#    4 │    10      4      1 \n#    5 │    13      5      1 \n#    6 │    16      6      2 \n#    7 │    19      7      2 \n#    8 │    22      8      2 \n#    9 │    25      9      2 \n#   ⋮  │   ⋮      ⋮      ⋮   \n#  492 │  1474     92     99 \n#  493 │  1477     93     99\n#  494 │  1480     94     99\n#  495 │  1483     95     99\n#  496 │  1486     96    100\n#  497 │  1489     97    100\n#  498 │  1492     98    100\n#  499 │  1495     99    100\n#  500 │  1498    100    100\n#            482 rows omitted\n\nfirst(df,3)\n# 3×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      1\n#    2 │     4      2      1\n#    3 │     7      3      1\n\nlast(df,4)\n# 4×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │  1489     97    100\n#    2 │  1492     98    100\n#    3 │  1495     99    100\n#    4 │  1498    100    100\n\nnames(df)\n# 3-element Vector{String}:\n#  \"X\"\n#  \"Y\"\n#  \"Z\"\n\ndescribe(df)\n# 3×7 DataFrame\n#  Row │ variable  mean     min    median   max    nmissing  eltype   \n#      │ Symbol    Float64  Int64  Float64  Int64  Int64     DataType \n# ─────┼──────────────────────────────────────────────────────────────\n#    1 │ X           749.5      1    749.5   1498         0  Int64\n#    2 │ Y            50.5      1     50.5    100         0  Int64\n#    3 │ Z            50.5      1     50.5    100         0  Int64\nIn generating this data, we used Julia’s repeat function. For the Y column, we specify outer=5, which means the data (1:100) is repeated 5 times as a set, i.e. 1 to 100, then 1 to 100 again, for a total of 5 times. For the Z column, we specify inner=5, which means each of the values from 1 to 100 is repeated 5 times: 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,… etc.\nWe can quickly see the first or last few rows using the Julia functions first and last, with the second parameter showing how many entries to display. The number of rows displayed by Julia for the full DataFrame depends on the size of the window it is being displayed in. The middle omitted rows are indicated with the ⋮ characters. If the DataFrame is too wide, columns will also be omitted, with a message indicating how many columns are hidden.\nIf you really want to see all the rows or columns, you can call show and specify allrows=true and/or allcols=true\nshow(df, allrows=true, allcols=true)\nFor obvious reasons, we won’t include the 500 rows of data here.\nThe names() function returns a vector of the column names as strings. You can also get summary statistics of the data with the describe() function.\nIf you only want specific statistics, you can specify them in the call:\ndescribe(df, :mean, :std)\n# 3×3 DataFrame\n#  Row │ variable  mean     std     \n#      │ Symbol    Float64  Float64 \n# ─────┼────────────────────────────\n#    1 │ X           749.5  433.445\n#    2 │ Y            50.5   28.895\n#    3 │ Z            50.5   28.895\nYou can also apply a custom function to describe the data. Here we use the Julia function extrema(), which returns the minimum and maximum value in an array. We’ll specify that we want the results in a column call minmax:\ndescribe(df, extrema =&gt; :minmax)\n# 3×2 DataFrame\n#  Row │ variable  minmax    \n#      │ Symbol    Tuple…    \n# ─────┼─────────────────────\n#    1 │ X         (1, 1498)\n#    2 │ Y         (1, 100)\n#    3 │ Z         (1, 100)\nLastly, the number of rows and column can be easily retrieved:\nnrow(df)\n# 500\n\nncol(df)\n# 6\n\n\n\n\nIn the introductory section, we selected specific rows and columns based on their indices. You can also select columns based on their names:\nselect(df, [:X, :Z])\n# 500×2 DataFrame     \n#  Row │ X      Z     \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      1\n#    2 │     4      1\n#    3 │     7      1\n#   ⋮  │   ⋮      ⋮\n#  498 │  1492    100\n#  499 │  1495    100\n#  500 │  1498    100\n#     494 rows omitted\nThere are also selector function to allow for selection of ranges of columns:\n\nNot(): Select all the columns expect the specified one(s)\nBetween(): Select all column starting with the first specified column and ending with the second. You can use names or indices to specify the columns\nCols(): Use this to combine other selector functions\nAll(): Select all columns - same as specifying :\n\nExamples:\nIn the previous example we selected columns X and Z, which is the same as selecting everything expect Y:\nselect(df, Not(:Y))\n# 500×2 DataFrame\n#  Row │ X      Z     \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      1\n#    2 │     4      1\n#    3 │     7      1\n#   ⋮  │   ⋮      ⋮\n#  498 │  1492    100\n#  499 │  1495    100\n#  500 │  1498    100\n#     494 rows omitted\nWe only passed a single symbol to Not, but could also pass an array of symbols to exclude multiple columns.\nTo make things more interesting, we can first add a few more columns:\ndf.A = 2 .* df.X\ndf.B = df.Y .+ df.Z\ndf.C = df.Z .^ 2\ndf\n# 500×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │     4      2      1      8      3      1\n#    3 │     7      3      1     14      4      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  498 │  1492     98    100   2984    198  10000\n#  499 │  1495     99    100   2990    199  10000\n#  500 │  1498    100    100   2996    200  10000\n#                                 494 rows omitted\nselect(df, Cols(:A, Between(:X, :Z)))\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\nHere we used Cols to combine selecting column A and all columns from X to Z. This also changed the order of the columns.\nWe used the select function to do the selections, but could as easily have used the normal array-type notation:\ndf[:, Cols(:A, Between(:X, :Z))]\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\nTo permanently change the DataFrame, either assign the returned result to the same variable, or use the mutating version of select(): select!().\ndf = select(df, Cols(:A, Between(:X, :Z)))\ndf\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\nor\nselect!(df, Cols(:A, Between(:X, :Z)))\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1 Da\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\nIt is also possible to select columns from a DataFrame that match to a regular expression. This is a template that describes a string of text. For more information, see one the many tutorials on the web.\ndf = DataFrame(\n    Names = [\"Tom\", \"Dick\", \"Harry\"], \n    AddressLine1 = [\"2 Maple Drive\", \"4 Oak Street\", \"6 Pine Road\"],\n    AddressLine2 = [\"Hopetown\", \"Smallville\", \"Metropolis\"],\n    AddressZip = [1234, 2345, 3456]\n)\n3×4 DataFrame\n#  Row │ Names   AddressLine1   AddressLine2  AddressZip \n#      │ String  String         String        Int64      \n# ─────┼─────────────────────────────────────────────────\n#    1 │ Tom     2 Maple Drive  Hopetown            1234\n#    2 │ Dick    4 Oak Street   Smallville          2345\n#    3 │ Harry   6 Pine Road    Metropolis          3456\n\n\ndf[:, r\"Addr\"]\n# 3×3 DataFrame\n#  Row │ AddressLine1   AddressLine2  AddressZip \n#      │ String         String        Int64      \n# ─────┼─────────────────────────────────────────\n#    1 │ 2 Maple Drive  Hopetown            1234\n#    2 │ 4 Oak Street   Smallville          2345\n#    3 │ 6 Pine Road    Metropolis          34\nHere we select all rows, but only the column that have the sub-string “Addr” in their names.\n\n\n\nYou can select rows by filtering the data. There are two equivalent ways:\nfilter(:X =&gt; &lt;=(10), df)\n# 4×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │     4      2      1      8      3      1\n#    3 │     7      3      1     14      4      1\n#    4 │    10      4      1     20      5      1\n\ndf[df.X .&lt;= 10, :]\n# 4×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │     4      2      1      8      3      1\n#    3 │     7      3      1     14      4      1\n#    4 │    10      4      1     20      5      1\nIn both cases we pass a predicate function, i.e. a function that returns true for rows that should be included. In the first case, a pair operator links a column name to the predicate function and in the second case we simply pass an expression that returns true for all the correct instances. Note the use of broadcasting in the second example.\n\n\n\n\n\n\nNote\n\n\n\nThe contents of the column being checked in the predicate function is passed as the first parameter, so :X =&gt; &lt;=(10) is in fact df[&lt;current row&gt;, X] &lt;= 10, which can also be written as &lt;=(df[&lt;current row&gt;, X], 10), since operators in Julia are just functions with special syntax - they can still be called like normal functions.\n\n\nYou can use any predicate function. A new useful ones include:\ndf[findfirst(==(4), df.C), :] # Find the first row where column C has a value of 4\n# DataFrameRow\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    6 │    16      6      2     32      8      4\n\ndf[findall(==(4), df.C), :] # Find all rows where column C has a value of 4\n# 5×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │    16      6      2     32      8      4\n#    2 │    19      7      2     38      9      4\n#    3 │    22      8      2     44     10      4\n#    4 │    25      9      2     50     11      4\n#    5 │    28     10      2     56     12      4\n\ndf[df.C .== 4, :] # Find all rows where column C has a value of 4, alternative form\n# 5×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │    16      6      2     32      8      4\n#    2 │    19      7      2     38      9      4\n#    3 │    22      8      2     44     10      4\n#    4 │    25      9      2     50     11      4\n#    5 │    28     10      2     56     12      4\nIt may also be useful to sort the data according to specified columns:\nsort(df, :Y)\n# 500×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │   301      1     21    602     22    441\n#    3 │   601      1     41   1202     42   1681\n#    4 │   901      1     61   1802     62   3721\n#    5 │  1201      1     81   2402     82   6561\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  497 │   598    100     40   1196    140   1600\n#  498 │   898    100     60   1796    160   3600\n#  499 │  1198    100     80   2396    180   6400\n#  500 │  1498    100    100   2996    200  10000\n#                                 491 rows omitted\n\nsort(df, [:Y, :B])\n# 500×6 DataFrame\n#  Row │ X      Y      Z      A      B      C\n#      │ Int64  Int64  Int64  Int64  Int64  Int64\n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │   301      1     21    602     22    441\n#    3 │   601      1     41   1202     42   1681\n#    4 │   901      1     61   1802     62   3721\n#    5 │  1201      1     81   2402     82   6561\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  497 │   598    100     40   1196    140   1600\n#  498 │   898    100     60   1796    160   3600\n#  499 │  1198    100     80   2396    180   6400\n#  500 │  1498    100    100   2996    200  10000\n#                                 491 rows omitted\n\n\n\nApplying a function to a column or multiple columns has been shown before when we added columns to a DataFrame. Since each column acts like a vector, we simply use normal Julia broadcasting to apply functions to whole columns:\ndf.BdivC = df.B ./ df.C\n# 500-element Vector{Float64}:\n#  2.0\n#  3.0\n#  4.0\n#  5.0\n#  6.0\n#  2.0\n#  2.25\n#  ⋮\n#  0.01979389858177737\n#  0.0196\n#  0.0197\n#  0.0198\n#  0.0199\n#  0.02\n\n# df\n# 500×7 DataFrame\n#  Row │ X      Y      Z      A      B      C      BdivC     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64  Float64   \n# ─────┼─────────────────────────────────────────────────────\n#    1 │     1      1      1      2      2      1  2.0\n#    2 │     4      2      1      8      3      1  3.0\n#    3 │     7      3      1     14      4      1  4.0\n#    4 │    10      4      1     20      5      1  5.0\n#    5 │    13      5      1     26      6      1  6.0\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮        ⋮\n#  497 │  1489     97    100   2978    197  10000  0.0197\n#  498 │  1492     98    100   2984    198  10000  0.0198\n#  499 │  1495     99    100   2990    199  10000  0.0199\n#  500 │  1498    100    100   2996    200  10000  0.02\n#                                            491 rows omitted\nIn order to apply functions across rows, we need to use some of the built-in functions of DataFrames, select and transform, along with ByRow.\nThe basic syntax is:\n\nselect(df, &lt;array of columns to select&gt;)\nselect(df, &lt;array of columns to select&gt;, &lt;array of columns to pass to function&gt; =&gt; &lt;function&gt; =&gt; &lt;name(s) of column(s) to hold result(s)&gt;)\nselect(df, AsTable(:) =&gt; &lt;function&gt; =&gt; &lt;name(s) of column(s) to hold result&gt;) # pass the entire table to the function\n\nSome examples:\n\nselect(df, :X, :X =&gt; cumsum =&gt; :cumX) # Put the cumulative sum of X in column cumX\n# 500×2 DataFrame\n#  Row │ X      cumX   \n#      │ Int64  Int64  \n# ─────┼───────────────\n#    1 │     1       1\n#    2 │     4       5\n#    3 │     7      12\n#    4 │    10      22\n#    5 │    13      35\n#   ⋮  │   ⋮      ⋮\n#  497 │  1489  370265\n#  498 │  1492  371757\n#  499 │  1495  373252\n#  500 │  1498  374750\n#      491 rows omitted\n\nselect(df, [:X, :Y], [:X, :Y] =&gt; ByRow((x, y) -&gt; sin(x)*cos(y)) =&gt; :sinXcosY) # Put the value of sin(X)*cos*(Y) in column sinXcosY\n# 500×3 DataFrame\n#  Row │ X      Y      sinXcosY    \n#      │ Int64  Int64  Float64     \n# ─────┼───────────────────────────\n#    1 │     1      1   0.454649\n#    2 │     4      2   0.314941\n#    3 │     7      3  -0.650412\n#    4 │    10      4   0.355596\n#    5 │    13      5   0.119185\n#   ⋮  │   ⋮      ⋮         ⋮\n#  497 │  1489     97   0.106082\n#  498 │  1492     98  -0.207859\n#  499 │  1495     99  -0.0154374\n#  500 │  1498    100   0.443124\n#                  491 rows omitted\n\nselect(df, AsTable(:) =&gt; ByRow(extrema) =&gt; [:min, :max]) # Find the smallest and largest value in each row\n# 500×2 DataFrame\n#  Row │ min    max   \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      2\n#    2 │     1      8\n#    3 │     1     14\n#    4 │     1     20\n#    5 │     1     26\n#   ⋮  │   ⋮      ⋮\n#  497 │    97  10000\n#  498 │    98  10000\n#  499 │    99  10000\n#  500 │   100  10000\n#     491 rows omitted\nIn each case, we used select and it only returned the specified columns. In the last example, we didn’t select any column, but just specified the function to apply. As a result, only the columns holding the results of the function are selected. If we instead call transform, the entire DataFrame is returned, as well as any new columns added in the calculations, e.g.\ntransform(df, AsTable(:) =&gt; ByRow(extrema) =&gt; [:min, :max])\n# 500×8 DataFrame\n#  Row │ X      Y      Z      A      B      C      min    max   \n#      │ Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────────────────────────────────\n#    1 │     1      1      1      2      2      1      1      2\n#    2 │     4      2      1      8      3      1      1      8\n#    3 │     7      3      1     14      4      1      1     14\n#    4 │    10      4      1     20      5      1      1     20\n#    5 │    13      5      1     26      6      1      1     26\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  497 │  1489     97    100   2978    197  10000     97  10000\n#  498 │  1492     98    100   2984    198  10000     98  10000\n#  499 │  1495     99    100   2990    199  10000     99  10000\n#  500 │  1498    100    100   2996    200  10000    100  10000\n#                                               491 rows omitted\nJust like before, select and transform return new DataFrames, while select! and transform! will modify the existing DataFrame.\n\n\n\n\n\nDataFrames will group your data by column values through the groupby() function. One or more columns can be specified and you will get a GroupedDataFrame - a container of SubDataFrames for each unique combination of the values in the specified columns.\ndf = DataFrame(X = 1:50, Y = repeat(1:2, outer=25), Z = repeat(2:2:10, inner=10))\n# 50×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      2 \n#    2 │     2      2      2\n#    3 │     3      1      2\n#    4 │     4      2      2\n#    5 │     5      1      2\n#    6 │     6      2      2\n#   ⋮  │   ⋮      ⋮      ⋮\n#   45 │    45      1     10\n#   46 │    46      2     10\n#   47 │    47      1     10\n#   48 │    48      2     10\n#   49 │    49      1     10\n#   50 │    50      2     10\n#             38 rows omitted\n\ngdf = groupby(df, [:Y, :Z]\n# GroupedDataFrame with 10 groups based on keys: Y, Z\n# First Group (5 rows): Y = 1, Z = 2\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      2\n#   ⋮  │   ⋮      ⋮      ⋮\n#    5 │     9      1      2\n#              3 rows omitted\n# ⋮\n# Last Group (5 rows): Y = 2, Z = 10\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │    42      2     10\n#   ⋮  │   ⋮      ⋮      ⋮\n#    5 │    50      2     10\n#              3 rows omitted\n\ncounts = combine(gdf, nrow, :X =&gt; mean)\n#     10×4 DataFrame\n#  Row │ Y      Z      nrow   X_mean\n#      │ Int64  Int64  Int64  Float64\n# ─────┼──────────────────────────────\n#    1 │     1      2      5      5.0\n#    2 │     1      4      5     15.0\n#    3 │     1      6      5     25.0\n#    4 │     1      8      5     35.0\n#    5 │     1     10      5     45.0\n#    6 │     2      2      5      6.0\n#    7 │     2      4      5     16.0\n#    8 │     2      6      5     26.0\n#    9 │     2      8      5     36.0\n#   10 │     2     10      5     46.0\n\ncounts = select(gdf, nrow, :X =&gt; mean) \n# 50×4 DataFrame\n#  Row │ Y      Z      nrow   X_mean  \n#      │ Int64  Int64  Int64  Float64 \n# ─────┼──────────────────────────────\n#    1 │     1      2      5      5.0\n#    2 │     2      2      5      6.0\n#    3 │     1      2      5      5.0\n#    4 │     2      2      5      6.0\n#    5 │     1      2      5      5.0\n#    6 │     2      2      5      6.0\n#   ⋮  │   ⋮      ⋮      ⋮       ⋮\n#   45 │     1     10      5     45.0\n#   46 │     2     10      5     46.0\n#   47 │     1     10      5     45.0\n#   48 │     2     10      5     46.0\n#   49 │     1     10      5     45.0\n#   50 │     2     10      5     46.0\n#                      38 rows omitted\nHere we create a DataFrame with three columns: X ranges from 1 to 50, Y alternates between 1 and 2, and Z is a sequence of the even numbers from 2 to 10. We then group by Y and Z, which gives us a GroupedDataFrame with 10 groups, for the 10 unique combinations of values in Y and Z. The second command created a new DataFrame, called counts which contains the number of rows in each of the 10 SubDataFrames in our GroupedDataFrame (gdf) as well as the mean2 value of the X column in each of the 10 groups. Lastly, we repeat the second example, but with select instead of combine. This returns a DataFrame with the same number (and order) of rows as in the original source DataFrame (not the grouped one!), but with only the newly created column. In this case, we see 50 rows, not the expected 10.\n\n\nFor this example, we use a dataset from Kaggle3. The data file includes information on the ingredients of 399 types of food.\ndf = CSV.read(raw\"D:\\JuliaCode\\KaggleData\\food_ingredients_and_allergens.csv\", DataFrame; normalizenames=true)\nselect!(df, [:Food_Product, :Allergens])\n# 399×2 DataFrame\n#  Row │ Food_Product             Allergens\n#      │ String                   String31\n# ─────┼─────────────────────────────────────────────────\n#    1 │ Almond Cookies           Almonds, Wheat, Dairy\n#    2 │ Almond Cookies           Almonds, Wheat, Dairy\n#    3 │ Chicken Noodle Soup      Chicken, Wheat, Celery\n#    4 │ Chicken Noodle Soup      Chicken, Wheat, Celery\n#    5 │ Cheddar Cheese           Dairy\n#    6 │ Ranch Dressing           Dairy\n#    7 │ Caramel Popcorn          Dairy\n#    8 │ Caesar Salad             Dairy\n#   ⋮  │            ⋮                       ⋮\n#  393 │ Chocolate Chip Pancakes  Wheat, Dairy, Cocoa\n#  394 │ Lemon Bars               Wheat, Dairy, Eggs\n#  395 │ Lemon Bars               Wheat, Dairy, Eggs\n#  396 │ Pecan Pie                Wheat, Dairy, Nuts\n#  397 │ Zucchini Bread           Wheat, Dairy, Nuts\n#  398 │ Banana Bread             Wheat, Dairy, Nuts\n#  399 │ Hawaiian Pizza           Wheat, Pork, Dairy\n#                                        384 rows omitted\nWe are going to focus on the allergens in these foods. We select to keep only the two column containing the names of the foods and the allergens contained in them. Unfortunately, the allergens are given as a single string of comma-separated values. This means we have to do a little processing of the data.\nWe ideally want a separate column for each allergen that contains a true (1) or false (0) to indicate if the allergen is present or not. To get this, we must process all the entries on allergens and split the strings into the individual allergens. We then need to identify the unique values, and add a true or false in a new column for each food and each allergen. This sounds like a lot of work, but Julia makes this easy.\nallAllergens = String[] #empty array of strings\nfor row in eachrow(df)\n    allergens = row.Allergens\n    for s in eachsplit(allergens, \", \")\n        push!(allAllergens, s)\n    end\nend\nunique!(allAllergens)\n\n# 24-element Vector{String}:\n#  \"Almonds\"\n#  \"Wheat\"\n#  \"Dairy\"\n#  \"Chicken\"\n#  \"Celery\"\n#  \"Anchovies\"\n#  \"Cocoa\"\n#  ⋮\n#  \"Oats\"\n#  \"Peanuts\"\n#  \"Pine nuts\"\n#  \"Rice\"\n#  \"Shellfish\"\n#  \"Pork\"\n#  \"Alcohol\"\nWe create an empty vector of Strings to hold the allergen names - allAllergens. Then we iterate trough the DataFrame, one row at a time, using the eachrow iterator. We extract the string holding the allergens into a temporary string allergens with allergens = row.Allergens (where row is the current row in the iterator eachrow).\nTo split the string (allergens) into the various allergens, we use the Julia function eachsplit, which splits the string with the specified delimiter (“,”), and returns an iterator of substrings. We loop through this iterator and push each substring into the empty vector we created at the start.\nLastly, we use the Julia function unique! to remove all duplicates from this vector. We now have a list of 24 possible allergens.\nfor allergen in allAllergens\n    transform!(df, :Allergens =&gt; ByRow(s -&gt; contains(string(s), allergen)) =&gt; Symbol(allergen))\nend\n\ndf[:, [:Food_Product, :Almonds, :Wheat, :Dairy]]\n# 399×4 DataFrame\n#  Row │ Food_Product             Almonds  Wheat  Dairy \n#      │ String                   Bool     Bool   Bool  \n# ─────┼────────────────────────────────────────────────\n#    1 │ Almond Cookies              true   true   true\n#    2 │ Almond Cookies              true   true   true\n#    3 │ Chicken Noodle Soup        false   true  false\n#    4 │ Chicken Noodle Soup        false   true  false\n#    5 │ Cheddar Cheese             false  false   true\n#    6 │ Ranch Dressing             false  false   true\n#   ⋮  │            ⋮                ⋮       ⋮      ⋮\n#  394 │ Lemon Bars                 false   true   true\n#  395 │ Lemon Bars                 false   true   true\n#  396 │ Pecan Pie                  false   true   true\n#  397 │ Zucchini Bread             false   true   true\n#  398 │ Banana Bread               false   true   true\n#  399 │ Hawaiian Pizza             false   true   true\n#                                       387 rows omitted\nWe now run through our newly created list of allergens and call the DataFrames function transform! for each allergen. transform! is the mutating version of transform and will modify the specified DataFrame rather than return a new object. transform includes all of the columns in the original DataFrame, unlike select, which will include only the specified columns.\nWe specify here than we want to take the contents of the Allergens column, and pass it, one row at a time (ByRow()) to an anonymous function (s -&gt; contains(string(s), allergen))) and store the result in a new column Symbol(allergen). Note that we are converting the name of the allergen, which is a String to a Symbol, which is what DataFrames expects here.\nThe anonymous function we define essentially only calls the Julia function contains, which will return a true or false depending on whether the string contains a specified substring. We convert the value from the DataFrame to a string (with the string() function), as DataFrames uses a more specialised data type for string values to save memory and improve performance. We have a quick look at three of the allergens and see that we indeed have exactly what we wanted.\nWe can now analyse the data any way we want to. Let’s group the data to see combinations of almonds and wheat in the various foods:\ngdf = groupby(df, [:Almonds, :Wheat])\n\nfor (keys, sdf) in pairs(gdf)\n    println(\"Number of foods with $keys: $(nrow(sdf))\")\nend\n\n# Number of foods with GroupKey: (Almonds = true, Wheat = true): 2\n# Number of foods with GroupKey: (Almonds = false, Wheat = true): 94\n# Number of foods with GroupKey: (Almonds = false, Wheat = false): 303\n\n\n\n\nDataFrames allows for joining of tables, just like in a SQL database. We shall give a few key definitions here to illustrate the concept.\nFirstly, what is a join? It is a combination of two tables, based on the values in a specified column, typically an ID or similar index value. The resulting table may include columns from one or both of the tables, for the rows that are included in the joined table, depending on the type of join.\nWe define two DataFrames to use in our examples:\ndf1 = DataFrame(ID = [1, 2, 3], Floor = [\"A\", \"B\", \"C\"], Office = [11, 12, 12])\n# 3×3 DataFrame\n#  Row │ ID     Floor   Office \n#      │ Int64  String  Int64  \n# ─────┼───────────────────────\n#    1 │     1  A           11\n#    2 │     2  B           12\n#    3 │     3  C           12\n\ndf2 = DataFrame(ID = [1, 2, 7, 11], Name = [\"Tom\", \"Dan\", \"Harry\", \"Bob\"])\n# 4×2 DataFrame\n#  Row │ ID     Name   \n#      │ Int64  String \n# ─────┼───────────────\n#    1 │     1  Tom\n#    2 │     2  Dan\n#    3 │     7  Harry\n#    4 │    11  Bob\nInner join: An inner join between two tables will include only the rows where the field (e.g. ID) on which you join, are the same in each table. Rows that include a value of ID that is only present in one of the two tables will not be included. All columns from both tables are included.\ninnerjoin(df1, df2, on=:ID)\n# 2×4 DataFrame\n#  Row │ ID     Floor   Office  Name   \n#      │ Int64  String  Int64   String \n# ─────┼───────────────────────────────\n#    1 │     1  A           11  Tom\n#    2 │     2  B           12  Dan\nLeft join: A left join between two tables will include all the rows from the left table, as well as those rows from right table where the joining field (e.g. ID) match. All columns are included, which may result in missing values in columns from the right table.\nleftjoin(df1, df2, on=:ID)\n# 3×4 DataFrame\n#  Row │ ID     Floor   Office  Name    \n#      │ Int64  String  Int64   String? \n# ─────┼────────────────────────────────\n#    1 │     1  A           11  Tom\n#    2 │     2  B           12  Dan\n#    3 │     3  C           12  missing \nRight join: Similar to a left join, but all rows from the right table are included and only matching rows from the left table. This may result in missing values in columns from the left table.\nrightjoin(df1, df2, on=:ID)\n# 4×4 DataFrame\n#  Row │ ID     Floor    Office   Name   \n#      │ Int64  String?  Int64?   String \n# ─────┼─────────────────────────────────\n#    1 │     1  A             11  Tom\n#    2 │     2  B             12  Dan\n#    3 │     7  missing  missing  Harry\n#    4 │    11  missing  missing  Bob\nOuter join: This will include all rows from both left and right tables, possibly resulting in missing values in all columns.\n# outerjoin(df1, df2, on=:ID)\n# 5×4 DataFrame\n#  Row │ ID     Floor    Office   Name    \n#      │ Int64  String?  Int64?   String? \n# ─────┼──────────────────────────────────\n#    1 │     1  A             11  Tom\n#    2 │     2  B             12  Dan\n#    3 │     3  C             12  missing \n#    4 │     7  missing  missing  Harry\n#    5 │    11  missing  missing  Bob\nSemi join (a.k.a. Left semi join): Like an inner join, this will only return rows that match in both columns, but will only return columns from the left table. This is useful if you want to select, for example, names from a list that are also present in another list, without including additional data from that list. To do a right semi join, just reverse the order to the two DataFrames.\nsemijoin(df1, df2, on=:ID)\n# 2×3 DataFrame\n#  Row │ ID     Floor   Office \n#      │ Int64  String  Int64  \n# ─────┼───────────────────────\n#    1 │     1  A           11\n#    2 │     2  B           12\nAnti join (a.k.a. Left anti join): Like the semi join, but will only return rows from the left table that are NOT matched in the right table.\nantijoin(df1, df2, on=:ID)\n# 1×3 DataFrame\n#  Row │ ID     Floor   Office \n#      │ Int64  String  Int64  \n# ─────┼───────────────────────\n#    1 │     3  C           12"
  },
  {
    "objectID": "13_DataFrames.html#what-is-a-dataframe",
    "href": "13_DataFrames.html#what-is-a-dataframe",
    "title": "DataFrames",
    "section": "",
    "text": "In short, a DataFrame is a table of data, where each column has a title and a type. Operations can be performed on a per column or per row basis, and columns and rows can be added or removed easily. The DataFrames package in Julia is the de facto standard for working with tabular data and is integrated in many other packages. In the previous section we have seen that you can read a data file directly into a DataFrame via the CSV package, but this is only one example of other packages integrating with DataFrames.\nThe DataFrames package provides a lot of functionality for manipulating the data contain in a DataFrame. There are also additional packages that provide either more options, or alternative (simpler) syntax for convenience, such as DataFramesMeta and Tidier.\nWe shall look at the basic use of DataFrames and leave these auxiliary packages and some more advanced functionality of DataFrames for self-study.\n\n\nUsually, you would create a DataFrame by reading in data from a file. You can however also create a DataFrame from variables directly:\ndf = DataFrame(X = [1, 2, 3], Y = [2, 3, 4], Z = 2.0)\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Float64\n# ─────┼───────────────────────\n#    1 │     1      2      2.0\n#    2 │     2      3      2.0\n#    3 │     3      4      2.0\nNote that columns X and Y are specified as arrays of integers, and so the columns are typed as Int64. Z is specified as a floating point value and hence the column is types as Float64. The length of Z is also expanded to be the same as the other columns, with a fixed value. The column names, X, Y and Z, are all legal Julia symbols (variable names) and so we can use the assignment operator (=) here.\nYou can also give columns longer names, with spaces, but then instead you need to either use the pair operator, =&gt;, or define a Dict and then convert that to a DataFrame:\ndf = DataFrame(\"X values\" =&gt; [1, 2, 3], \"Y values\" =&gt; [2, 3, 4], \"Z\" =&gt; 2.0)\n# 3×3 DataFrame\n#  Row │ X values  Y values  Z\n#      │ Int64     Int64     Float64\n# ─────┼─────────────────────────────\n#    1 │        1         2      2.0\n#    2 │        2         3      2.0\n#    3 │        3         4      2.0\n\nd = Dict(\"X values\" =&gt; [1, 2, 3], \"Y values\" =&gt; [2, 3, 4], \"Z\" =&gt; 2.0)\n# Dict{String, Any} with 3 entries:\n#   \"Z\"        =&gt; 2.0\n#   \"X values\" =&gt; [1, 2, 3]\n#   \"Y values\" =&gt; [2, 3, 4]\n\ndf = DataFrame(d)\n# 3×3 DataFrame\n#  Row │ X values  Y values  Z\n#      │ Int64     Int64     Float64\n# ─────┼─────────────────────────────\n#    1 │        1         2      2.0\n#    2 │        2         3      2.0\n#    3 │        3         4      2.0\n\n\n\n\n\n\nCaution\n\n\n\nDon’t use strings for column names just because you can. Using a symbol, like :X_values, instead of the string “X values” will give faster results and is just as readable. This does mean you need to use underscores instead of spaces, but all-in-all that is not too high a price to pay.\n\n\nA DataFrame can also be constructed one column at a time:\ndf = DataFrame()\n# 0×0 DataFrame\n\ndf.A = 1:3\n# 1:3\n\ndf.B = 2:2:6\n# 2:2:6\n\ndf\n# 3×2 DataFrame\n#  Row │ A      B\n#      │ Int64  Int64\n# ─────┼──────────────\n#    1 │     1      2\n#    2 │     2      4\n#    3 │     3      6\nOr row by row:\ndf = DataFrame(A=String[], B=Int64[])\n# 0×2 DataFrame\n#  Row │ A       B\n#      │ String  Int64\n# ─────┴───────────────\n\npush!(df, (\"Bob\", 1))\n# 1×2 DataFrame\n#  Row │ A       B\n#      │ String  Int64\n# ─────┼───────────────\n#    1 │ Bob         1\n\npush!(df, (\"Tom\", 5))\n# 2×2 DataFrame\n#  Row │ A       B\n#      │ String  Int64\n# ─────┼───────────────\n#    1 │ Bob         1\n#    2 │ Tom         5\nNote how we forced types of the columns in the creation of the empty DataFrame. This is needed to give the columns names, and tell the empty DataFrame how many columns it will hold. You could specify the types as Any, but that would not lead to good performance.\nLastly, you can also convert a matrix to a DataFrame. This requires you to either allow DataFrames to automatically generate column names, or to pass a vector of names:\nm = rand(5, 5)\n# 5×5 Matrix{Float64}:\n#  0.460589   0.734461   0.771352   0.292767   0.0078547\n#  0.254958   0.153814   0.571355   0.196476   0.739701\n#  0.0799407  0.457583   0.553493   0.25409    0.245967\n#  0.106429   0.435509   0.0184347  0.932008   0.805972\n#  0.0877892  0.0231817  0.435262   0.0187286  0.812151\n\ndf = DataFrame(m, :auto) # Automatically generate names\n# 5×5 DataFrame\n#  Row │ x1         x2         x3         x4         x5\n#      │ Float64    Float64    Float64    Float64    Float64\n# ─────┼───────────────────────────────────────────────────────\n#    1 │ 0.460589   0.734461   0.771352   0.292767   0.0078547\n#    2 │ 0.254958   0.153814   0.571355   0.196476   0.739701\n#    3 │ 0.0799407  0.457583   0.553493   0.25409    0.245967\n#    4 │ 0.106429   0.435509   0.0184347  0.932008   0.805972\n#    5 │ 0.0877892  0.0231817  0.435262   0.0187286  0.812151\n\ndf = DataFrame(m, [:X, :Y, :Z, :W, :Q]) # Specify names\n# 5×5 DataFrame\n#  Row │ X          Y          Z          W          Q\n#      │ Float64    Float64    Float64    Float64    Float64\n# ─────┼───────────────────────────────────────────────────────\n#    1 │ 0.460589   0.734461   0.771352   0.292767   0.0078547\n#    2 │ 0.254958   0.153814   0.571355   0.196476   0.739701\n#    3 │ 0.0799407  0.457583   0.553493   0.25409    0.245967\n#    4 │ 0.106429   0.435509   0.0184347  0.932008   0.805972\n#    5 │ 0.0877892  0.0231817  0.435262   0.0187286  0.812151\n\n\n\nOnce the data is in a DataFrame, you can access column like they are individual vectors1:\ndf.X\n# 5-element Vector{Float64}:\n#  0.460589206535297\n#  0.25495814887990786\n#  0.07994066869519556\n#  0.10642869978604408\n#  0.0877892134158087\nYou can also add columns, even via calculations:\ndf.New = (df.X).^2 .- df.Y\n# 5-element Vector{Float64}:\n#  -0.5223183397440386\n#  -0.08881079559662731\n#  -0.45119243718262425\n#  -0.42418203290738643\n#  -0.015474773743873368\n\ndf\n# 5×6 DataFrame\n#  Row │ X          Y          Z          W          Q          New\n#      │ Float64    Float64    Float64    Float64    Float64    Float64\n# ─────┼───────────────────────────────────────────────────────────────────\n#    1 │ 0.460589   0.734461   0.771352   0.292767   0.0078547  -0.522318\n#    2 │ 0.254958   0.153814   0.571355   0.196476   0.739701   -0.0888108\n#    3 │ 0.0799407  0.457583   0.553493   0.25409    0.245967   -0.451192\n#    4 │ 0.106429   0.435509   0.0184347  0.932008   0.805972   -0.424182\n#    5 │ 0.0877892  0.0231817  0.435262   0.0187286  0.812151   -0.0154748\nNote the use of broadcasting in the first command - using .^ instead of ^ and .- instead of -. This tells Julia to execute these operations in element-wise fashion. The new column, df.New, is added to the DataFrame automatically.\nYou can also access individual entries by specifying the row and column, the latter using either the names or indexes:\ndf[2, 3] # Row 2, Column 3 (Z)\n# 0.5713552793835407\n\ndf[2:3, 3:5]\n# 2×3 DataFrame\n#  Row │ Z         W         Q\n#      │ Float64   Float64   Float64\n# ─────┼──────────────────────────────\n#    1 │ 0.571355  0.196476  0.739701\n#    2 │ 0.553493  0.25409   0.245967\n\ndf[1:3, :W]\n# 3-element Vector{Float64}:\n#  0.29276715395306163\n#  0.19647571959450094\n#  0.25409034700483624\nTo select an entire row or column, the : operator is used, just like in Arrays. This returns a copy of the slice of the DataFrame. When using a !, however, a view to the data is returned. Modifying the view will modify the contents of the DataFrame as well:\ndf = DataFrame(X = [1, 2, 3], Y = [2, 4, 6], Z = [3, 6, 9])\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Int64\n# ─────┼─────────────────────\n#    1 │     1      2      3\n#    2 │     2      4      6\n#    3 │     3      6      9\n\nxvals = df[:, :X]\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nxvals[1] = 100\n# 100\n\ndf\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Int64\n# ─────┼─────────────────────\n#    1 │     1      2      3\n#    2 │     2      4      6\n#    3 │     3      6      9\n\nxview = df[!, :X]\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nxview[1] = 100\n# 100\n\ndf\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Int64\n# ─────┼─────────────────────\n#    1 │   100      2      3\n#    2 │     2      4      6\n#    3 │     3      6      9\nYou can also select just specific rows and columns:\ndf[[1, 3], [1, 3]]\n# 2×2 DataFrame\n#  Row │ X      Z     \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      3\n#    2 │     3      9\n\n\n\nData wrangling is the pre-processing of your data to get it into the form you need for the modelling or analysis you intend to do with it. This can include many steps. DataFrames has a rich feature set to support you in this. We’ll look at several examples here, but if you are going to be doing this type of work often, save yourself a lot of page-turning and download, print and laminate a copy of the Data Wrangling with DataFrames.jl Cheat Sheet.\nWe start off by creating a dataset to work with:\ndf = DataFrame(X = 1:3:1500, Y = repeat(1:100, outer=5), Z = repeat(1:100, inner=5)\n# 500×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      1 \n#    2 │     4      2      1 \n#    3 │     7      3      1 \n#    4 │    10      4      1 \n#    5 │    13      5      1 \n#    6 │    16      6      2 \n#    7 │    19      7      2 \n#    8 │    22      8      2 \n#    9 │    25      9      2 \n#   ⋮  │   ⋮      ⋮      ⋮   \n#  492 │  1474     92     99 \n#  493 │  1477     93     99\n#  494 │  1480     94     99\n#  495 │  1483     95     99\n#  496 │  1486     96    100\n#  497 │  1489     97    100\n#  498 │  1492     98    100\n#  499 │  1495     99    100\n#  500 │  1498    100    100\n#            482 rows omitted\n\nfirst(df,3)\n# 3×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      1\n#    2 │     4      2      1\n#    3 │     7      3      1\n\nlast(df,4)\n# 4×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │  1489     97    100\n#    2 │  1492     98    100\n#    3 │  1495     99    100\n#    4 │  1498    100    100\n\nnames(df)\n# 3-element Vector{String}:\n#  \"X\"\n#  \"Y\"\n#  \"Z\"\n\ndescribe(df)\n# 3×7 DataFrame\n#  Row │ variable  mean     min    median   max    nmissing  eltype   \n#      │ Symbol    Float64  Int64  Float64  Int64  Int64     DataType \n# ─────┼──────────────────────────────────────────────────────────────\n#    1 │ X           749.5      1    749.5   1498         0  Int64\n#    2 │ Y            50.5      1     50.5    100         0  Int64\n#    3 │ Z            50.5      1     50.5    100         0  Int64\nIn generating this data, we used Julia’s repeat function. For the Y column, we specify outer=5, which means the data (1:100) is repeated 5 times as a set, i.e. 1 to 100, then 1 to 100 again, for a total of 5 times. For the Z column, we specify inner=5, which means each of the values from 1 to 100 is repeated 5 times: 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,… etc.\nWe can quickly see the first or last few rows using the Julia functions first and last, with the second parameter showing how many entries to display. The number of rows displayed by Julia for the full DataFrame depends on the size of the window it is being displayed in. The middle omitted rows are indicated with the ⋮ characters. If the DataFrame is too wide, columns will also be omitted, with a message indicating how many columns are hidden.\nIf you really want to see all the rows or columns, you can call show and specify allrows=true and/or allcols=true\nshow(df, allrows=true, allcols=true)\nFor obvious reasons, we won’t include the 500 rows of data here.\nThe names() function returns a vector of the column names as strings. You can also get summary statistics of the data with the describe() function.\nIf you only want specific statistics, you can specify them in the call:\ndescribe(df, :mean, :std)\n# 3×3 DataFrame\n#  Row │ variable  mean     std     \n#      │ Symbol    Float64  Float64 \n# ─────┼────────────────────────────\n#    1 │ X           749.5  433.445\n#    2 │ Y            50.5   28.895\n#    3 │ Z            50.5   28.895\nYou can also apply a custom function to describe the data. Here we use the Julia function extrema(), which returns the minimum and maximum value in an array. We’ll specify that we want the results in a column call minmax:\ndescribe(df, extrema =&gt; :minmax)\n# 3×2 DataFrame\n#  Row │ variable  minmax    \n#      │ Symbol    Tuple…    \n# ─────┼─────────────────────\n#    1 │ X         (1, 1498)\n#    2 │ Y         (1, 100)\n#    3 │ Z         (1, 100)\nLastly, the number of rows and column can be easily retrieved:\nnrow(df)\n# 500\n\nncol(df)\n# 6\n\n\n\n\nIn the introductory section, we selected specific rows and columns based on their indices. You can also select columns based on their names:\nselect(df, [:X, :Z])\n# 500×2 DataFrame     \n#  Row │ X      Z     \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      1\n#    2 │     4      1\n#    3 │     7      1\n#   ⋮  │   ⋮      ⋮\n#  498 │  1492    100\n#  499 │  1495    100\n#  500 │  1498    100\n#     494 rows omitted\nThere are also selector function to allow for selection of ranges of columns:\n\nNot(): Select all the columns expect the specified one(s)\nBetween(): Select all column starting with the first specified column and ending with the second. You can use names or indices to specify the columns\nCols(): Use this to combine other selector functions\nAll(): Select all columns - same as specifying :\n\nExamples:\nIn the previous example we selected columns X and Z, which is the same as selecting everything expect Y:\nselect(df, Not(:Y))\n# 500×2 DataFrame\n#  Row │ X      Z     \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      1\n#    2 │     4      1\n#    3 │     7      1\n#   ⋮  │   ⋮      ⋮\n#  498 │  1492    100\n#  499 │  1495    100\n#  500 │  1498    100\n#     494 rows omitted\nWe only passed a single symbol to Not, but could also pass an array of symbols to exclude multiple columns.\nTo make things more interesting, we can first add a few more columns:\ndf.A = 2 .* df.X\ndf.B = df.Y .+ df.Z\ndf.C = df.Z .^ 2\ndf\n# 500×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │     4      2      1      8      3      1\n#    3 │     7      3      1     14      4      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  498 │  1492     98    100   2984    198  10000\n#  499 │  1495     99    100   2990    199  10000\n#  500 │  1498    100    100   2996    200  10000\n#                                 494 rows omitted\nselect(df, Cols(:A, Between(:X, :Z)))\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\nHere we used Cols to combine selecting column A and all columns from X to Z. This also changed the order of the columns.\nWe used the select function to do the selections, but could as easily have used the normal array-type notation:\ndf[:, Cols(:A, Between(:X, :Z))]\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\nTo permanently change the DataFrame, either assign the returned result to the same variable, or use the mutating version of select(): select!().\ndf = select(df, Cols(:A, Between(:X, :Z)))\ndf\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\nor\nselect!(df, Cols(:A, Between(:X, :Z)))\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1 Da\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\nIt is also possible to select columns from a DataFrame that match to a regular expression. This is a template that describes a string of text. For more information, see one the many tutorials on the web.\ndf = DataFrame(\n    Names = [\"Tom\", \"Dick\", \"Harry\"], \n    AddressLine1 = [\"2 Maple Drive\", \"4 Oak Street\", \"6 Pine Road\"],\n    AddressLine2 = [\"Hopetown\", \"Smallville\", \"Metropolis\"],\n    AddressZip = [1234, 2345, 3456]\n)\n3×4 DataFrame\n#  Row │ Names   AddressLine1   AddressLine2  AddressZip \n#      │ String  String         String        Int64      \n# ─────┼─────────────────────────────────────────────────\n#    1 │ Tom     2 Maple Drive  Hopetown            1234\n#    2 │ Dick    4 Oak Street   Smallville          2345\n#    3 │ Harry   6 Pine Road    Metropolis          3456\n\n\ndf[:, r\"Addr\"]\n# 3×3 DataFrame\n#  Row │ AddressLine1   AddressLine2  AddressZip \n#      │ String         String        Int64      \n# ─────┼─────────────────────────────────────────\n#    1 │ 2 Maple Drive  Hopetown            1234\n#    2 │ 4 Oak Street   Smallville          2345\n#    3 │ 6 Pine Road    Metropolis          34\nHere we select all rows, but only the column that have the sub-string “Addr” in their names.\n\n\n\nYou can select rows by filtering the data. There are two equivalent ways:\nfilter(:X =&gt; &lt;=(10), df)\n# 4×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │     4      2      1      8      3      1\n#    3 │     7      3      1     14      4      1\n#    4 │    10      4      1     20      5      1\n\ndf[df.X .&lt;= 10, :]\n# 4×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │     4      2      1      8      3      1\n#    3 │     7      3      1     14      4      1\n#    4 │    10      4      1     20      5      1\nIn both cases we pass a predicate function, i.e. a function that returns true for rows that should be included. In the first case, a pair operator links a column name to the predicate function and in the second case we simply pass an expression that returns true for all the correct instances. Note the use of broadcasting in the second example.\n\n\n\n\n\n\nNote\n\n\n\nThe contents of the column being checked in the predicate function is passed as the first parameter, so :X =&gt; &lt;=(10) is in fact df[&lt;current row&gt;, X] &lt;= 10, which can also be written as &lt;=(df[&lt;current row&gt;, X], 10), since operators in Julia are just functions with special syntax - they can still be called like normal functions.\n\n\nYou can use any predicate function. A new useful ones include:\ndf[findfirst(==(4), df.C), :] # Find the first row where column C has a value of 4\n# DataFrameRow\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    6 │    16      6      2     32      8      4\n\ndf[findall(==(4), df.C), :] # Find all rows where column C has a value of 4\n# 5×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │    16      6      2     32      8      4\n#    2 │    19      7      2     38      9      4\n#    3 │    22      8      2     44     10      4\n#    4 │    25      9      2     50     11      4\n#    5 │    28     10      2     56     12      4\n\ndf[df.C .== 4, :] # Find all rows where column C has a value of 4, alternative form\n# 5×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │    16      6      2     32      8      4\n#    2 │    19      7      2     38      9      4\n#    3 │    22      8      2     44     10      4\n#    4 │    25      9      2     50     11      4\n#    5 │    28     10      2     56     12      4\nIt may also be useful to sort the data according to specified columns:\nsort(df, :Y)\n# 500×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │   301      1     21    602     22    441\n#    3 │   601      1     41   1202     42   1681\n#    4 │   901      1     61   1802     62   3721\n#    5 │  1201      1     81   2402     82   6561\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  497 │   598    100     40   1196    140   1600\n#  498 │   898    100     60   1796    160   3600\n#  499 │  1198    100     80   2396    180   6400\n#  500 │  1498    100    100   2996    200  10000\n#                                 491 rows omitted\n\nsort(df, [:Y, :B])\n# 500×6 DataFrame\n#  Row │ X      Y      Z      A      B      C\n#      │ Int64  Int64  Int64  Int64  Int64  Int64\n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │   301      1     21    602     22    441\n#    3 │   601      1     41   1202     42   1681\n#    4 │   901      1     61   1802     62   3721\n#    5 │  1201      1     81   2402     82   6561\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  497 │   598    100     40   1196    140   1600\n#  498 │   898    100     60   1796    160   3600\n#  499 │  1198    100     80   2396    180   6400\n#  500 │  1498    100    100   2996    200  10000\n#                                 491 rows omitted\n\n\n\nApplying a function to a column or multiple columns has been shown before when we added columns to a DataFrame. Since each column acts like a vector, we simply use normal Julia broadcasting to apply functions to whole columns:\ndf.BdivC = df.B ./ df.C\n# 500-element Vector{Float64}:\n#  2.0\n#  3.0\n#  4.0\n#  5.0\n#  6.0\n#  2.0\n#  2.25\n#  ⋮\n#  0.01979389858177737\n#  0.0196\n#  0.0197\n#  0.0198\n#  0.0199\n#  0.02\n\n# df\n# 500×7 DataFrame\n#  Row │ X      Y      Z      A      B      C      BdivC     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64  Float64   \n# ─────┼─────────────────────────────────────────────────────\n#    1 │     1      1      1      2      2      1  2.0\n#    2 │     4      2      1      8      3      1  3.0\n#    3 │     7      3      1     14      4      1  4.0\n#    4 │    10      4      1     20      5      1  5.0\n#    5 │    13      5      1     26      6      1  6.0\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮        ⋮\n#  497 │  1489     97    100   2978    197  10000  0.0197\n#  498 │  1492     98    100   2984    198  10000  0.0198\n#  499 │  1495     99    100   2990    199  10000  0.0199\n#  500 │  1498    100    100   2996    200  10000  0.02\n#                                            491 rows omitted\nIn order to apply functions across rows, we need to use some of the built-in functions of DataFrames, select and transform, along with ByRow.\nThe basic syntax is:\n\nselect(df, &lt;array of columns to select&gt;)\nselect(df, &lt;array of columns to select&gt;, &lt;array of columns to pass to function&gt; =&gt; &lt;function&gt; =&gt; &lt;name(s) of column(s) to hold result(s)&gt;)\nselect(df, AsTable(:) =&gt; &lt;function&gt; =&gt; &lt;name(s) of column(s) to hold result&gt;) # pass the entire table to the function\n\nSome examples:\n\nselect(df, :X, :X =&gt; cumsum =&gt; :cumX) # Put the cumulative sum of X in column cumX\n# 500×2 DataFrame\n#  Row │ X      cumX   \n#      │ Int64  Int64  \n# ─────┼───────────────\n#    1 │     1       1\n#    2 │     4       5\n#    3 │     7      12\n#    4 │    10      22\n#    5 │    13      35\n#   ⋮  │   ⋮      ⋮\n#  497 │  1489  370265\n#  498 │  1492  371757\n#  499 │  1495  373252\n#  500 │  1498  374750\n#      491 rows omitted\n\nselect(df, [:X, :Y], [:X, :Y] =&gt; ByRow((x, y) -&gt; sin(x)*cos(y)) =&gt; :sinXcosY) # Put the value of sin(X)*cos*(Y) in column sinXcosY\n# 500×3 DataFrame\n#  Row │ X      Y      sinXcosY    \n#      │ Int64  Int64  Float64     \n# ─────┼───────────────────────────\n#    1 │     1      1   0.454649\n#    2 │     4      2   0.314941\n#    3 │     7      3  -0.650412\n#    4 │    10      4   0.355596\n#    5 │    13      5   0.119185\n#   ⋮  │   ⋮      ⋮         ⋮\n#  497 │  1489     97   0.106082\n#  498 │  1492     98  -0.207859\n#  499 │  1495     99  -0.0154374\n#  500 │  1498    100   0.443124\n#                  491 rows omitted\n\nselect(df, AsTable(:) =&gt; ByRow(extrema) =&gt; [:min, :max]) # Find the smallest and largest value in each row\n# 500×2 DataFrame\n#  Row │ min    max   \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      2\n#    2 │     1      8\n#    3 │     1     14\n#    4 │     1     20\n#    5 │     1     26\n#   ⋮  │   ⋮      ⋮\n#  497 │    97  10000\n#  498 │    98  10000\n#  499 │    99  10000\n#  500 │   100  10000\n#     491 rows omitted\nIn each case, we used select and it only returned the specified columns. In the last example, we didn’t select any column, but just specified the function to apply. As a result, only the columns holding the results of the function are selected. If we instead call transform, the entire DataFrame is returned, as well as any new columns added in the calculations, e.g.\ntransform(df, AsTable(:) =&gt; ByRow(extrema) =&gt; [:min, :max])\n# 500×8 DataFrame\n#  Row │ X      Y      Z      A      B      C      min    max   \n#      │ Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────────────────────────────────\n#    1 │     1      1      1      2      2      1      1      2\n#    2 │     4      2      1      8      3      1      1      8\n#    3 │     7      3      1     14      4      1      1     14\n#    4 │    10      4      1     20      5      1      1     20\n#    5 │    13      5      1     26      6      1      1     26\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  497 │  1489     97    100   2978    197  10000     97  10000\n#  498 │  1492     98    100   2984    198  10000     98  10000\n#  499 │  1495     99    100   2990    199  10000     99  10000\n#  500 │  1498    100    100   2996    200  10000    100  10000\n#                                               491 rows omitted\nJust like before, select and transform return new DataFrames, while select! and transform! will modify the existing DataFrame.\n\n\n\n\n\nDataFrames will group your data by column values through the groupby() function. One or more columns can be specified and you will get a GroupedDataFrame - a container of SubDataFrames for each unique combination of the values in the specified columns.\ndf = DataFrame(X = 1:50, Y = repeat(1:2, outer=25), Z = repeat(2:2:10, inner=10))\n# 50×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      2 \n#    2 │     2      2      2\n#    3 │     3      1      2\n#    4 │     4      2      2\n#    5 │     5      1      2\n#    6 │     6      2      2\n#   ⋮  │   ⋮      ⋮      ⋮\n#   45 │    45      1     10\n#   46 │    46      2     10\n#   47 │    47      1     10\n#   48 │    48      2     10\n#   49 │    49      1     10\n#   50 │    50      2     10\n#             38 rows omitted\n\ngdf = groupby(df, [:Y, :Z]\n# GroupedDataFrame with 10 groups based on keys: Y, Z\n# First Group (5 rows): Y = 1, Z = 2\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      2\n#   ⋮  │   ⋮      ⋮      ⋮\n#    5 │     9      1      2\n#              3 rows omitted\n# ⋮\n# Last Group (5 rows): Y = 2, Z = 10\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │    42      2     10\n#   ⋮  │   ⋮      ⋮      ⋮\n#    5 │    50      2     10\n#              3 rows omitted\n\ncounts = combine(gdf, nrow, :X =&gt; mean)\n#     10×4 DataFrame\n#  Row │ Y      Z      nrow   X_mean\n#      │ Int64  Int64  Int64  Float64\n# ─────┼──────────────────────────────\n#    1 │     1      2      5      5.0\n#    2 │     1      4      5     15.0\n#    3 │     1      6      5     25.0\n#    4 │     1      8      5     35.0\n#    5 │     1     10      5     45.0\n#    6 │     2      2      5      6.0\n#    7 │     2      4      5     16.0\n#    8 │     2      6      5     26.0\n#    9 │     2      8      5     36.0\n#   10 │     2     10      5     46.0\n\ncounts = select(gdf, nrow, :X =&gt; mean) \n# 50×4 DataFrame\n#  Row │ Y      Z      nrow   X_mean  \n#      │ Int64  Int64  Int64  Float64 \n# ─────┼──────────────────────────────\n#    1 │     1      2      5      5.0\n#    2 │     2      2      5      6.0\n#    3 │     1      2      5      5.0\n#    4 │     2      2      5      6.0\n#    5 │     1      2      5      5.0\n#    6 │     2      2      5      6.0\n#   ⋮  │   ⋮      ⋮      ⋮       ⋮\n#   45 │     1     10      5     45.0\n#   46 │     2     10      5     46.0\n#   47 │     1     10      5     45.0\n#   48 │     2     10      5     46.0\n#   49 │     1     10      5     45.0\n#   50 │     2     10      5     46.0\n#                      38 rows omitted\nHere we create a DataFrame with three columns: X ranges from 1 to 50, Y alternates between 1 and 2, and Z is a sequence of the even numbers from 2 to 10. We then group by Y and Z, which gives us a GroupedDataFrame with 10 groups, for the 10 unique combinations of values in Y and Z. The second command created a new DataFrame, called counts which contains the number of rows in each of the 10 SubDataFrames in our GroupedDataFrame (gdf) as well as the mean2 value of the X column in each of the 10 groups. Lastly, we repeat the second example, but with select instead of combine. This returns a DataFrame with the same number (and order) of rows as in the original source DataFrame (not the grouped one!), but with only the newly created column. In this case, we see 50 rows, not the expected 10.\n\n\nFor this example, we use a dataset from Kaggle3. The data file includes information on the ingredients of 399 types of food.\ndf = CSV.read(raw\"D:\\JuliaCode\\KaggleData\\food_ingredients_and_allergens.csv\", DataFrame; normalizenames=true)\nselect!(df, [:Food_Product, :Allergens])\n# 399×2 DataFrame\n#  Row │ Food_Product             Allergens\n#      │ String                   String31\n# ─────┼─────────────────────────────────────────────────\n#    1 │ Almond Cookies           Almonds, Wheat, Dairy\n#    2 │ Almond Cookies           Almonds, Wheat, Dairy\n#    3 │ Chicken Noodle Soup      Chicken, Wheat, Celery\n#    4 │ Chicken Noodle Soup      Chicken, Wheat, Celery\n#    5 │ Cheddar Cheese           Dairy\n#    6 │ Ranch Dressing           Dairy\n#    7 │ Caramel Popcorn          Dairy\n#    8 │ Caesar Salad             Dairy\n#   ⋮  │            ⋮                       ⋮\n#  393 │ Chocolate Chip Pancakes  Wheat, Dairy, Cocoa\n#  394 │ Lemon Bars               Wheat, Dairy, Eggs\n#  395 │ Lemon Bars               Wheat, Dairy, Eggs\n#  396 │ Pecan Pie                Wheat, Dairy, Nuts\n#  397 │ Zucchini Bread           Wheat, Dairy, Nuts\n#  398 │ Banana Bread             Wheat, Dairy, Nuts\n#  399 │ Hawaiian Pizza           Wheat, Pork, Dairy\n#                                        384 rows omitted\nWe are going to focus on the allergens in these foods. We select to keep only the two column containing the names of the foods and the allergens contained in them. Unfortunately, the allergens are given as a single string of comma-separated values. This means we have to do a little processing of the data.\nWe ideally want a separate column for each allergen that contains a true (1) or false (0) to indicate if the allergen is present or not. To get this, we must process all the entries on allergens and split the strings into the individual allergens. We then need to identify the unique values, and add a true or false in a new column for each food and each allergen. This sounds like a lot of work, but Julia makes this easy.\nallAllergens = String[] #empty array of strings\nfor row in eachrow(df)\n    allergens = row.Allergens\n    for s in eachsplit(allergens, \", \")\n        push!(allAllergens, s)\n    end\nend\nunique!(allAllergens)\n\n# 24-element Vector{String}:\n#  \"Almonds\"\n#  \"Wheat\"\n#  \"Dairy\"\n#  \"Chicken\"\n#  \"Celery\"\n#  \"Anchovies\"\n#  \"Cocoa\"\n#  ⋮\n#  \"Oats\"\n#  \"Peanuts\"\n#  \"Pine nuts\"\n#  \"Rice\"\n#  \"Shellfish\"\n#  \"Pork\"\n#  \"Alcohol\"\nWe create an empty vector of Strings to hold the allergen names - allAllergens. Then we iterate trough the DataFrame, one row at a time, using the eachrow iterator. We extract the string holding the allergens into a temporary string allergens with allergens = row.Allergens (where row is the current row in the iterator eachrow).\nTo split the string (allergens) into the various allergens, we use the Julia function eachsplit, which splits the string with the specified delimiter (“,”), and returns an iterator of substrings. We loop through this iterator and push each substring into the empty vector we created at the start.\nLastly, we use the Julia function unique! to remove all duplicates from this vector. We now have a list of 24 possible allergens.\nfor allergen in allAllergens\n    transform!(df, :Allergens =&gt; ByRow(s -&gt; contains(string(s), allergen)) =&gt; Symbol(allergen))\nend\n\ndf[:, [:Food_Product, :Almonds, :Wheat, :Dairy]]\n# 399×4 DataFrame\n#  Row │ Food_Product             Almonds  Wheat  Dairy \n#      │ String                   Bool     Bool   Bool  \n# ─────┼────────────────────────────────────────────────\n#    1 │ Almond Cookies              true   true   true\n#    2 │ Almond Cookies              true   true   true\n#    3 │ Chicken Noodle Soup        false   true  false\n#    4 │ Chicken Noodle Soup        false   true  false\n#    5 │ Cheddar Cheese             false  false   true\n#    6 │ Ranch Dressing             false  false   true\n#   ⋮  │            ⋮                ⋮       ⋮      ⋮\n#  394 │ Lemon Bars                 false   true   true\n#  395 │ Lemon Bars                 false   true   true\n#  396 │ Pecan Pie                  false   true   true\n#  397 │ Zucchini Bread             false   true   true\n#  398 │ Banana Bread               false   true   true\n#  399 │ Hawaiian Pizza             false   true   true\n#                                       387 rows omitted\nWe now run through our newly created list of allergens and call the DataFrames function transform! for each allergen. transform! is the mutating version of transform and will modify the specified DataFrame rather than return a new object. transform includes all of the columns in the original DataFrame, unlike select, which will include only the specified columns.\nWe specify here than we want to take the contents of the Allergens column, and pass it, one row at a time (ByRow()) to an anonymous function (s -&gt; contains(string(s), allergen))) and store the result in a new column Symbol(allergen). Note that we are converting the name of the allergen, which is a String to a Symbol, which is what DataFrames expects here.\nThe anonymous function we define essentially only calls the Julia function contains, which will return a true or false depending on whether the string contains a specified substring. We convert the value from the DataFrame to a string (with the string() function), as DataFrames uses a more specialised data type for string values to save memory and improve performance. We have a quick look at three of the allergens and see that we indeed have exactly what we wanted.\nWe can now analyse the data any way we want to. Let’s group the data to see combinations of almonds and wheat in the various foods:\ngdf = groupby(df, [:Almonds, :Wheat])\n\nfor (keys, sdf) in pairs(gdf)\n    println(\"Number of foods with $keys: $(nrow(sdf))\")\nend\n\n# Number of foods with GroupKey: (Almonds = true, Wheat = true): 2\n# Number of foods with GroupKey: (Almonds = false, Wheat = true): 94\n# Number of foods with GroupKey: (Almonds = false, Wheat = false): 303\n\n\n\n\nDataFrames allows for joining of tables, just like in a SQL database. We shall give a few key definitions here to illustrate the concept.\nFirstly, what is a join? It is a combination of two tables, based on the values in a specified column, typically an ID or similar index value. The resulting table may include columns from one or both of the tables, for the rows that are included in the joined table, depending on the type of join.\nWe define two DataFrames to use in our examples:\ndf1 = DataFrame(ID = [1, 2, 3], Floor = [\"A\", \"B\", \"C\"], Office = [11, 12, 12])\n# 3×3 DataFrame\n#  Row │ ID     Floor   Office \n#      │ Int64  String  Int64  \n# ─────┼───────────────────────\n#    1 │     1  A           11\n#    2 │     2  B           12\n#    3 │     3  C           12\n\ndf2 = DataFrame(ID = [1, 2, 7, 11], Name = [\"Tom\", \"Dan\", \"Harry\", \"Bob\"])\n# 4×2 DataFrame\n#  Row │ ID     Name   \n#      │ Int64  String \n# ─────┼───────────────\n#    1 │     1  Tom\n#    2 │     2  Dan\n#    3 │     7  Harry\n#    4 │    11  Bob\nInner join: An inner join between two tables will include only the rows where the field (e.g. ID) on which you join, are the same in each table. Rows that include a value of ID that is only present in one of the two tables will not be included. All columns from both tables are included.\ninnerjoin(df1, df2, on=:ID)\n# 2×4 DataFrame\n#  Row │ ID     Floor   Office  Name   \n#      │ Int64  String  Int64   String \n# ─────┼───────────────────────────────\n#    1 │     1  A           11  Tom\n#    2 │     2  B           12  Dan\nLeft join: A left join between two tables will include all the rows from the left table, as well as those rows from right table where the joining field (e.g. ID) match. All columns are included, which may result in missing values in columns from the right table.\nleftjoin(df1, df2, on=:ID)\n# 3×4 DataFrame\n#  Row │ ID     Floor   Office  Name    \n#      │ Int64  String  Int64   String? \n# ─────┼────────────────────────────────\n#    1 │     1  A           11  Tom\n#    2 │     2  B           12  Dan\n#    3 │     3  C           12  missing \nRight join: Similar to a left join, but all rows from the right table are included and only matching rows from the left table. This may result in missing values in columns from the left table.\nrightjoin(df1, df2, on=:ID)\n# 4×4 DataFrame\n#  Row │ ID     Floor    Office   Name   \n#      │ Int64  String?  Int64?   String \n# ─────┼─────────────────────────────────\n#    1 │     1  A             11  Tom\n#    2 │     2  B             12  Dan\n#    3 │     7  missing  missing  Harry\n#    4 │    11  missing  missing  Bob\nOuter join: This will include all rows from both left and right tables, possibly resulting in missing values in all columns.\n# outerjoin(df1, df2, on=:ID)\n# 5×4 DataFrame\n#  Row │ ID     Floor    Office   Name    \n#      │ Int64  String?  Int64?   String? \n# ─────┼──────────────────────────────────\n#    1 │     1  A             11  Tom\n#    2 │     2  B             12  Dan\n#    3 │     3  C             12  missing \n#    4 │     7  missing  missing  Harry\n#    5 │    11  missing  missing  Bob\nSemi join (a.k.a. Left semi join): Like an inner join, this will only return rows that match in both columns, but will only return columns from the left table. This is useful if you want to select, for example, names from a list that are also present in another list, without including additional data from that list. To do a right semi join, just reverse the order to the two DataFrames.\nsemijoin(df1, df2, on=:ID)\n# 2×3 DataFrame\n#  Row │ ID     Floor   Office \n#      │ Int64  String  Int64  \n# ─────┼───────────────────────\n#    1 │     1  A           11\n#    2 │     2  B           12\nAnti join (a.k.a. Left anti join): Like the semi join, but will only return rows from the left table that are NOT matched in the right table.\nantijoin(df1, df2, on=:ID)\n# 1×3 DataFrame\n#  Row │ ID     Floor   Office \n#      │ Int64  String  Int64  \n# ─────┼───────────────────────\n#    1 │     3  C           12"
  },
  {
    "objectID": "13_DataFrames.html#footnotes",
    "href": "13_DataFrames.html#footnotes",
    "title": "DataFrames",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nUnless, of course, you used strings with spaces for column names.↩︎\nNote that to use the mean function, you need to first include the Statistics standard library↩︎\nKaggle is a website for data science enthusiasts. It has many data sets and run competitions to generate predictions based on these sets.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia for Engineering Research",
    "section": "",
    "text": "This is an introductory course to using the Julia programming language for technical programming.\nIt assumes some nominal programming background and knowledge of the engineering sciences and numerical methods to fully appreciate the examples.\nThis course is NOT meant to turn the reader into an expert in either Julia. or technical modelling. It is meant to get you up and running in a reasonably short time, so you can start learning by doing. More detailed references are given in each section for additional information.\nOnce you are comfortable with the material, it is recommended to also work through Parallel Computing and Scientific Machine Learning (SciML): Methods and Applications, which is a more advanced, and much more comprehensive document.\nThis is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n\n\n Back to top"
  }
]