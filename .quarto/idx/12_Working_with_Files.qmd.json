{"title":"Working with Files","markdown":{"yaml":{"title":"Working with Files"},"headingText":"Reading in Data","containsRefs":false,"markdown":"\n\n\nThere are many, many different libraries to manipulate various formats of text and binary files. Here we shall look only at the built-in Julia methods, and the most popular package for reading in large amounts of data - CSV.jl.\n\nFor cases where you may want to store binary data (such as storing variables to file), the JLD2[^1] package is very convenient.\n\n[^1]: The data is stored in a format compatible with the HDF5 standard and the package and read most files created by other programs in HDF5 format. HDF, or Hierarchical Data Format is a standard created by the US National Center for Supercomputing Applications.\n\nFor processing the data, there are again a near-infinite number of options. The most popular, and extremely powerful, choice is to put the data in a DataFrame object. We shall look at DataFrames in more detail in the next section.\n\n### Using Files in Julia - Open, Read and Write\n\nYou can do simple file access through the base Julia commands `open`, `read/readline(s)` and `write`:\n\nTo open a file in write mode:\n\n``` julia\nf = open(\"filename.txt\", \"w\")\n# IOStream(<file filename.txt>)\n\nwrite(f, \"Hello world.\\n\")\n# 13\n\nclose(f)\n```\n\n::: callout-note\nNote that, unlike when printing to the console, there is no print() and println() versions that do or do not add a new line. When writing to a file, you explicitly add the newline (`\\n`) in the string you are writing.\n:::\n\nTo open a file in read mode:\n\n``` julia\nf = open(\"filename.txt\", \"r\")\n# IOStream(<file filename.txt>)\ns = readlines(f)\n# 1-element Vector{String}:\n#  \"Hello world.\"\n```\n\nTo open a file in append mode:\n\n``` julia\nf = open(\"filename.txt\", \"a\")\n# IOStream(<file filename.txt>)\nwrite(f, \"Hello back.\\n\")\n# 12\nclose(f)\nf = open(\"filename.txt\", \"r\") # or just f = open(\"filename.txt\")\n# IOStream(<file filename.txt>)\ns = readlines(f)\n2-element Vector{String}:\n#  \"Hello world.\"\n#  \"Hello back.\"\n```\n\nOpening a file in read, write and append mode is fairly straight-forward. The object returned is an `IOStream`. There are several ways to interact with this object.\n\n-   `readline()`: Reads the next line in a file and return it as a `String`\n-   `readlines()`: This reads the entire file, interprets the contents as `Strings` and returns an array with each line a separate entry.\n-   `read()`: This reads the entire file, interprets the contents as data (UInt8, single byte values), e.g.\n\n``` julia\nss = read(f)\n# 25-element Vector{UInt8}:\n#  0x48\n#  0x65\n#  0x6c\n#  0x6c\n#  0x6f\n#  0x20\n#  0x77\n#  0x6f\n#  0x72\n#  0x6c\n#  0x64\n#  0x2e\n#  0x0a\n#  0x48\n#  0x65\n#  0x6c\n#  0x6c\n#  0x6f\n#  0x20\n#  0x62\n#  0x61\n#  0x63\n#  0x6b\n#  0x2e\n#  0x0a\n\nChar.(ss) # Convert the UInt8 data to Char to get better display in Julie\n# 25-element Vector{Char}:\n#  'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n#  'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n#  ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n#  'w': ASCII/Unicode U+0077 (category Ll: Letter, lowercase)\n#  'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n#  'r': ASCII/Unicode U+0072 (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n#  '.': ASCII/Unicode U+002E (category Po: Punctuation, other)\n#  '\\n': ASCII/Unicode U+000A (category Cc: Other, control)\n#  'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n#  'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n#  ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n#  'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n#  'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n#  'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n#  'k': ASCII/Unicode U+006B (category Ll: Letter, lowercase)\n#  '.': ASCII/Unicode U+002E (category Po: Punctuation, other)\n#  '\\n': ASCII/Unicode U+000A (category Cc: Other, control)\n```\n\n-   `write()`: Write a string to the file.\n\n::: callout-important\nA reminder again, that you need to explicitly add new lines characters, `\\n`. A call to `write(f, \"Line 1\", \"Line 1\")` will write the text \"Line 1Line 2\" to a single line in the file.\n:::\n\nThe use of `open()` is optional for reading and overwriting a file (not appending). You could simply supply the filename to `read()/readline()/readlines()` and `write()`:\n\n``` julia\nwrite(\"filename.txt\", \"This is some text.\\n\")\n# 19\n\nreadlines(\"filename.txt\")\n# 1-element Vector{String}:\n#  \"This is some text.\"\n```\n\nWhere `open()` comes in handy, is when you want to manipulate the contents of the file with a function. Combining `open()` with a `do` block is the most common way of doing this:\n\n``` julia\nas = collect(1:10)\n# 10-element Vector{Int64}:\n#   1\n#   2\n#   3\n#   4\n#   5\n#   6\n#   7\n#   8\n#   9\n#  10\n\nopen(\"data.txt\", \"w\") do f\n    for a in as\n        write(f, string(a)*\"/n\")\n    end\nend\n\nb = Int64[]\n# Int64[]\n\nopen(\"data.txt\", \"r\") do f\n    for l in eachline(f)\n        push!(b, parse(Int64, l))\n    end\nend\n\nb\n# 10-element Vector{Int64}:\n#   1\n#   2\n#   3\n#   4\n#   5\n#   6\n#   7\n#   8\n#   9\n#  10\n```\n\nSome new things to note in this example: `eachline()` returns an iterator that contains the lines of the file. We can loop through the lines using this and the lines only get read when needed - very useful for extremely large files.\n\n`parse()`, interprets a string as the type that is passed as the first parameter - `Int64` in this case. It will error if the interpretation is not possible:\n\n``` julia\nparse(Float64, \"this is not a numeric value\")\n# ERROR: ArgumentError: cannot parse \"this is not a numeric value\" as Float64\n```\n\nFor more information, see the [manual](https://docs.julialang.org/en/v1/base/io-network/)\n\n### The DelimitedFiles Standard Library\n\nWhile using the built-in file I/O functions are useful for simple text files, we more often work with larger files containing data. The [`DelimitedFiles`](http://delimitedfiles.juliadata.org/dev/) package is useful for working with small to medium (in the Mb range, not Gb) files that contain rows and columns of data. This package was a Julia standard library up to v1.9.0, when it was spun out as a separate package. The intent is to do this with more of the standard libraries to allow them to be developed faster and updated in-between Julia versions.\n\nThe benefit of `DelimitedFiles` over alternatives, like `CSV` is that it is lightweight. It does not have the functionality of CSV, nor the speed with larger files. When you only want to read in a small file, however, the additional compile time for `CSV` is more of a burden than a blessing. This is where `DelimitedFiles` shines.\n\nThere are only two function in the package:\n\n-   `readdlm()`: Read a delimited file\n-   `writedlm()`: Write a delimited file\n\nIn order to accommodate a large number of optional parameters, the package declares several versions of `readdlm`:\n\n``` julia\nreaddlm(source, delim::AbstractChar, T::Type, eol::AbstractChar; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=false, comment_char='#')\nreaddlm(source, delim::AbstractChar, eol::AbstractChar; options...)\nreaddlm(source, delim::AbstractChar, T::Type; options...)\nreaddlm(source, delim::AbstractChar; options...)\nreaddlm(source, T::Type; options...)\nreaddlm(source; options...)\n```\n\nThese parameters do the following:\n\n-   `source`: The source filename as a string, or a stream object.\n-   `delim`: The character used as a delimiter, such as `','`, or `'\\t'` (a tab character). Note the single quotes indicating a `Char`, not a `String`.\n-   `T`: The type of the data. If not specified, the function will interpret the data to identify the type and may return a heterogeneous array. If `T` is a numeric type, non-numeric entries will be interpreted as `NaN` for floating point types, or zero.\n-   `eol`: The end-of-line character, typically `'\\n'`.\n-   `header`: If `true`, the first row is read as column headings and the function returns a tuple `(data_cells, header_cells)`, rather than just `data_cells`\n-   `skipstart`: An integer value, indicating the number of lines to skip at the start\n-   `skipblanks`: If `true`, skip blank lines\n-   `use_mmap`: Use a memory map to access the file. This could speed up large file access, but must be used with caution on Windows - only when reading once and never when writing to the file.\n-   `quotes`: If true, column entries that are enclosed in double quotes may contain end-of-line and delimiter characters. Double quote characters inside the quote must be escaped with another double quote(`\"\"`)\n-   `dims`: A tuple, `(rows, columns)`, that estimated the size of the data. This can speed up things for large files as sufficient memory is allocated in a single block.\n-   `comments` and `comment_char`: If `comments` is true, lines starting with `comment_char` and text after a `comment_char` in a line are ignored.\n\nThe write option is a lot simpler and only takes the file to write to, the data, the delimiter and then the keyword arguments from `readdlm()`:\n\n``` julia\nwritedlm(f, A, delim='\\t'; opts)\n```\n\nHere, the only option that is currently used, is `quotes` to indicate that quoted strings can contain end-of-line and delimiter characters.\n\nSome examples:\n\n``` julia\na = collect(1:5)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = collect(2:2:10)\n# 5-element Vector{Int64}:\n#   2\n#   4\n#   6\n#   8\n#  10\n\nwritedlm(\"data.csv\", [a b], ',')\n\nreadlines(\"data.csv\")\n# 5-element Vector{String}:\n#  \"1,2\"\n#  \"2,4\"\n#  \"3,6\"\n#  \"4,8\"\n#  \"5,10\"\n\ndata = readdlm(\"data.csv\", ',')\n# 5×2 Matrix{Float64}:\n#  1.0   2.0\n#  2.0   4.0\n#  3.0   6.0\n#  4.0   8.0\n#  5.0  10.0\n\ndata = readdlm(\"data.csv\", ',', Int64)\n# 5×2 Matrix{Int64}:\n#  1   2\n#  2   4\n#  3   6\n#  4   8\n#  5  10\n```\n\n### FileIO.jl and JLD2.jl\n\nThe `FileIO` package is a common framework for reading and writing files that is used by many other packages, such as `JLD2`.\n\n`FileIO` supplies `load` and `save` and will identify the file's type from the extension. The actual code for a given file type is implemented by the package that uses `FileIO`.\n\nThere is a long list of file types and the packages that implement `load` and `save` for them in the [`FileIO` documentation](https://juliaio.github.io/FileIO.jl/stable/registry/). You can simply use `FileIO` and the package will call the correct package to save or load your data or file. That package must of course also be installed in your project.\n\nOne of these packages is `JLD2`. It implements `save` and `load` from `FileIO` for generic Julia variables. `JLD2` replaces the original `JLD` and is often hugely faster. `JLD` is still around, but you probably don't want to use it.\n\n#### Using JLD2\n\nFor consistency over many file types, we shall look at the `FileIO` interface implemented by JLD2. You can either just install and use `JLD2` or you can install both `FileIO` and `JLD2`, then just use `FileIO`. If you are only going to deal one or two file types, then you may prefer only installing the specific packages, rather than deal with FileIO. Each package will support `load` and `save` functions in addition to their internal functions.\n\n##### JLD2 with `load` and `save`\n\nThe `FileIO` specification requires you to supply a name for each variable you save. This can either by via creating a `Dict`[^2], or by passing the names and variables sequentially as parameters:\n\n[^2]: A dictionary, or a collection of name and value pairs.\n\n``` julia\nusing JLD2\n\nstruct MyData\n    x\n    y\nend\n\ndata = MyData(rand(5), rand(5))\n# MyData([0.41915922256751215, 0.36513861729204666, 0.922892254146376, 0.12902554672750943, 0.2285766214336168], [0.8030027668439638, 0.2007295612353277, 0.6996873161379902, 0.7449547510169909, 0.5305104381235525])\n\nv = rand(10)\n# 10-element Vector{Float64}:\n#  0.7689384578959101\n#  0.7408163205271128\n#  0.9655957120143325\n#  0.3581479242990463\n#  0.28719219030844134\n#  0.6645105539839383\n#  0.8936175723328116\n#  0.22088721590210036\n#  0.3338736118785931\n#  0.6492950330159202\n\nsave(\"data.jld2\", Dict(\"data\" => data, \"vector\" => v))\nsave(\"data2.jld2\", \"data\", data, \"vector\", v)\n```\n\nThe last two statements are equivalent.\n\nTo read the file, you can either read the whole dictionary, or specify the entries you want (using the name you specified when saving):\n\n``` julia\nload(\"data.jld2\")\n# Dict{String, Any} with 2 entries:\n#   \"vector\" => [0.768938, 0.740816, 0.965596, 0.358148, 0.287192, 0.664511, 0.893618, 0.220887, 0.333874, 0.649295]\n#   \"data\"   => MyData([0.419159, 0.365139, 0.922892, 0.129026, 0.228577], [0.803003, 0.20073, 0.699687, 0.744955, 0.5305…\n\ndat = load(\"data.jld2\", \"data\")\nMyData([0.41915922256751215, 0.36513861729204666, 0.922892254146376, 0.12902554672750943, 0.2285766214336168], [0.8030027668439638, 0.2007295612353277, 0.6996873161379902, 0.7449547510169909, 0.5305104381235525])\n\ndata.x == dat.x #Check against the original object created earlier\n# true\n\ndata.y == dat.y\n# true\n```\n\nHere the `struct`, `MyData` is already defined, but if you read a data file in a fresh instance of Julia without defining it, you will see that `JLD2` reconstructs the custom type for you:\n\n``` julia\nusing JLD2\n\ndata = load(\"data.jld2\", \"data\")\n# ┌ Warning: type Main.MyData does not exist in workspace; reconstructing\n# └ @ JLD2 C:\\Users\\Braam\\.julia\\packages\\JLD2\\ryhNR\\src\\data\\reconstructing_datatypes.jl:495\n# JLD2.ReconstructedTypes.var\"##Main.MyData#292\"([0.41915922256751215, 0.36513861729204666, 0.922892254146376, 0.12902554672750943, 0.2285766214336168], [0.8030027668439638, 0.2007295612353277, 0.6996873161379902, 0.7449547510169909, 0.5305104381235525])\n\ntypeof(data)\n# JLD2.ReconstructedTypes.var\"##Main.MyData#292\"\n```\n\nYou won't be able to create new objects of the type, however, as the constructors are not also recreated. You will however be able to access the data.\n\n``` julia\ndata.x\n# 5-element Vector{Float64}:\n#  0.41915922256751215\n#  0.36513861729204666\n#  0.922892254146376\n#  0.12902554672750943\n#  0.2285766214336168\n\ndata.y\n# 5-element Vector{Float64}:\n#  0.8030027668439638\n#  0.2007295612353277\n#  0.6996873161379902\n#  0.7449547510169909\n#  0.5305104381235525\n```\n\n### CSV.jl\n\nCSV, or comma separated values files are a very common way of storing data. You can save an Excel worksheet as a CSV file, and then process that further in Julia.\n\nThe `CSV` package is one of the fastest (often the fastest, but things can change with new versions of other packages) ways of reading large (VERY large) CSV files in any language[^3].\n\n[^3]: See https://www.zdnet.com/article/programming-languages-julia-touts-its-speed-edge-over-python-and-r/ as an example. Here Julia and CSV was up to 22x faster than R's `fread` and both R and Julia were faster than Pandas (Python)\n\nThe `CSV` package has a multitude of features. We are only going to look at the most commonly used ones here. You would however spend your time well in reading the full [documentation](https://csv.juliadata.org/stable/index.html) to see other options, like reading data directly from a zip or g-zipped file.\n\nWe are also going to assume the most common use case, that your data is read into or written from a DataFrame object. There is a separate section on DataFrames.\n\n#### Writing a CSV file\n\nWriting a DataFrame to a CSV file is simple. You just call `CSV.write(filename, dataframe, keyword options)`\n\n``` julia\nusing CSV, DataFrames\n\ndf = DataFrame(a = rand(10), b = rand(10))\n# 10×2 DataFrame\n#  Row │ a           b\n#      │ Float64     Float64\n# ─────┼──────────────────────\n#    1 │ 0.48043     0.94456\n#    2 │ 0.0665074   0.677552\n#    3 │ 0.789794    0.396974\n#    4 │ 0.0412975   0.987218\n#    5 │ 0.456003    0.789401\n#    6 │ 0.295094    0.985048\n#    7 │ 0.837373    0.654643\n#    8 │ 0.378567    0.632108\n#    9 │ 0.890707    0.700569\n#   10 │ 0.00709744  0.637061\n\nCSV.write(\"data.csv\", df)\n# \"data.csv\"\n```\n\nThere are many options that can be passed as keyword arguments. We shall look at only the more commonly used ones:\n\n-   `delim`: A character (or string) that specifies the delimiter character. Default to a comma.\n-   `quotechar`: A character that specifies what quote character should be used to wrap strings that contain end-of-line, delimiting characters.\n-   `missingstring`: A string that will be written in the place of `missing` values.\n-   `dateformat`: A date format string for `Date` and `DateTime` values.\n-   `append`: If `true`, will append to an existing file. Defaults to `false`.\n-   `header`: A list of column names to replace those of the input table or DataFrame\n-   `decimal`: The character to use for decimals, Defaults to `'.'`.\n\nThere are several more in the [documentation](https://csv.juliadata.org/stable/writing.html#CSV.write).\n\n#### Reading a CSV file\n\nThe easiest way to read a CSV file is via `CSV.read()`. This function allows you to specify a sink - the type the data should be cast into.\n\n``` julia\nusing CSV, DataFrames\n\ndf = CSV.read(\"data.csv\", DataFrame)\n# 10×2 DataFrame\n#  Row │ a           b\n#      │ Float64     Float64\n# ─────┼──────────────────────\n#    1 │ 0.48043     0.94456\n#    2 │ 0.0665074   0.677552\n#    3 │ 0.789794    0.396974\n#    4 │ 0.0412975   0.987218\n#    5 │ 0.456003    0.789401\n#    6 │ 0.295094    0.985048\n#    7 │ 0.837373    0.654643\n#    8 │ 0.378567    0.632108\n#    9 │ 0.890707    0.700569\n#   10 │ 0.00709744  0.637061\n```\n\nYou can also pass keyword options, like for `CSV.write()`:\n\n-   `header`:\n    -   When passed an integer, this is the number of the line that contains the column names. Lines before this are considered comments.\n    -   If a vector of integers are passed, these rows will be concatenated to determine the column names. - A vector of names (either strings or symbols) can also be passed to specify the names. Don't do this if there are names in the file, unless you skip that line with `skipto`\n    -   `header` can be set to either zero or `false` to auto-generate column names (Column1, Column2...).\n    -   If commented or empty rows are present, counting starts at the first non-commented/non-empty row.\n-   `normalizenames`:\n    -   When set to `true`, this will replace spaces in names with underscores and any other processing that is needed to generate valid Julia identifiers.\n    -   Defaults to `false`.\n-   `skipto`:\n    -   Jump to the specified line (an integer) and start reading there.\n    -   Can be used to skip the column names and replace them with names specified in `header`.\n    -   Note that commented and empty rows (if `ignoreemptyrows` is specified) are **not** counted.\n-   `footerskip`:\n    -   Skip the specified number of lines at the end of the file.\n    -   Commented rows do not count, nor empty rows if `skipemptyrows` is specified.\n-   `transpose`:\n    -   Transpose the file - rows become columns etc.\n-   `comment`:\n    -   A string that specifies which rows are commented in the file. Any row beginning with this is considered a comment.\n-   `ignoreemptyrows`:\n    -   If `true`, empty lines will be skipped.\n    -   Note that this can influence the count in `skipto` and `header`.\n    -   Defaults to `true`.\n-   `select`:\n    -   Pass a vector of integers, symbols, strings or `Bool`s to indicate which **columns** to read.\n    -   Can also pass a predicate function (i, name) -\\> keep::Bool Only functions for which the function returns `true` are kept.\n-   `drop`:\n    -   The inverse of `select`. Indicate which columns to skip.\n-   `limit`:\n    -   The maximum number of rows to read.\n    -   Combine with `skipto` to only read a part of the file.\n-   `missingstring`:\n    -   Specifies a string that indicates `missing` values. Often this will be `NA` when the data file was generated by R.\n-   `delim`:\n    -   A character used to separate the columns.\n    -   Defaults to `','`.\n-   `ignorerepeated`:\n    -   If `true`, consecutive delimiters are treated as a single one.\n    -   Use with caution, as consecutive delimiters can also be used to show a missing value from a column. Some files, however, use fixed column widths and pad with delimiters, such as spaces.\n-   `quoted`:\n    -   Indicate whether quoted strings are present\n-   `quotechar`:\n    -   Indicate the character used as quotation mark.\n    -   Quoted strings can include end-of-line and delimiter characters.\n-   `dateformat`:\n    -   A date format string for Date and DateTime columns\n    -   See Dates.DateFormat in the Julia [documentation](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat).\n-   `decimal`:\n    -   Indicate the decimal character\n    -   Defaults to `'.'`.\n-   `truestrings` / `falsestrings`\n    -   Vectors that specify strings that indicate `true` and `false` values, like \"true\", \"TRUE\", \"T\", \"1\", etc.\n-   `skipwhitespace`:\n    -   If `true`, skip leading and trailing white space from values and column names\n-   `types`:\n    -   A single type, vector or Dict of types to specify the types of each column, when you want to override the automatic detection of types.\n    -   The Dict can link a column name (as string or symbol) or index to a type, e.g. `Dict(1 => Int64)`.\n    -   Consider using `validate` with `types`.\n-   `validate`:\n    -   Check that the data and specified types match up.\n\nOther parameters specify the number of parallel thread to read in large files and how many lines should be processed to determine the types of each column, etc. Clearly `CSV` is a complex package with huge flexibility. Unfortunately, this usually means a bit of a learning curve for the users.","srcMarkdownNoYaml":"\n\n## Reading in Data\n\nThere are many, many different libraries to manipulate various formats of text and binary files. Here we shall look only at the built-in Julia methods, and the most popular package for reading in large amounts of data - CSV.jl.\n\nFor cases where you may want to store binary data (such as storing variables to file), the JLD2[^1] package is very convenient.\n\n[^1]: The data is stored in a format compatible with the HDF5 standard and the package and read most files created by other programs in HDF5 format. HDF, or Hierarchical Data Format is a standard created by the US National Center for Supercomputing Applications.\n\nFor processing the data, there are again a near-infinite number of options. The most popular, and extremely powerful, choice is to put the data in a DataFrame object. We shall look at DataFrames in more detail in the next section.\n\n### Using Files in Julia - Open, Read and Write\n\nYou can do simple file access through the base Julia commands `open`, `read/readline(s)` and `write`:\n\nTo open a file in write mode:\n\n``` julia\nf = open(\"filename.txt\", \"w\")\n# IOStream(<file filename.txt>)\n\nwrite(f, \"Hello world.\\n\")\n# 13\n\nclose(f)\n```\n\n::: callout-note\nNote that, unlike when printing to the console, there is no print() and println() versions that do or do not add a new line. When writing to a file, you explicitly add the newline (`\\n`) in the string you are writing.\n:::\n\nTo open a file in read mode:\n\n``` julia\nf = open(\"filename.txt\", \"r\")\n# IOStream(<file filename.txt>)\ns = readlines(f)\n# 1-element Vector{String}:\n#  \"Hello world.\"\n```\n\nTo open a file in append mode:\n\n``` julia\nf = open(\"filename.txt\", \"a\")\n# IOStream(<file filename.txt>)\nwrite(f, \"Hello back.\\n\")\n# 12\nclose(f)\nf = open(\"filename.txt\", \"r\") # or just f = open(\"filename.txt\")\n# IOStream(<file filename.txt>)\ns = readlines(f)\n2-element Vector{String}:\n#  \"Hello world.\"\n#  \"Hello back.\"\n```\n\nOpening a file in read, write and append mode is fairly straight-forward. The object returned is an `IOStream`. There are several ways to interact with this object.\n\n-   `readline()`: Reads the next line in a file and return it as a `String`\n-   `readlines()`: This reads the entire file, interprets the contents as `Strings` and returns an array with each line a separate entry.\n-   `read()`: This reads the entire file, interprets the contents as data (UInt8, single byte values), e.g.\n\n``` julia\nss = read(f)\n# 25-element Vector{UInt8}:\n#  0x48\n#  0x65\n#  0x6c\n#  0x6c\n#  0x6f\n#  0x20\n#  0x77\n#  0x6f\n#  0x72\n#  0x6c\n#  0x64\n#  0x2e\n#  0x0a\n#  0x48\n#  0x65\n#  0x6c\n#  0x6c\n#  0x6f\n#  0x20\n#  0x62\n#  0x61\n#  0x63\n#  0x6b\n#  0x2e\n#  0x0a\n\nChar.(ss) # Convert the UInt8 data to Char to get better display in Julie\n# 25-element Vector{Char}:\n#  'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n#  'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n#  ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n#  'w': ASCII/Unicode U+0077 (category Ll: Letter, lowercase)\n#  'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n#  'r': ASCII/Unicode U+0072 (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n#  '.': ASCII/Unicode U+002E (category Po: Punctuation, other)\n#  '\\n': ASCII/Unicode U+000A (category Cc: Other, control)\n#  'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n#  'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'l': ASCII/Unicode U+006C (category Ll: Letter, lowercase)\n#  'o': ASCII/Unicode U+006F (category Ll: Letter, lowercase)\n#  ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n#  'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n#  'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n#  'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n#  'k': ASCII/Unicode U+006B (category Ll: Letter, lowercase)\n#  '.': ASCII/Unicode U+002E (category Po: Punctuation, other)\n#  '\\n': ASCII/Unicode U+000A (category Cc: Other, control)\n```\n\n-   `write()`: Write a string to the file.\n\n::: callout-important\nA reminder again, that you need to explicitly add new lines characters, `\\n`. A call to `write(f, \"Line 1\", \"Line 1\")` will write the text \"Line 1Line 2\" to a single line in the file.\n:::\n\nThe use of `open()` is optional for reading and overwriting a file (not appending). You could simply supply the filename to `read()/readline()/readlines()` and `write()`:\n\n``` julia\nwrite(\"filename.txt\", \"This is some text.\\n\")\n# 19\n\nreadlines(\"filename.txt\")\n# 1-element Vector{String}:\n#  \"This is some text.\"\n```\n\nWhere `open()` comes in handy, is when you want to manipulate the contents of the file with a function. Combining `open()` with a `do` block is the most common way of doing this:\n\n``` julia\nas = collect(1:10)\n# 10-element Vector{Int64}:\n#   1\n#   2\n#   3\n#   4\n#   5\n#   6\n#   7\n#   8\n#   9\n#  10\n\nopen(\"data.txt\", \"w\") do f\n    for a in as\n        write(f, string(a)*\"/n\")\n    end\nend\n\nb = Int64[]\n# Int64[]\n\nopen(\"data.txt\", \"r\") do f\n    for l in eachline(f)\n        push!(b, parse(Int64, l))\n    end\nend\n\nb\n# 10-element Vector{Int64}:\n#   1\n#   2\n#   3\n#   4\n#   5\n#   6\n#   7\n#   8\n#   9\n#  10\n```\n\nSome new things to note in this example: `eachline()` returns an iterator that contains the lines of the file. We can loop through the lines using this and the lines only get read when needed - very useful for extremely large files.\n\n`parse()`, interprets a string as the type that is passed as the first parameter - `Int64` in this case. It will error if the interpretation is not possible:\n\n``` julia\nparse(Float64, \"this is not a numeric value\")\n# ERROR: ArgumentError: cannot parse \"this is not a numeric value\" as Float64\n```\n\nFor more information, see the [manual](https://docs.julialang.org/en/v1/base/io-network/)\n\n### The DelimitedFiles Standard Library\n\nWhile using the built-in file I/O functions are useful for simple text files, we more often work with larger files containing data. The [`DelimitedFiles`](http://delimitedfiles.juliadata.org/dev/) package is useful for working with small to medium (in the Mb range, not Gb) files that contain rows and columns of data. This package was a Julia standard library up to v1.9.0, when it was spun out as a separate package. The intent is to do this with more of the standard libraries to allow them to be developed faster and updated in-between Julia versions.\n\nThe benefit of `DelimitedFiles` over alternatives, like `CSV` is that it is lightweight. It does not have the functionality of CSV, nor the speed with larger files. When you only want to read in a small file, however, the additional compile time for `CSV` is more of a burden than a blessing. This is where `DelimitedFiles` shines.\n\nThere are only two function in the package:\n\n-   `readdlm()`: Read a delimited file\n-   `writedlm()`: Write a delimited file\n\nIn order to accommodate a large number of optional parameters, the package declares several versions of `readdlm`:\n\n``` julia\nreaddlm(source, delim::AbstractChar, T::Type, eol::AbstractChar; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=false, comment_char='#')\nreaddlm(source, delim::AbstractChar, eol::AbstractChar; options...)\nreaddlm(source, delim::AbstractChar, T::Type; options...)\nreaddlm(source, delim::AbstractChar; options...)\nreaddlm(source, T::Type; options...)\nreaddlm(source; options...)\n```\n\nThese parameters do the following:\n\n-   `source`: The source filename as a string, or a stream object.\n-   `delim`: The character used as a delimiter, such as `','`, or `'\\t'` (a tab character). Note the single quotes indicating a `Char`, not a `String`.\n-   `T`: The type of the data. If not specified, the function will interpret the data to identify the type and may return a heterogeneous array. If `T` is a numeric type, non-numeric entries will be interpreted as `NaN` for floating point types, or zero.\n-   `eol`: The end-of-line character, typically `'\\n'`.\n-   `header`: If `true`, the first row is read as column headings and the function returns a tuple `(data_cells, header_cells)`, rather than just `data_cells`\n-   `skipstart`: An integer value, indicating the number of lines to skip at the start\n-   `skipblanks`: If `true`, skip blank lines\n-   `use_mmap`: Use a memory map to access the file. This could speed up large file access, but must be used with caution on Windows - only when reading once and never when writing to the file.\n-   `quotes`: If true, column entries that are enclosed in double quotes may contain end-of-line and delimiter characters. Double quote characters inside the quote must be escaped with another double quote(`\"\"`)\n-   `dims`: A tuple, `(rows, columns)`, that estimated the size of the data. This can speed up things for large files as sufficient memory is allocated in a single block.\n-   `comments` and `comment_char`: If `comments` is true, lines starting with `comment_char` and text after a `comment_char` in a line are ignored.\n\nThe write option is a lot simpler and only takes the file to write to, the data, the delimiter and then the keyword arguments from `readdlm()`:\n\n``` julia\nwritedlm(f, A, delim='\\t'; opts)\n```\n\nHere, the only option that is currently used, is `quotes` to indicate that quoted strings can contain end-of-line and delimiter characters.\n\nSome examples:\n\n``` julia\na = collect(1:5)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = collect(2:2:10)\n# 5-element Vector{Int64}:\n#   2\n#   4\n#   6\n#   8\n#  10\n\nwritedlm(\"data.csv\", [a b], ',')\n\nreadlines(\"data.csv\")\n# 5-element Vector{String}:\n#  \"1,2\"\n#  \"2,4\"\n#  \"3,6\"\n#  \"4,8\"\n#  \"5,10\"\n\ndata = readdlm(\"data.csv\", ',')\n# 5×2 Matrix{Float64}:\n#  1.0   2.0\n#  2.0   4.0\n#  3.0   6.0\n#  4.0   8.0\n#  5.0  10.0\n\ndata = readdlm(\"data.csv\", ',', Int64)\n# 5×2 Matrix{Int64}:\n#  1   2\n#  2   4\n#  3   6\n#  4   8\n#  5  10\n```\n\n### FileIO.jl and JLD2.jl\n\nThe `FileIO` package is a common framework for reading and writing files that is used by many other packages, such as `JLD2`.\n\n`FileIO` supplies `load` and `save` and will identify the file's type from the extension. The actual code for a given file type is implemented by the package that uses `FileIO`.\n\nThere is a long list of file types and the packages that implement `load` and `save` for them in the [`FileIO` documentation](https://juliaio.github.io/FileIO.jl/stable/registry/). You can simply use `FileIO` and the package will call the correct package to save or load your data or file. That package must of course also be installed in your project.\n\nOne of these packages is `JLD2`. It implements `save` and `load` from `FileIO` for generic Julia variables. `JLD2` replaces the original `JLD` and is often hugely faster. `JLD` is still around, but you probably don't want to use it.\n\n#### Using JLD2\n\nFor consistency over many file types, we shall look at the `FileIO` interface implemented by JLD2. You can either just install and use `JLD2` or you can install both `FileIO` and `JLD2`, then just use `FileIO`. If you are only going to deal one or two file types, then you may prefer only installing the specific packages, rather than deal with FileIO. Each package will support `load` and `save` functions in addition to their internal functions.\n\n##### JLD2 with `load` and `save`\n\nThe `FileIO` specification requires you to supply a name for each variable you save. This can either by via creating a `Dict`[^2], or by passing the names and variables sequentially as parameters:\n\n[^2]: A dictionary, or a collection of name and value pairs.\n\n``` julia\nusing JLD2\n\nstruct MyData\n    x\n    y\nend\n\ndata = MyData(rand(5), rand(5))\n# MyData([0.41915922256751215, 0.36513861729204666, 0.922892254146376, 0.12902554672750943, 0.2285766214336168], [0.8030027668439638, 0.2007295612353277, 0.6996873161379902, 0.7449547510169909, 0.5305104381235525])\n\nv = rand(10)\n# 10-element Vector{Float64}:\n#  0.7689384578959101\n#  0.7408163205271128\n#  0.9655957120143325\n#  0.3581479242990463\n#  0.28719219030844134\n#  0.6645105539839383\n#  0.8936175723328116\n#  0.22088721590210036\n#  0.3338736118785931\n#  0.6492950330159202\n\nsave(\"data.jld2\", Dict(\"data\" => data, \"vector\" => v))\nsave(\"data2.jld2\", \"data\", data, \"vector\", v)\n```\n\nThe last two statements are equivalent.\n\nTo read the file, you can either read the whole dictionary, or specify the entries you want (using the name you specified when saving):\n\n``` julia\nload(\"data.jld2\")\n# Dict{String, Any} with 2 entries:\n#   \"vector\" => [0.768938, 0.740816, 0.965596, 0.358148, 0.287192, 0.664511, 0.893618, 0.220887, 0.333874, 0.649295]\n#   \"data\"   => MyData([0.419159, 0.365139, 0.922892, 0.129026, 0.228577], [0.803003, 0.20073, 0.699687, 0.744955, 0.5305…\n\ndat = load(\"data.jld2\", \"data\")\nMyData([0.41915922256751215, 0.36513861729204666, 0.922892254146376, 0.12902554672750943, 0.2285766214336168], [0.8030027668439638, 0.2007295612353277, 0.6996873161379902, 0.7449547510169909, 0.5305104381235525])\n\ndata.x == dat.x #Check against the original object created earlier\n# true\n\ndata.y == dat.y\n# true\n```\n\nHere the `struct`, `MyData` is already defined, but if you read a data file in a fresh instance of Julia without defining it, you will see that `JLD2` reconstructs the custom type for you:\n\n``` julia\nusing JLD2\n\ndata = load(\"data.jld2\", \"data\")\n# ┌ Warning: type Main.MyData does not exist in workspace; reconstructing\n# └ @ JLD2 C:\\Users\\Braam\\.julia\\packages\\JLD2\\ryhNR\\src\\data\\reconstructing_datatypes.jl:495\n# JLD2.ReconstructedTypes.var\"##Main.MyData#292\"([0.41915922256751215, 0.36513861729204666, 0.922892254146376, 0.12902554672750943, 0.2285766214336168], [0.8030027668439638, 0.2007295612353277, 0.6996873161379902, 0.7449547510169909, 0.5305104381235525])\n\ntypeof(data)\n# JLD2.ReconstructedTypes.var\"##Main.MyData#292\"\n```\n\nYou won't be able to create new objects of the type, however, as the constructors are not also recreated. You will however be able to access the data.\n\n``` julia\ndata.x\n# 5-element Vector{Float64}:\n#  0.41915922256751215\n#  0.36513861729204666\n#  0.922892254146376\n#  0.12902554672750943\n#  0.2285766214336168\n\ndata.y\n# 5-element Vector{Float64}:\n#  0.8030027668439638\n#  0.2007295612353277\n#  0.6996873161379902\n#  0.7449547510169909\n#  0.5305104381235525\n```\n\n### CSV.jl\n\nCSV, or comma separated values files are a very common way of storing data. You can save an Excel worksheet as a CSV file, and then process that further in Julia.\n\nThe `CSV` package is one of the fastest (often the fastest, but things can change with new versions of other packages) ways of reading large (VERY large) CSV files in any language[^3].\n\n[^3]: See https://www.zdnet.com/article/programming-languages-julia-touts-its-speed-edge-over-python-and-r/ as an example. Here Julia and CSV was up to 22x faster than R's `fread` and both R and Julia were faster than Pandas (Python)\n\nThe `CSV` package has a multitude of features. We are only going to look at the most commonly used ones here. You would however spend your time well in reading the full [documentation](https://csv.juliadata.org/stable/index.html) to see other options, like reading data directly from a zip or g-zipped file.\n\nWe are also going to assume the most common use case, that your data is read into or written from a DataFrame object. There is a separate section on DataFrames.\n\n#### Writing a CSV file\n\nWriting a DataFrame to a CSV file is simple. You just call `CSV.write(filename, dataframe, keyword options)`\n\n``` julia\nusing CSV, DataFrames\n\ndf = DataFrame(a = rand(10), b = rand(10))\n# 10×2 DataFrame\n#  Row │ a           b\n#      │ Float64     Float64\n# ─────┼──────────────────────\n#    1 │ 0.48043     0.94456\n#    2 │ 0.0665074   0.677552\n#    3 │ 0.789794    0.396974\n#    4 │ 0.0412975   0.987218\n#    5 │ 0.456003    0.789401\n#    6 │ 0.295094    0.985048\n#    7 │ 0.837373    0.654643\n#    8 │ 0.378567    0.632108\n#    9 │ 0.890707    0.700569\n#   10 │ 0.00709744  0.637061\n\nCSV.write(\"data.csv\", df)\n# \"data.csv\"\n```\n\nThere are many options that can be passed as keyword arguments. We shall look at only the more commonly used ones:\n\n-   `delim`: A character (or string) that specifies the delimiter character. Default to a comma.\n-   `quotechar`: A character that specifies what quote character should be used to wrap strings that contain end-of-line, delimiting characters.\n-   `missingstring`: A string that will be written in the place of `missing` values.\n-   `dateformat`: A date format string for `Date` and `DateTime` values.\n-   `append`: If `true`, will append to an existing file. Defaults to `false`.\n-   `header`: A list of column names to replace those of the input table or DataFrame\n-   `decimal`: The character to use for decimals, Defaults to `'.'`.\n\nThere are several more in the [documentation](https://csv.juliadata.org/stable/writing.html#CSV.write).\n\n#### Reading a CSV file\n\nThe easiest way to read a CSV file is via `CSV.read()`. This function allows you to specify a sink - the type the data should be cast into.\n\n``` julia\nusing CSV, DataFrames\n\ndf = CSV.read(\"data.csv\", DataFrame)\n# 10×2 DataFrame\n#  Row │ a           b\n#      │ Float64     Float64\n# ─────┼──────────────────────\n#    1 │ 0.48043     0.94456\n#    2 │ 0.0665074   0.677552\n#    3 │ 0.789794    0.396974\n#    4 │ 0.0412975   0.987218\n#    5 │ 0.456003    0.789401\n#    6 │ 0.295094    0.985048\n#    7 │ 0.837373    0.654643\n#    8 │ 0.378567    0.632108\n#    9 │ 0.890707    0.700569\n#   10 │ 0.00709744  0.637061\n```\n\nYou can also pass keyword options, like for `CSV.write()`:\n\n-   `header`:\n    -   When passed an integer, this is the number of the line that contains the column names. Lines before this are considered comments.\n    -   If a vector of integers are passed, these rows will be concatenated to determine the column names. - A vector of names (either strings or symbols) can also be passed to specify the names. Don't do this if there are names in the file, unless you skip that line with `skipto`\n    -   `header` can be set to either zero or `false` to auto-generate column names (Column1, Column2...).\n    -   If commented or empty rows are present, counting starts at the first non-commented/non-empty row.\n-   `normalizenames`:\n    -   When set to `true`, this will replace spaces in names with underscores and any other processing that is needed to generate valid Julia identifiers.\n    -   Defaults to `false`.\n-   `skipto`:\n    -   Jump to the specified line (an integer) and start reading there.\n    -   Can be used to skip the column names and replace them with names specified in `header`.\n    -   Note that commented and empty rows (if `ignoreemptyrows` is specified) are **not** counted.\n-   `footerskip`:\n    -   Skip the specified number of lines at the end of the file.\n    -   Commented rows do not count, nor empty rows if `skipemptyrows` is specified.\n-   `transpose`:\n    -   Transpose the file - rows become columns etc.\n-   `comment`:\n    -   A string that specifies which rows are commented in the file. Any row beginning with this is considered a comment.\n-   `ignoreemptyrows`:\n    -   If `true`, empty lines will be skipped.\n    -   Note that this can influence the count in `skipto` and `header`.\n    -   Defaults to `true`.\n-   `select`:\n    -   Pass a vector of integers, symbols, strings or `Bool`s to indicate which **columns** to read.\n    -   Can also pass a predicate function (i, name) -\\> keep::Bool Only functions for which the function returns `true` are kept.\n-   `drop`:\n    -   The inverse of `select`. Indicate which columns to skip.\n-   `limit`:\n    -   The maximum number of rows to read.\n    -   Combine with `skipto` to only read a part of the file.\n-   `missingstring`:\n    -   Specifies a string that indicates `missing` values. Often this will be `NA` when the data file was generated by R.\n-   `delim`:\n    -   A character used to separate the columns.\n    -   Defaults to `','`.\n-   `ignorerepeated`:\n    -   If `true`, consecutive delimiters are treated as a single one.\n    -   Use with caution, as consecutive delimiters can also be used to show a missing value from a column. Some files, however, use fixed column widths and pad with delimiters, such as spaces.\n-   `quoted`:\n    -   Indicate whether quoted strings are present\n-   `quotechar`:\n    -   Indicate the character used as quotation mark.\n    -   Quoted strings can include end-of-line and delimiter characters.\n-   `dateformat`:\n    -   A date format string for Date and DateTime columns\n    -   See Dates.DateFormat in the Julia [documentation](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat).\n-   `decimal`:\n    -   Indicate the decimal character\n    -   Defaults to `'.'`.\n-   `truestrings` / `falsestrings`\n    -   Vectors that specify strings that indicate `true` and `false` values, like \"true\", \"TRUE\", \"T\", \"1\", etc.\n-   `skipwhitespace`:\n    -   If `true`, skip leading and trailing white space from values and column names\n-   `types`:\n    -   A single type, vector or Dict of types to specify the types of each column, when you want to override the automatic detection of types.\n    -   The Dict can link a column name (as string or symbol) or index to a type, e.g. `Dict(1 => Int64)`.\n    -   Consider using `validate` with `types`.\n-   `validate`:\n    -   Check that the data and specified types match up.\n\nOther parameters specify the number of parallel thread to read in large files and how many lines should be processed to determine the types of each column, etc. Clearly `CSV` is a complex package with huge flexibility. Unfortunately, this usually means a bit of a learning curve for the users."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"embed-resources":true,"output-file":"12_Working_with_Files.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"cosmo","monofont":"JetBrains Mono","smooth-scroll":false,"footnotes-hover":true,"title":"Working with Files"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}