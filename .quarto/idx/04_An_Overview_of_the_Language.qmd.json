{"title":"An Overview of the Language","markdown":{"yaml":{"title":"An Overview of the Language"},"headingText":"Package Management","containsRefs":false,"markdown":"\n\nThis section is meant to give you a running start in using Julia. The ultimate reference for all things regarding the language is the official [manual](https://docs.julialang.org/en/v1/), where you will find much more information.\n\n\nJulia will open up in the default environment, e.g., `@v1.9`. You can add packages to this environment, and they will be available to load as soon as you open Julia. Be very careful about doing this, as this can very often lead to what is lightly called *dependency hell*. This is what happens when a package you want to update depends on another package that can't update, sometime because it depends on a specific version of yet another package. The more packages you have in the current environment, the more often this will happen. The correct solution is to create a new environment for each project and add only the packages you are actually using in the project.\n\n``` julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.9.1 (2023-06-07)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\ncd(\"./Dummy\")\n\npwd()\n# \"D:\\\\JuliaCode\\\\Dummy\"\n\n(@v1.9) pkg> activate .   #type ] to activate package manager in REPL\n  # Activating project at `D:\\JuliaCode\\Dummy`\n\n(Dummy) pkg> add UnicodePlots\n  #   Updating registry at `C:\\Users\\Braam\\.julia\\registries\\General.toml`\n  #  Resolving package versions...\n  #   Updating `D:\\JuliaCode\\Dummy\\Project.toml`\n  # [b8865327] + UnicodePlots v3.4.1\n  #   Updating `D:\\JuliaCode\\Dummy\\Manifest.toml`\n  # [d360d2e6] + ChainRulesCore v1.15.7\n  # [9e997f8a] + ChangesOfVariables v0.1.6\n  # [35d6a980] + ColorSchemes v3.20.0\n  # .\n  # .\n  # .\n\n(Dummy) pkg> st\n# Status `D:\\JuliaCode\\Dummy\\Project.toml`\n#   [b8865327] UnicodePlots v3.4.1\n```\n\nHere we changed the current directory to the *Dummy* sub-folder. Note the use of a forward slash. Backslashes are used for special characters, , `\\n` for a new line and must themselves be *escaped* by typing a double backslash: `cd(\".\\\\Dummy\")`. Or you can use a raw string: `cd(raw\".\\Dummy\")`. The forward slash however works just as well in Linux and MaxOS, so is preferred.\n\n`pwd()` is a function that replicates the Unix (Linux) command for *print working directory* and simply returns the name of the current folder.\n\nThe package manager is then activated with `]` and the current folder is activated as a project with `activate .`, where `.` means the current directory (`..` means the parent directory).\n\nFinally, we add a registered package, UnicodePlots.jl, and once the installation is done, check which packages and versions are currently installed with the `st` command (short for `status`).\n\nOnce a package is installed, it can be loaded by issuing the `using` command:\n\n``` julia\nusing UnicodePlots\n```\n\nIn the `Dummy` folder, Julia creates two files: `project.toml` and `manifest.toml`. These hold the record of the specific versions of packages that have been installed *for this project*. The packages directly installed are in the `project.toml` file, while the version numbers of dependencies are tracked in `manifest.toml`. These two files mean that someone else can reinstate the exact environment you developed your code in by activating the project and issuing the `instantiate` command to the package manager. This will install the same versions of the packages and dependencies as listed in the `*.toml` files.\n\nEach project should be in its own folder, with its own `*.toml` files. This means different projects can potentially use different versions of the same package, depending on what other packages are in use.\n\nTo update the packages and dependencies to the latest versions (as allowed for by the specified versions of dependencies for each package), use the `up` command of the package manager. This updates packages for the **current** project only.\n\n## Using vs Import\n\nThere are two ways to load a Julia package: `using` and `import`\n\nIf you use `using`, all methods and variables exported by a package are brought into the current namespace. You can call them directly:\n\n``` julia\nusing Plots\n\nscatter(rand(10), rand(10))\n```\n\nThis does mean that several functions and variables you are not using are now also in the namespace and you cannot define a new function with the same name or use another package that exports a function with the same name. For those cases, you can use `import`. If a package is `import`ed, you need to prepend each function call with the package name.\n\n``` julia\nimport Plots\nimport GLMakie\n\nPlots.scatter(rand(10), rand(10))\nGLMakie.scatter(rand(10), rand(10))\n```\n\n::: callout-tip\n## Try this\n\nSee what happens when you use `using` for the previous example.\n:::\n\nYou can load specific functions or variables from a package:\n\n``` julia\nusing Plots: scatter\nimport GLMakie: lines\n```\n\nNone of the other exported variables or functions will become available. When loading a single item, you can also rename it using the `as` keyword:\n\n``` julia\nimport Plots.scatter as ps\nimport GLMakie: scatter as ms\n\nps(rand(10), rand(10))\nms(rand(10), rand(10))\n```\n\nor even rename the package during import:\n\n``` julia\nimport BenchmarkTools as bt\n\nbt.@benchmark sin.(1:1_000_000)\n# BenchmarkTools.Trial: 400 samples with 1 evaluation.\n#  Range (min … max):  11.751 ms … 24.278 ms  ┊ GC (min … max): 0.00% … 49.13%\n#  Time  (median):     12.043 ms              ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   12.515 ms ±  2.246 ms  ┊ GC (mean ± σ):  3.56% ±  9.50%\n\n#   ▆█▅\n#   ████▆▁▄▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▁▅▇▆ ▆\n#   11.8 ms      Histogram: log(frequency) by time        24 ms <\n\n#  Memory estimate: 7.63 MiB, allocs estimate: 2.\n```\n\n## Variables\n\nThere is no programming without variables. In Julia, there is no need to pre-declare a variable (although you can) and variables can be reassigned to a value of another type:\n\n``` julia\nx = 1\n# 1\n\ntypeof(x)\n# Int64\n\nx = 2.4\n# 2.4\n\ntypeof(x)\n# Float64\n\nx = \"Hello, World\"\n# \"Hello, World\"\n\ntypeof(x)\n# String\n```\n\nWhen assigning a value to the variable `x`, Julia infers the type of the value, e.g., `Int64` and then associates the name, `x`, with that value.\n\nAs illustrated, the function `typeof()` will return the type of the variable or value. While you don't have to specify the types of variables, Julia is a *strongly typed* language, just like C or Fortran. The type of a variable is just automatically inferred whenever possible.\n\nSince variables can be reassigned in the global scope, this makes it difficult for the compiler to generate optimised code - the type of the variable could change. If you want fast code, then avoid using global variables, or if you absolutely have to use them, declare them as `const`.\n\n``` julia\nconst MyConst = 1\n# 1\n\ntypeof(MyConst)\n# Int64\n\nMyConst = 2\n# WARNING: redefinition of constant MyConst. This may fail, cause incorrect answers, or produce other errors.\n# 2\n\nMyConst = 2.0\n# ERROR: invalid redefinition of constant MyConst\n# Stacktrace:\n#  [1] top-level scope\n#    @ REPL[4]:1\n```\n\nDeclaring a variable as `const` freezes the type of the variable, allowing more optimisations. It is possible, but not recommended, to change the value, but not the type. It is expected that changes to the values will also be prevented in future versions of Julia.\n\nThe best practice, however, is to put your code inside functions.\n\n### Strings and Characters\n\nText values are stored as either strings (`\"This is a string\"`, type `String`) or single characters (`'c'`, type `Char`). Note the use of double and single quotation marks for `String` vs `Char`. A string can be just one character long: `\"A\"`. Strings can also include multiple lines, and quotation marks, when enclosed with triple quotation marks:\n\n``` julia\ns = \"\"\"\n    This is my\n    very long\n    string with \"quotes\"\n\"\"\"\n# \"This is my \\nvery long\\nstring with \\\"quotes\\\"\\n\"  \n\ns[5]\n# ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n\ns[5:10]\n# \" is my\"\n```\n\nNote how new lines are indicated with `'\\n'`, which is itself a character (n is short for **n**ew line).\n\nNumerical values can be converted to strings using the `string()` function:\n\n``` julia\nstring(123)\n# \"123\"\n```\n\nStrings and characters in Julia are encoded in UTF-8 Unicode. This allows all kinds of characters, from mathematical symbols to Chinese characters and emojis to be used. It also means that not all *glyphs* take the same amount of memory to store. This can be confusing when processing strings. If you intend to work with strings, read the relevant sections of the [manual](https://docs.julialang.org/en/v1/manual/strings/#Unicode-and-UTF-8) carefully.\n\nA somewhat unintuitive feature of Julia is that string concatenation is done via the `*` operator. This does have the advantage that multiple copies of a string can be concatenated via the exponentiation (`^`) operator:\n\n``` julia\nstr = \"lala\"\n# \"lala\"\n\nstr*str\n# \"lalalala\"\n\nstr^5\n# \"lalalalalalalalalala\"\n```\n\nJulia includes a vast number of string processing functions. These are discussed in detail in the [manual](https://docs.julialang.org/en/v1/manual/strings/).\n\n#### String Interpolation\n\nYou can *interpolate* a value from a variable or expression into a string, using the `$` character:\n\n``` julia\nvalue = 1.0\n# 1.0\n\nkey = \"myvar\"\n# \"myvar\"\n\nprintln(\"The key is: $key and the value is: $value.\")\n# The key is: myvar and the value is: 1.0.\n\nprintln(\"Twice the value is: $(2*value)\")\n# Twice the value is: 2.0\n```\n\n### Integers and Floating-point Values\n\nJulia has the usual selection of variable types for integers and floating-point values. There are signed and unsigned versions of 8, 16, 32, 64 and 128-bit integers. See the [manual](https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/) for details.\n\nThere is also a `Bool` type that holds either `true` (1) or `false` (0).\n\nFor floating-point values, there is Float16, Float32 and Float64.\n\nThe default integer, `Int` is equivalent to `Int64` for 64-bit Julia and `Int32` for 32-bit Julia. Generally, you would want to use `Float64` for floating-point numbers, unless there is a specific reason not to. Calculations on a GPU (via e.g., `CUDA.jl`) should be done using `Float32`, unless you have a very expensive[^1] GPU capable of processing 64-bit floating point calculations.\n\n[^1]: An Nvidia Tesla A100 costs about US\\$7400 in mid-2023\n\n#### A Word on Floating-Point Values\n\nFloating-point values are stored in a limited number of bits (typically 64 bits - a.k.a. double precision) and hence have a limited precision. The result is that most values cannot be precisely stored in a `Float64` variable. As a simple example, 1/10, which is clearly precisely equal to 0.1, is actually calculated as 0.1000000000000000055511151231257827021181583404541015625 with 256-bit precision.\n\nThe smallest positive value that can be stored in a `Float64`, is 2.220446049250313e-16. You can calculate this in Julia using the `eps()` function e.g., `eps(Float64)`. The value epsilon is an indication of the precision you can expect. It is the smallest value you can add to the floating-point value that will cause it to result in a new value. Anything smaller may as well be zero. Obviously, epsilon depends on the magnitude of the values you are working with, and you can again use the `eps()` function: `eps(100) = 1.4210854715202004e-14`, so adding a smaller amount to 100 will not change the value.\n\nWhile you can safely ignore this for many, if not most engineering calculations, it can sometimes become an issue when you least expect it. Consider adding up a very large number of small values. The larger the difference between the running total and the next value you are adding, the larger the rounding error will become. At some point in this exercise, the value you are adding to the running total will be in the order of the relative epsilon and the running total will stop increasing, no matter how many more values you add. The solution to this is actually fairly simple and implemented in the Julia `sum()` function.\n\nThe list of values is split into pairs and the pairs are added to each other, then this is repeated over and over until there is only one value left - the answer. The algorithm works under the inherent assumption that the values are fairly equally sized and so adding similar values results in minimal rounding error. Once the pairs have been summed, the new values should also be similarly sized and so the process repeats, with a minimum rounding error at each step.\n\nSomething else to consider, which much more often trips up new programmers, is that you will very rarely find two identical floating-point values through calculations. Directly comparing values that are realistically speaking equal, will very often result in the wrong part of an `if` statement executing. When comparing floating-point values, always use a check for approximate equality. This is done either via the `≈` operator (`\\approx<tab>`), or the `isapprox()` function, which allows you to specify absolute and relative tolerances. The `≈` operator calls `isapprox()` with default tolerances.\n\nThe internal storage of floating-point values is standardised by the [IEEE 754](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) standard, which is used in just about every programming language. This is important, since it means you can pass values between Julia and code running in R or Python or compiled in C.\n\n### BigInt and BigFloat\n\nSometimes, you may find a need for additional precision. Arbitrary-precision integer and floating-point types are available as BigInt and BigFloat.\n\nThere are several ways to specify that you are using `big` numbers, but the simplest is via the `big()` function:\n\n``` julia\nx = big(10.0)\n# 10.0\n\ntypeof(x)\n# BigFloat\n```\n\nThe precision again comes at the cost of performance. See the [manual](https://docs.julialang.org/en/v1/base/numbers/#BigFloats-and-BigInts) for more details. You only need to specify that one variable/number in a calculation is `big` - the rest will be converted automatically by Julia.\n\n### Complex Numbers\n\nJulia has built-in types for complex numbers, which depend on the integer or floating-point type used to store the real and imaginary parts, e.g.\n\n``` julia\ntypeof(1 + 2im)\n# Complex{Int64}\n\ntypeof(1.0 + 2.0im)\n# ComplexF64 (alias for Complex{Float64})\n```\n\nAs you will notice, a complex type is specified as `Complex{T}` where T is an integer or floating-point type. Any of the integer and floating-point types mentioned before could be used, including `BigInt` and `BigFloat`. Simply define the value as:\n\n``` julia\nz = big(10.0) + 1.0im\n# 10.0 + 1.0im\n\ntypeof(z)\n# Complex{BigFloat}\n\nz = big(10) + im\n# 10 + 1im\n\ntypeof(z)\n# Complex{BigInt}\n```\n\nThe imaginary part of the number is indicated by adding `im` directly behind the number - no space! As shown in the example, the `1` is optional in the imaginary part - you can just specify `im` for `1im`.\n\nThe expected functions for use with complex numbers are available, including:\n\n``` julia\nz = 1 + 1im\n# 1 + 1im\n\nreal(z) # real part\n# 1\n\nimag(z) # imaginary part\n# 1\n\nconj(z) # complex conjugate\n# 1 - 1im\n\nabs(z) # absolute value - distance from zero\n# 1.4142135623730951\n\nabs2(z) # squared absolute value\n# 2\n\nangle(z) # phase angle (radians)\n# 0.7853981633974483\n\nangle(z) * 360/2π # convert to degrees\n# 45.0\n\n√z\n# 1.09868411346781 + 0.45508986056222733im\n\nsqrt(z)\n# 1.09868411346781 + 0.45508986056222733im\n```\n\n### Rational Numbers\n\nYou can also work with rational numbers.\n\n``` julia\na = 1//2 + 3//8\n# 7//8\n\nfloat(a)\n# 0.875\n\nrationalize(0.875)\n# 7//8\n```\n\nThis eliminates rounding losses, but at a loss of performance:\n\n``` julia\nfunction myfunc(x)\n    sum = zero(x)\n    for i in 1:10_000\n        sum += x * i\n    end\n    return sum\nend\n\n# myfunc (generic function with 1 method)\n\nusing BenchmarkTools\n\n@benchmark myfunc(1.0)\n# BenchmarkTools.Trial: 10000 samples with 3 evaluations.\n#  Range (min … max):  8.500 μs …  73.733 μs  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     8.700 μs               ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   8.704 μs ± 966.620 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#   ▅  █  ▆  ▃         █  █   ▅  ▂  ▁   ▁  ▁                    ▂\n#   █▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁█▁▁▁▇▁▁█▁▁▇▁▁▄ █\n#   8.5 μs       Histogram: log(frequency) by time       9.1 μs <\n\n#  Memory estimate: 0 bytes, allocs estimate: 0.\n\n@benchmark myfunc(1//1)\n# BenchmarkTools.Trial: 7295 samples with 1 evaluation.\n#  Range (min … max):  663.600 μs …  1.234 ms  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     680.100 μs              ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   682.504 μs ± 29.021 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#   ▇█▆▃▂▃██▅▄▃▃▃▂▃▁▁▁▁       ▁                                  ▂\n#   ███████████████████████▇▇████▇▇█▆▆▇▇▇▅▆▆▅▆▅▅▅▃▅▅▄▆▅▃▅▅▄▄▁▃▃▅ █\n#   664 μs        Histogram: log(frequency) by time       811 μs <\n\n#  Memory estimate: 0 bytes, allocs estimate: 0.\n```\n\nSo, floating-point calculations are about 78x faster than with rational numbers. What about integers?\n\n``` julia\n@benchmark myfunc(1)\n# BenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n#  Range (min … max):  1.900 ns … 27.200 ns  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     2.000 ns              ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   1.976 ns ±  0.530 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#   ▄                                                        █\n#   █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▂\n#   1.9 ns         Histogram: frequency by time           2 ns <\n\n#  Memory estimate: 0 bytes, allocs estimate: 0.\n```\n\n1.9 nanoseconds?!? That sounds too good to be true, doesn't it? Let's see what type of code Julia generated to make that possible.\n\n``` julia\n@code_llvm myfunc(1)\n\n;  @ REPL[6]:1 within `myfunc`\n; Function Attrs: uwtable\ndefine i64 @julia_myfunc_739(i64 signext %0) #0 {\ntop:\n;  @ REPL[6]:3 within `myfunc`\n  %1 = mul i64 %0, 50005000\n;  @ REPL[6]:6 within `myfunc`\n  ret i64 %1\n}\n```\n\nWe can again ignore any line starting with a semi-colon. The one line that matters is this:\n\n``` julia\n  %1 = mul i64 %0, 50005000\n```\n\nThe Julia compiler could analyse the code well enough to see that the answer to our function is simply 50005000 times the input value and that is exactly what it returned!\n\nWith floating-point and rational values, there were type conversions required before multiplying the integer value of the loop counter with the input value. This \"hid\" the true nature of the calculation enough that the compiler could not see the short-cut. There is however continuous development in the compiler, and we can reasonably expect this to also be optimised in a future version of Julia.\n\n### Arrays, Tuples and Ranges\n\n#### Arrays\n\nIn most code, you will find it convenient to deal with a collection of values at the same time. There are several ways of doing this.\n\nThe most common collection of values is an Array. In mathematics, you will be familiar with *vectors* and *matrices*. These are simply one- and two-dimensional arrays. You can have arrays with any number of dimensions (*tensors*). The keywords `Vector` and `Matrix` are also available as synonyms for `Array` in the special cases of one and two dimensions.\n\n::: callout-note\nSimple one-dimensional arrays are treated as **column vectors** for use in linear algebra calculations.\n:::\n\nSome examples:\n\n``` julia\na = [1, 2, 3]   # use commas to specify column vectors\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nb = [1 2 3]   # use spaces to specify row vectors\n# 1×3 Matrix{Int64}:\n#  1  2  3\n\na * b \n# 3×3 Matrix{Int64}:\n#  1  2  3\n#  2  4  6\n#  3  6  9\n\nA = [1 2 3;   # directly specify a 2D array a.k.a. a matrix\n     4 5 6;\n     7 8 9]\n# 3×3 Matrix{Int64}:\n#  1  2  3\n#  4  5  6\n#  7  8  9\n\nB = zeros(3, 3, 3)   # zeros() and ones() fill the array of the specified size\n# 3×3×3 Array{Float64, 3}:\n# [:, :, 1] =\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n\n# [:, :, 2] =\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n\n# [:, :, 3] =\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0 \n\nC = zeros(Int64, 2, 2) # You can specify the type - Float64 is the default\n# 2×2 Matrix{Int64}:\n#  0  0\n#  0  0\n\nD = [1;2;;3;4;;;5;6;;7;8;;;9;10;;11;12]  # ; separates in first dimension, ;; in second dimension, ;;; in third etc.\n# 2×2×3 Array{Int64, 3}:\n# [:, :, 1] =\n#  1  3\n#  2  4\n\n# [:, :, 2] =\n#  5  7\n#  6  8\n\n# [:, :, 3] =\n#   9  11\n#  10  12\n\nE = Float64[]   # an empty 1D array of Float64\n# Float64[]\n```\n\nThe individual entries of an array are accessed via `[]`, e.g.,\n\n``` julia\nA[2, 3]\n# 6\n```\n\nIn the background, `[]` calls `getindex()` and `setindex()` to retrieve or modify the entries of the array. If you define your own array-like type, you will need to supply the appropriate `getindex()` and `setindex()` functions.\n\nYou can concatenate arrays horizontally and vertically with `hcat()` and `vcat()`, or using the syntax above with spaces or semi-colons:\n\n``` julia\nA = [1, 2, 3]\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nB = [4, 5, 6]\n# 3-element Vector{Int64}:\n#  4\n#  5\n#  6\n\n[A; B]\n# 6-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n#  6\n\n[A B]\n# 3×2 Matrix{Int64}:\n#  1  4\n#  2  5\n#  3  6\n\nvcat(A, B)\n# 6-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n#  6\n\nhcat(A, B)\n# 3×2 Matrix{Int64}:\n#  1  4\n#  2  5\n#  3  6\n```\n\n#### Tuples\n\nTuples are functionally similar to arrays. They are specified with commas and (optional) parentheses. They are intimately linked with passing parameters to functions and returning values from functions, e.g.\n\n``` julia\nfunction myfunc(a, b)\n    return a*b, a+b\nend\n# myfunc (generic function with 1 method)\n\nmyfunc(1, 2)\n# (2, 3)\n\ntypeof(myfunc(1, 2))\n# Tuple{Int64, Int64}\n```\n\nWe pass the parameters to the function as a tuple, (a, b). The results are returned as a tuple, (2, 3). Other than passing parameters to functions, what is the use of tuples? They are fairly widely used in Julia. The main differences from arrays are that while arrays are heap-allocated, tuples are stack-allocated. This is some more computer jargon, but what it means in practise is that tuples can be accessed faster than arrays but cannot be as large.\n\nTuples are also *immutable*, meaning once created, they cannot be modified. The entries of an array can always be modified. This is important to keep in mind when writing functions in Julia. The only way you can modify a parameter passed to a function is if that parameter is an array. And then only the individual entries of the array can be changed - you cannot replace the array with another one (more detail later).\n\nSome examples:\n\n``` julia\na = (1, 2, 3)\n# (1, 2, 3)\n\ntypeof(a)\n# Tuple{Int64, Int64, Int64}\n\nb = (1., 2., 3, 1//2)\n# (1.0, 2.0, 3, 1//2)\n\ntypeof(b)\n# Tuple{Float64, Float64, Int64, Rational{Int64}}\n\na[2]\n# 2\n\nc = (1,) # A tuple with only one value - note the trailing comma!\n# (1,)\n\ntypeof(c)\n# Tuple{Int64}\n\nd = 1,2,3  # the parentheses are optional\n# (1, 2, 3)\n\ntypeof(d)\n# Tuple{Int64, Int64, Int64}\n```\n\nWe again use `[]` to access the individual entries.\n\n``` julia\na = (1, 2, 3)\n# (1, 2, 3)\n\na[2]\n# 2\n```\n\nTuples can be unpacked into variables:\n\n``` julia\na\n# (1, 2, 3)\n\nx, y, z = a\n# (1, 2, 3)\n\nx\n# 1\n\ny\n# 2\n\nz\n# 3\n```\n\nAnd since the parentheses are optional in the direct specification of tuples, we can do this:\n\n``` julia\nx = 1\n# 1\n\ny = 2\n# 2\n\ny, x = x, y\n# (1, 2)\n\nx\n# 2\n\ny\n# 1\n```\n\nHere we defined a tuple `(x, y)` and then unpacked it into the variables `y` and `x`, swapping their values.\n\nSince tuples have superior performance to arrays, there exists a package that builds small arrays-like structures from tuples - [`StaticArrays.jl`](https://github.com/JuliaArrays/StaticArrays.jl). This is commonly used for maximum performance, but only for smallish arrays, typically less than 200-300 entries. More than that and you run out of space on the stack, which has a limited size.\n\n#### Named Tuples\n\nYou can also name the entries in a tuple and access them via the names instead of indexes:\n\n``` julia\nnt = (a = 1, b = 2, c = \"Bob\")\n# (a = 1, b = 2, c = \"Bob\")\n\ntypeof(nt)\n# NamedTuple{(:a, :b, :c), Tuple{Int64, Int64, String}}\n\nnt.a\n# 1\n\nnt[2]\n# 2\n\nnt.c\n# \"Bob\"\n\nnt.c === nt[3] # The values are \"egal\", i.e. not just equal, but the actual same bits in memory\n# true\n```\n\nNote that the entries in a tuple or named tuple needn't be all of the same type. This is also true for arrays, but in that case the array will be of type `Any` and performance will be hugely impacted. **Avoid this whenever possible!**\n\n#### Ranges\n\nThe third collection type we are considering are ranges. There are several ways to specify a range:\n\n``` julia\na = 1:10   # start : stop with default step of one, hence a unit range\n# 1:10\n\ntypeof(a)\n# UnitRange{Int64}\n\nb = 1:2:20   # start : step : stop, hence a step range\n# 1:2:19\n\ntypeof(b)\n# StepRange{Int64, Int64}\n\nc = 1.0:0.5:5.0 # with floating-point steps, we get a StepRangeLen\n# 1.0:0.5:5.0\n\ntypeof(c)\n# StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}\n\nd = range(2.0, step=5.3, length=5)  # instead of colon notation, you can call the function with more options\n# 2.0:5.3:23.2\n\ntypeof(d)\n# StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}\n```\n\n::: callout-note\nThe `Base.TwicePrecision{Float64}` part may be confusion. Directly from the Julia help (type `?Base.TwicePrecision` at the REPL prompt:\n\n> *TwicePrecision is an internal type used to increase the precision of floating-point ranges, and not intended for external use. If you encounter them in real code, the most likely explanation is that you are directly accessing the fields of a range. Use the function interface instead, step(r) rather than r.step*\n:::\n\nAnd just like before, we access the entries with `[]`:\n\n``` julia\na[2]\n# 2\n\nb[3]\n# 5\n\nc[4]\n# 2.5\n\nd[5]\n# 23.2\n```\n\nThe main difference is that, while arrays and tuples consist of values stored in memory, ranges are *lazy*. The values are only calculated when they are requested and no matter the length of the range, it takes up the same amount of memory - just enough to store the *start*, *step* and *stop*/*length* values that are needed to calculate any entry and know when you have run through the whole range.\n\nYou can change a range into an array, with the `collect()` function:\n\n``` julia\ncollect(1:10)\n# 10-element Vector{Int64}:\n#   1\n#   2\n#   3\n#   4\n#   5\n#   6\n#   7\n#   8\n#   9\n#  10\n```\n\n#### Iterables\n\nArrays, tuples and ranges (and strings) are all iterable types, meaning you can iterate through their entries:\n\n``` julia\na = [1, 5, 10]\n# 3-element Vector{Int64}:\n#   1\n#   5\n#  10\n\nfor i in a\n    println(i)\nend\n# 1\n# 5\n# 10\n\nfor j in 1:3\n    println(j*2)\nend\n# 2\n# 4\n# 6\n\nt = (1, 2, 3)\n# (1, 2, 3)\n\nfor k in t\n    println(k)\nend\n# 1\n# 2\n# 3\n```\n\n::: callout-note\nYou can also use the Unicode symbol ∈ (`\\in<tab>`) in place of the word `in`.\n:::\n\nFrom a programmer's point of view, iterable types all behave the same. We can therefore write a function that can handle any iterable type. The only requirement for this example is that the item passed should have at least two entries, or there will be an error.\n\n``` julia\nfunction mycomp(a)\n    if a[1] > a[2]\n        return true\n    else\n        return false\n    end\nend\n# mycomp (generic function with 1 method)\n\nar = [1, 2]\n# 2-element Vector{Int64}:\n#  1\n#  2\n\nt = (2, 1)\n# (2, 1)\n\nr = 10:-1:1\n# 10:-1:1\n\nmycomp(ar)\n# false\n\nmycomp(t)\n# true\n\nmycomp(r)\n# true\n```\n\nFor each case, the Julia compiler will generate optimised code depending on the type of the variable passed.\n\n#### Indexing\n\nIn the examples above, we used one-dimensional arrays and there was really no choice in how to index into the structure. The entries are all in a row in memory.\n\nIn the case if multi-dimensional arrays, the entries are still sequential in memory - that is how RAM works! Here, however, there are better and worse options for accessing a given entry in the array.\n\nThis is because of how the values are stored in memory. It is faster to sequentially access values that are stored next to each other than to jump around in memory. Julia is *column major*, meaning that the values in the first column of a matrix are stored next to each other in memory, followed by the values of the second column etc. For higher dimensions, the sequence is similar: each subsequent index follows the next. This is then the fastest way of iterating through the whole array.\n\n``` julia\nA = rand(10_000, 10_000);  # the _ is ignored - it is just to make reading easier. The ; at the end suppresses output of the result\n\nfunction myfunc(A)\n    mysum = 0.0\n    m, n = size(A)\n    for i = 1:m, j = 1:n  # we are running through the matrix a row at a time\n        mysum += A[i, j]\n    end\n    return mysum\nend\n# myfunc (generic function with 1 method)\n\nfunction myfunc2(A)\n    mysum = 0.0\n    m, n = size(A)\n    for j = 1:n, i = 1:m  # we are running through the matrix a column at a time\n        mysum += A[i, j]\n    end\n    return mysum\nend\n# myfunc2 (generic function with 1 method)\n\nusing BenchmarkTools\n\n@btime myfunc(A)\n#   644.754 ms (1 allocation: 16 bytes)\n# 4.99959369384022e7\n\n@btime myfunc2(A)\n#   94.296 ms (1 allocation: 16 bytes)\n# 4.999593693838226e7\n```\n\nSo, in our 10,000 x 10,000 random matrix, summing up the values row-wise takes 644.754ms, while column-wise it takes only 96.449ms. Quite the improvement! If you are worried you won't remember the correct way of iterating through a structure, Julia has you covered. Use `eachindex()` to get the optimal sequence:\n\n``` julia\nfunction myfunc3(A)\n    mysum = 0.0\n    m, n = size(A)\n    for i in eachindex(A)\n        mysum += A[i]\n    end\n    return mysum\nend\n# myfunc3 (generic function with 1 method)\n\n@btime myfunc3(A)\n#   96.394 ms (1 allocation: 16 bytes)\n# 5.000090241950418e7\n```\n\n`eachindex()` returns a linear index, no matter what the dimensionality of the array is and sequences it for the fastest sequential access.\n\nAnother useful indexing function is `enumerate()`. It returns an iterator of tuples, each containing an index and value pair. The indexes are linear, not cartesian.\n\n``` julia\nA = rand(2,2)\n# 2×2 Matrix{Float64}:\n#  0.488632  0.177813\n#  0.221677  0.559213\n\nfor (index, value) in enumerate(A)\n    println(\"$index $value\")\nend\n# 1 0.4886321057630626\n# 2 0.22167740760406662\n# 3 0.17781317540395236\n# 4 0.5592126504604934\n```\n\nFor more information, see the [manual](https://docs.julialang.org/en/v1/base/iterators/#Base.Iterators.enumerate).\n\n::: callout-note\nJulia also provides the keywords `begin` and `end` to directly index the first and last entries in an array:\n\n``` julia\na = [1, 2, 3]\n# 3-element Vector{Int64}: …\n\na[begin]\n# 1\n\na[end]\n# 3\n\na[end-1] # second last entry\n# 2\n```\n:::\n\n#### Array Assignments\n\nThe array variable is a pointer[^2] that holds the address of the memory space where the contents is kept (on the heap). This is not an implementation detail - it is an important thing to keep in mind, as there is a difference between modifying the entries of the array (the values in the memory the array variable points to) and changing the array variable (which memory it points to):\n\n[^2]: A pointer is just a memory address - computer guys like their jargon.\n\n``` julia\na = collect(1:5)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = a\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb[2] = -1\n# -1\n\na\n# 5-element Vector{Int64}:\n#   1\n#  -1\n#   3\n#   4\n#   5\n\na[2] = 10\n# 10\n\nb\n# 5-element Vector{Int64}:\n#   1\n#  10\n#   3\n#   4\n#   5\n```\n\nHere we created an array variable, `a`. Then we assigned `a` to `b`. The result is a new array variable that **points to the same memory space**. If we change the contents of `b`, we also change the contents of `a`, and vice versa.\n\nIf you want an independent copy of `a`, then use the `copy()` function:\n\n``` julia\na = collect(1:5)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = copy(a)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb[2] = -1\n# -1\n\na\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb\n# 5-element Vector{Int64}:\n#   1\n#  -1\n#   3\n#   4\n#   5\n```\n\n#### Array Comprehensions\n\nThis is a quick, flexible way of creating arrays with specific values, best illustrated by example:\n\n``` julia\na = [sin(i^2) for i in 0:0.1:2π]\n# 63-element Vector{Float64}:\n#   0.0\n#   0.009999833334166666\n#   0.03998933418663417\n#   0.08987854919801107\n#   0.159318206614246\n#   0.24740395925452294\n#   ⋮\n#   0.7940962483324946\n#  -0.24980688359658182\n#  -0.9917788534431158\n#  -0.4698420526176865\n#   0.6749435215575963\n\n[1/(x+y) for x in 1:3, y in 1:3]\n# 3×3 Matrix{Float64}:\n#  0.5       0.333333  0.25\n#  0.333333  0.25      0.2\n#  0.25      0.2       0.166667\n\n[1/(x+y) for x in 1:3 for y in 1:3] # A second `for` keyword and no comma!\n# 9-element Vector{Float64}:\n#  0.5\n#  0.3333333333333333       \n#  0.25\n#  0.3333333333333333\n#  0.25\n#  0.2\n#  0.25\n#  0.2\n#  0.16666666666666666 \n```\n\nTake note of the subtle difference between the second and third examples. This is not terribly intuitive!\n\n#### Broadcasting\n\nYou can process each entry in an iterable in a loop, or you can use the built-in broadcasting (a.k.a. dot notation). The following are equivalent:\n\n``` julia\na = collect(1:5) # create an array\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = 2:2:10 # create a range\n# 2:2:10\n\nc = similar(a) # create an uninitialised array with the same size and type as a\n# 5-element Vector{Int64}:\n#                0\n#  140734236573968\n#  140734236545296\n#                0\n#                0\n\nfor i in 1:length(a)\n    c[i] = a[i] + b[i]\nend\n\nc\n# 5-element Vector{Int64}:\n#   3\n#   6\n#   9\n#  12\n#  15\n\nd = a .+ b # element-wise addition\n# 5-element Vector{Int64}:\n#   3\n#   6\n#   9\n#  12\n#  15 \n\ne = sqrt.(d) # works for any function (note the . is between the name and the open parenthesis)\n# 5-element Vector{Float64}:\n#  1.7320508075688772\n#  2.449489742783178\n#  3.0\n#  3.4641016151377544\n#  3.872983346207417\n```\n\n### The Type Hierarchy\n\nThe built-in types have a hierarchy:\n\n![The type hierarchy - Image from https://thautwarm.github.io/](https://thautwarm.github.io/Site-32/_images/julia-type-hierarchy.png)\n\nThis consists of abstract and concrete types. You can only instantiate a variable of a concrete type, but the abstract types are useful to specify groups of types that would behave similarly, e.g., `Float64` and `Int64` could both the added and multiplied. This is true for all the `Number` types, be they `Real` or `Complex`. We could specify allowed groups of types, via the `<:` operator, or specific types, via `::`, e.g.\n\n``` julia\nfunction f(x::T) where T <: Number\n    #do something\nend\n```\n\nHere, Julia will allow us to call f(x) with any sub-type of the `Number` abstract type, such as `Float64`, `Int32` or `ComplexF64`. Calling f(x) with a `String` type will give an error, rather than try to compile a specialised version of `f()`.\n\nWe can also use this to have alternative versions of a function for different types of inputs, via multiple dispatch:\n\n``` julia\nfunction addthem(a::T, b::S) where {T<:Number, S<:Number}\n    return a + b\nend\n\nfunction addthem(a::T, b::T) where T<:AbstractString\n    return a * b\nend\n\naddthem(1, 2)\n#3\n\naddthem(2, 2.0)\n#4.0\n\naddthem(\"One\", \"Two\")\n#OneTwo\n```\n\n::: callout-note\nNote that in the first function we use T and S, both sub-types of `Number`. If both variables where `T<:Number`, then calling the function with an integer and a floating point value - the second example - would have given an error, as the two variables are not of the same type.\n\nWe also used `AbstractString` for the second function, so any type that acts like a `String` should work, as long as they have the `*` operator defined.\n:::\n\n### Structs\n\nStructs are use-defined complex types that can contain multiple fields. They are defined using the `struct` keyword:\n\n``` julia\nstruct PersonData\n    name::String\n    address::String\n    ID::Int64\nend\n\ncustomers = PersonData[] # empty array of PersonData structs\n# PersonData[]\n\ntypeof(customers)\n# Vector{PersonData} (alias for Array{PersonData, 1})\n\nbob = PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456) # create a variable of type PersonData by calling the constructor\n# PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\npush!(customers, bob) # push an entry into the array - will increase the length by one\n# 1-element Vector{PersonData}:\n#  PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\ncustomers[1]\n# PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\nbob.name # access the values via the field names\n# \"Robert Smith\"\n\ncustomers[1].name\n# \"Robert Smith\"\n```\n\nBy default, a `struct` is immutable, meaning it cannot be changed once created:\n\n``` julia\nbob.name = \"Joe Bloggs\"\n# ERROR: setfield!: immutable struct of type PersonData cannot be changed\n# Stacktrace:\n#  [1] setproperty!(x::PersonData, f::Symbol, v::String)\n#    @ Base .\\Base.jl:39\n#  [2] top-level scope\n#    @ REPL[31]:1\n```\n\nTo make a `struct` mutable, simply add the keyword `mutable` to the definition.\n\n``` julia\nmutable struct PersonData2\n    name::String\n    address::String\n    ID::Int64\nend\n\nbob = PersonData2(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n# PersonData2(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\nbob.name\n# \"Robert Smith\"\n\nbob.name = \"Joe Bloggs\"\n# \"Joe Bloggs\"\n\nbob\n# PersonData2(\"Joe Bloggs\", \"2 Cypress Lane\", 123456)\n```\n\nThe `struct` is immutable by default to allow additional compiler optimisations. Mutable structs will therefore have worse performance, but more flexibility.\n\n#### Constructors\n\nJulia automatically creates a *constructor* for each struct you define. This is a function that takes the values of the fields, creates a new structure in memory and assigns the specified values to the fields.\n\nYou can also create additional constructors. There are two types:\n\n-   Outer constructors and\n-   Inner constructors\n\nThe default constructor is an outer constructor. You can also specify additional outer constructors that e.g., have default values for some fields, or calculate some values from others:\n\n``` julia\nstruct PersonData\n    name::String\n    address::String\n    ID::Int64\nend\n\nbob = PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n# PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\nfunction PersonData(name, ID)\n    # Call the default constructor to do the allocations and assignments\n    PersonData(name, \"No known address\", ID) \nend\n# PersonData\n\nsally = PersonData(\"Sally Jones\", 123)\n# PersonData(\"Sally Jones\", \"No known address\", 123)\n\nsally.address\n# \"No known address\"\n\ntom = PersonData(\"Tom Jones\", \"Las Vegas\", 34556) # The default is still available\n# PersonData(\"Tom Jones\", \"Las Vegas\", 34556\n```\n\nInner constructors are defined as part of the `struct` definition and are used to validate the entries for the struct before creating the instance.\n\n``` julia\nstruct OnlyNegatives\n    val::Float64\n    OnlyNegatives(val) = val > 0 ? error(\"Non-negative value!\") : new(val)\nend\n\nOnlyNegatives(-1)\n# OnlyNegatives(-1.0)\n\nOnlyNegatives(1)\n# ERROR: Non-negative value!\n# Stacktrace:\n#  [1] error(s::String)\n#    @ Base .\\error.jl:35\n#  [2] OnlyNegatives(val::Int64)\n#    @ Main .\\REPL[7]:3\n#  [3] top-level scope\n#    @ REPL[9]:1\n```\n\nInner constructors have access to a special local function, `new()`, which acts like the default outer constructor would.\n\n::: callout-important\nIf you define an inner constructor, **NO** default constructors are created. You need to handle all cases via your inner constructors.\n:::\n\n## Loops\n\nJulia provides two types of loops:\n\n1.  `for` loops for iterating over an iterable construct, like a range or array with a known length\n2.  `while` loops for iterating until a logical criterium is met, with an initially unknown number of iterations\n\n``` julia\na = zeros(5)\n# 5-element Vector{Float64}:\n#  0.0\n#  0.0\n#  0.0\n#  0.0\n#  0.0\n\nfor i in 1:length(a)\n    a[i] = 2*i^2\nend\n\na\n# 5-element Vector{Float64}:\n#   2.0\n#   8.0\n#  18.0\n#  32.0\n#  50.0\n\nwhile a[i] <= 10\n    println(i, \"\\t\", a[i])\n    i += 1\nend\n# 1       2.0\n# 2       8.0\n```\n\nIn a `while` loop, it is critical to manually implement a step (`i += 1` in the example), or the loop will execute indefinitely!\n\n## Logic and Flow Control\n\nAt some point in your code, you will want to execute different instructions depending on some criteria. The most basic form of flow control is the `if` statement:\n\n``` julia\nif a < 0\n    println(\"Negative\")\nelseif a == 0\n    println(\"Zero\")\nelse\n    println(\"Positive\")\nend\n```\n\nThe `elseif` and `else` blocks are optional. You can have multiple `elseif` blocks with different criteria. You can also nest `if` statements. The `end` statement is a requirement. Unlike many other languages, there is no `then` keyword (`if`...`then`...`else`...`end`).\n\nJulia also offers a short-cut alternative for for simple `if` statements. The following two statements will both print the value `Negative` if `a < 0`.\n\n``` julia\na < 0 && println(\"Negative\")\na >= 0 || println(\"Negative\")\n```\n\nThis looks a little arcane. It works as follows:\n\nThe `&&` operator is a logical `and`. For an `and` statement to be true, both criteria must be true, so if the first statement (before the `&&`) is false, Julia won't bother to evaluate the second statement (after the `&&`), since the whole cannot be true. This is called *short-circuiting evaluation*. This means the `println()` is only executed if `a` is indeed less than zero.\n\nThe `||` operator is a logical `or`. For an `or` statement to be true, either of the two criteria must be true, so if the first statement is true, there is no need need to also evaluate the second - the whole is already true. The `println()` will therefore not be executed if `a` is larger than or equal to zero.\n\n::: callout-tip\nTo help you remember how *short-circuiting evaluations* work, try this:\n\n`a < 0 && println(\"Negative\")` reads as `a < 0` AND then `println()`\n\n`a >= 0 || println(\"Negative\")` reads as `a >= 0` OR else `println()`\n:::\n\nYou may very well choose to stick to more readily understandable `if` statements in your code, but these *short-circuit* notations are commonly used and you will encounter them often in other people's code\n\nFinally, when you are only assigning values to a variable based on some criterium, there is the so-called *ternary operator*:\n\n``` julia\na\n# -1\n\nb = a > 0 ? \"Positive\" : \"Not positive\"\n# \"Not positive\"\n```\n\nThese can be nested as well:\n\n``` julia\nb = a > 0 ? \"Positive\" : (a == 0 ? \"Zero\" : \"Negative\")\n# \"Negative\"\n```\n\nThe parentheses around the final statement are optional, but significantly improves readability.\n\n## Functions\n\nFunctions are the core of any Julia program. Inputs are passed as parameters and any number and type of values can be returned as a tuple. You can also modify the values of array parameters passed to the function. In this case, the function is called *mutating* and it is accepted practise in Julia to end the function name with an exclamation mark (or a bang, if you are American), to indicate that the function mutates one or more parameters. Typically, it would be the first parameter that is mutated.\n\n::: callout-note\nMost people use the terms *parameter* and *argument* interchangeably as they refer to functions. If you want to be strictly formal, then a function is defined to accept *parameters* and you pass specific *argument* values when you call the function. Here, we won't be formal - feel free to use either term.\n:::\n\nThere are four ways to declare a function:\n\n1.  Full declaration\n\n``` julia\nfunction myfunc(a, b)\n    return a + b\nend\n```\n\nThe keyword `return` is optional, but it significantly improves readability. In the absence of a `return` statement, Julia will return the last calculated result. You can also have multiple `return` statements in, e.g., an `if` block. When a `return` is executed (evaluated in Julia parlance), the function will return the specified value and exit.\n\n2.  Short-cut for single-line functions\n\n``` julia\nmyfunc(a, b) = a + b\n```\n\n3.  Anonymous functions, typically used when passing a single-use function to a higher-level function (a function that takes another function as input)\n\n``` julia\nmysum = sum(x -> x^2 + √x, somearray)\n```\n\nHere Julia will apply the function `x -> x^2 + √x` to each entry in the array `somearray` and then add up the results.\n\nYou technically can pass only one parameter to an anonymous function, but since that parameter can be a tuple (and tuples can contain scalars. arrays or even other tuples), there is practically no limit to the number of parameters passed, e.g.\n\n``` julia\nf = (x, y) -> 2x/y^2\n```\n\nHere we also assign the result of the function definition to a variable, `f`, which means we can later call `f(x, y)`. There is really no reason to do this. Rather use the short-cut function definition above.\n\n4.  Do blocks (similar to anonymous functions, but for multi-line functions)\n\n``` julia\nopen(\"myfile.txt\", \"w\") do io\n    write(io, \"Hello world!\")\nend\n```\n\nHere, there are a few things to pay attention to:\n\n-   We are calling the higher-level function `open()`, which takes another function as its first parameter. The `do` block **ALWAYS** passes the specified (anonymous) function to the first parameter of the calling function. The nominal syntax for `open()` is `open(f::Function, args...; kwargs...)`. The function, `f` is specified by the `do` block.\n-   We pass the parameter `io` to the function be specifying `io` next to the keyword `do`. This is similar to the `x -> ...` in an anonymous function, here we effectively have `io -> ...`\n\n### Passing Values to Functions and Returning Results\n\nIn all of the examples so far, we have passed values to the functions. These values are called *parameters* or *arguments*[^3] and there are two types of parameters in Julia: positional parameters and keyword arguments.\n\n[^3]: See the previous comment on this - the terms are often used interchangeably\n\n#### Positional parameters\n\nPositional parameters are parameters where Julia knows which local (to the function) variable to assign the value to, based on the parameter's position in the list of arguments. If we have a function `f(x, y)`, and we call it with `f(1, 2)`, Julia will assign the value of 1 to `x` and 2 to `y`.\n\nPositional parameters can have default values: `f(x, y=2)`. We can now either call the function with `f(2, 4)`, in which case `x` will be assigned a value of 2 and `y` a value of 4, or we can omit the value for `y` and call `f(2)`, in which was `x` will be assigned a value of 2 and `y` will use its default value, also 2.\n\nMultiple parameters can have default values, e.g. `f(x, y=2, z = 3)`. If we now call `f(2)`, `y` and `z` use their default values. What happens when we call `f(2, 10)`?\n\n``` julia\nfunction f(x, y=2, z=4)\n    println(x)\n    println(y)\n    println(z)\nend\n\nf(2)\n# 2\n# 2\n# 4\n\nf(2, 10)\n# 2\n# 10\n# 4\n```\n\nWe see that the second value is passed to `y`, since it is the second positional parameter. Positional values are always assigned left to right, then default values are used for what is left. So how would we pass values for `x` and `z` and have `y` use its default value? The answer is keyword arguments.\n\n#### Keyword arguments\n\nKeyword arguments (a.k.a. keyword parameters, a.k.a. *kwargs*[^4]) are identified by name when passing values to a function. To define them, we first list the positional parameters, then a semi-colon, then the keyword arguments. Keyword arguments **must** all have default values assigned to them.\n\n[^4]: In the spirit of computer science (and technical fields in general) the least understandable option - kwargs - is also the most used one. Go figure.\n\n``` julia\nfunction f(x; y=2, z=4)\n    println(x)\n    println(y)\n    println(z)\nend\n\nf(2)\n# 2\n# 2\n# 4\n```\n\nSo, as expected, `y` and `z` are using their default values. We can now decide to override the defaults for `y`, `z` or both:\n\n``` julia\nf(2, z=3)\n# 2       \n# 2\n# 3\n\nf(2, y=5, z=10)\n# 2\n# 5\n# 10\n```\n\nSince `x` is a positional parameters, a value must always be passed for it, or we get an error:\n\n``` julia\nf(y=5, z=10)\n# ERROR: MethodError: no method matching f(; y::Int64, z::Int64)\n\n# Closest candidates are:\n#   f(::Any; y, z)\n#    @ Main d:\\JuliaCode\\Julia4ER\\Julia for Engineering Research\\scrathpad.jl:42\n```\n\n::: callout-note\nIt is common to find that positional and keyword arguments are separated with a semi-colon at the point where the function is called, e.g. `f(2; y=3, z=5)`. This is just done to emphasise that the parameters after the semi-colon are kwargs, but it is not required. A comma will do just fine.\n:::\n\n#### Returning Results\n\nAs mentioned above, to return values from a function, there are two preferred options:\n\n-   Use the keyword `return`\n-   Mutate (modify) an array passed as parameter to the function\n\nFunctions in Julia will always return a value. Either there is an explicit `return` statement, or the last calculated value is automatically returned. It is good practise to always explicitly return a value. If your function returns nothing, then use `return nothing` to prevent an unexpected and unintended value from being returned.\n\nYou can have multiple `return` statements, but the first one to execute will terminate the function and return to the line after the call to the function.\n\n``` julia\nfunction isnotnegative(x)\n    if x >= 0\n        return true\n    else\n        return false\n    end\nend\n```\n\nor more concisely\n\n``` julia\nfunction isnotnegative(x)\n    return x >= 0\nend\n```\n\nThis is more understandable than the equivalent:\n\n``` julia\nfunction isnotnegative()\n    x >= 0\nend\n```\n\nJulia uses *pass-by-sharing* for parameters passed to functions. If you don't know what that means, you are in good [company](https://discourse.julialang.org/t/i-thought-i-understood-pass-by-sharing-in-julia-until-i-found-this/46897/8).\n\nThe practical implications however are fairly simply to understand. Parameters are immutable - you cannot modify them:\n\n``` julia\nfunction trychangeing(x)\n    println(\"Passed value: $x\")\n    x = 10\n    println(\"Local value: $x\")\nend\n\nx = -1\ntrychangeing(x)\n# Passed value: -1\n# Local value: 10\n\nprintln(\"Value at call site: $x\")\n# Value at call site: -1\n\na = [1]\ntrychangeing(a)\n# Passed value: [1]\n# Local value: 10\n\nprintln(\"Value at call site: $a\")\n# Value at call site: [1]\n```\n\nWhat happens is that Julia creates a new, local variable in the scope of the function, and assigns it the value of the argument that was passed. You can change the values of the parameters, but that does not affect the variables that were passed to the function - `x` and `a` in the examples above.\n\nHow do you then mutate an argument? You cannot change scalar values at all. Neither can you change an array. But the value of an array is just a pointer to some data that it contains, and you *can* change *that* data:\n\n``` julia\nfunction canchange!(x)\n    println(\"Passed value: $x\")\n    x[1] = -10\n    println(\"Local value: $x\")\nend\n\na = [1, 2, 3]\ncanchange!(a)\n# Passed value: [1, 2, 3]\n# Local value: [-10, 2, 3]\n\nprintln(a)\n[-10, 2, 3]\n```\n\n::: callout-note\nNote the addition of the exclamation mark (or \"bang\", for our American friends) to the name of the function. This is not a Julia requirement, just good manners. We inform the user of the code that one or parameter will be mutated. By convention, this will be the first parameter.\n:::\n\nA function returns only one value. What then if you need to return more than one result? Simply return them as a tuple and unpack them at the call site:\n\n``` julia\nfunction sqr_two(a, b)\n    return a^2, b^2 # The parentheses around the tuple are optional\nend\n\na2, b2 = sqr_two(2, 3) # Unpack the returned tuple into the two variables, a2 and b2\nprintln(\"a2 = $a2 and b2 = $b2.\"\n# a2 = 4 and b2 = 9.\n```\n\n#### Slurping and Splatting - Variable number of positional arguments\n\nJulia uses the `...` operator to *slurp* and *splat* values. Slurping means combining multiple scalar values into an array or tuple (slurping them up) and splatting means breaking an array or tuple into a number of scalar values. While this is sometimes used in other places, the most common application is to allow a variable number of parameters to be passed to a function.\n\n``` julia\nfunction confused(a, b, c...)\n    println(\"a is $a\")\n    println(\"b is $b\")\n    println(\"c is $c\")\nend\n\nconfused(1, 2, 3, 4, 5)\n# a is 1  \n# b is 2\n# c is (3, 4, 5)\n```\n\nSplatting allows an array to be passed to a function that expects a number of scalars:\n\n``` julia\nfunction confused2(a, b, c)\n    println(\"a is $a\")\n    println(\"b is $b\")\n    println(\"c is $c\")\nend\n\nx = [1, 2, 3]\nconfused2(x...)\n# a is 1  \n# b is 2\n# c is 3\n\nx = [1, 2, 3, 4]\nconfused2(x...)\n# ERROR: MethodError: no method matching confused2(::Int64, ::Int64, ::Int64, ::Int64)\n\n# Closest candidates are:\n#   confused2(::Any, ::Any, ::Any)\n# ...\n```\n\nThe last example results in an error, as there is no version of the function that accepts four parameters.\n\n## Type Stability and Fast Code\n\nBeing able to change the type of a variable can be useful, but it does also open the door to something that can cause slowdown in your code: **type instability**. This is when the type of x changes during the execution of your code, making many of the optimisations Julia could do, impossible. Instead, additional code is required to handle the type changes. Keep a look-out for something like this:\n\n``` julia\nfunction myfunc(n)\n    sum = 0\n    for i in 1:n\n        sum += 1.5\n    end\n    return sum\nend\n```\n\nAt first glance, there is nothing strange about this code. If you take a closer look however, you will see that `sum` is created as an integer via `sum = 0`, but then we assign floating-point values to it.\n\nJulia has a lot of code analyses tools. One of which is `@code_warntype`:\n\n``` julia\n@code_warntype myfunc(5)\n\nMethodInstance for myfunc(::Int64)\n  from myfunc(n) in Main at REPL[20]:1\nArguments\n  #self#::Core.Const(myfunc)\n  n::Int64\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  sum::Union{Float64, Int64}\n  i::Int64\nBody::Union{Float64, Int64}\n1 ─       (sum = 0)\n│   %2  = (1:n)::Core.PartialStruct(UnitRange{Int64}, Any[Core.Const(1), Int64])\n│         (@_3 = Base.iterate(%2))\n│   %4  = (@_3 === nothing)::Bool\n│   %5  = Base.not_int(%4)::Bool\n└──       goto #4 if not %5\n2 ┄ %7  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Int64\n│         (sum = sum + 1.5)\n│         (@_3 = Base.iterate(%2, %9))\n│   %12 = (@_3 === nothing)::Bool\n│   %13 = Base.not_int(%12)::Bool\n└──       goto #4 if not %13\n3 ─       goto #2\n4 ┄       return sum\n```\n\nLike when we looked at the LLVM code generated for a function, this may seem intimidating, but the important bits are these:\n\n``` julia\nsum::Union{Float64, Int64}\n```\n\nand\n\n``` julia\nBody::Union{Float64, Int64}\n```\n\n::: callout-note\nIn the REPL these are helpfully printed in red to draw your attention.\n:::\n\nJulia indicates that the variable `sum` is not type stable. It is assigned both `Int64` and `Float64`values. This limits the amount of optimisation that is allowed and ends up in slower code.\n\nTo learn more about type stability and many other useful tips to help you write faster code, refer to the [Performance Tips](https://docs.julialang.org/en/v1/manual/performance-tips/) section in the manual.\n\nThe main things to consider, if you want fast code are:\n\n1.  The fastest code is code that you don't need to execute. **Better algorithms always trump more optimised code**\n2.  Avoid type instability in your code.\n3.  Avoid unnecessary memory allocation by re-using arrays where possible.\n\nOnce you have these issues under control, learning to properly benchmark your code (using [BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl)) will allow you to fine tune the performance of your code. Writing fast code is mostly about *not writing slow code*.","srcMarkdownNoYaml":"\n\nThis section is meant to give you a running start in using Julia. The ultimate reference for all things regarding the language is the official [manual](https://docs.julialang.org/en/v1/), where you will find much more information.\n\n## Package Management\n\nJulia will open up in the default environment, e.g., `@v1.9`. You can add packages to this environment, and they will be available to load as soon as you open Julia. Be very careful about doing this, as this can very often lead to what is lightly called *dependency hell*. This is what happens when a package you want to update depends on another package that can't update, sometime because it depends on a specific version of yet another package. The more packages you have in the current environment, the more often this will happen. The correct solution is to create a new environment for each project and add only the packages you are actually using in the project.\n\n``` julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.9.1 (2023-06-07)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\ncd(\"./Dummy\")\n\npwd()\n# \"D:\\\\JuliaCode\\\\Dummy\"\n\n(@v1.9) pkg> activate .   #type ] to activate package manager in REPL\n  # Activating project at `D:\\JuliaCode\\Dummy`\n\n(Dummy) pkg> add UnicodePlots\n  #   Updating registry at `C:\\Users\\Braam\\.julia\\registries\\General.toml`\n  #  Resolving package versions...\n  #   Updating `D:\\JuliaCode\\Dummy\\Project.toml`\n  # [b8865327] + UnicodePlots v3.4.1\n  #   Updating `D:\\JuliaCode\\Dummy\\Manifest.toml`\n  # [d360d2e6] + ChainRulesCore v1.15.7\n  # [9e997f8a] + ChangesOfVariables v0.1.6\n  # [35d6a980] + ColorSchemes v3.20.0\n  # .\n  # .\n  # .\n\n(Dummy) pkg> st\n# Status `D:\\JuliaCode\\Dummy\\Project.toml`\n#   [b8865327] UnicodePlots v3.4.1\n```\n\nHere we changed the current directory to the *Dummy* sub-folder. Note the use of a forward slash. Backslashes are used for special characters, , `\\n` for a new line and must themselves be *escaped* by typing a double backslash: `cd(\".\\\\Dummy\")`. Or you can use a raw string: `cd(raw\".\\Dummy\")`. The forward slash however works just as well in Linux and MaxOS, so is preferred.\n\n`pwd()` is a function that replicates the Unix (Linux) command for *print working directory* and simply returns the name of the current folder.\n\nThe package manager is then activated with `]` and the current folder is activated as a project with `activate .`, where `.` means the current directory (`..` means the parent directory).\n\nFinally, we add a registered package, UnicodePlots.jl, and once the installation is done, check which packages and versions are currently installed with the `st` command (short for `status`).\n\nOnce a package is installed, it can be loaded by issuing the `using` command:\n\n``` julia\nusing UnicodePlots\n```\n\nIn the `Dummy` folder, Julia creates two files: `project.toml` and `manifest.toml`. These hold the record of the specific versions of packages that have been installed *for this project*. The packages directly installed are in the `project.toml` file, while the version numbers of dependencies are tracked in `manifest.toml`. These two files mean that someone else can reinstate the exact environment you developed your code in by activating the project and issuing the `instantiate` command to the package manager. This will install the same versions of the packages and dependencies as listed in the `*.toml` files.\n\nEach project should be in its own folder, with its own `*.toml` files. This means different projects can potentially use different versions of the same package, depending on what other packages are in use.\n\nTo update the packages and dependencies to the latest versions (as allowed for by the specified versions of dependencies for each package), use the `up` command of the package manager. This updates packages for the **current** project only.\n\n## Using vs Import\n\nThere are two ways to load a Julia package: `using` and `import`\n\nIf you use `using`, all methods and variables exported by a package are brought into the current namespace. You can call them directly:\n\n``` julia\nusing Plots\n\nscatter(rand(10), rand(10))\n```\n\nThis does mean that several functions and variables you are not using are now also in the namespace and you cannot define a new function with the same name or use another package that exports a function with the same name. For those cases, you can use `import`. If a package is `import`ed, you need to prepend each function call with the package name.\n\n``` julia\nimport Plots\nimport GLMakie\n\nPlots.scatter(rand(10), rand(10))\nGLMakie.scatter(rand(10), rand(10))\n```\n\n::: callout-tip\n## Try this\n\nSee what happens when you use `using` for the previous example.\n:::\n\nYou can load specific functions or variables from a package:\n\n``` julia\nusing Plots: scatter\nimport GLMakie: lines\n```\n\nNone of the other exported variables or functions will become available. When loading a single item, you can also rename it using the `as` keyword:\n\n``` julia\nimport Plots.scatter as ps\nimport GLMakie: scatter as ms\n\nps(rand(10), rand(10))\nms(rand(10), rand(10))\n```\n\nor even rename the package during import:\n\n``` julia\nimport BenchmarkTools as bt\n\nbt.@benchmark sin.(1:1_000_000)\n# BenchmarkTools.Trial: 400 samples with 1 evaluation.\n#  Range (min … max):  11.751 ms … 24.278 ms  ┊ GC (min … max): 0.00% … 49.13%\n#  Time  (median):     12.043 ms              ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   12.515 ms ±  2.246 ms  ┊ GC (mean ± σ):  3.56% ±  9.50%\n\n#   ▆█▅\n#   ████▆▁▄▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▁▅▇▆ ▆\n#   11.8 ms      Histogram: log(frequency) by time        24 ms <\n\n#  Memory estimate: 7.63 MiB, allocs estimate: 2.\n```\n\n## Variables\n\nThere is no programming without variables. In Julia, there is no need to pre-declare a variable (although you can) and variables can be reassigned to a value of another type:\n\n``` julia\nx = 1\n# 1\n\ntypeof(x)\n# Int64\n\nx = 2.4\n# 2.4\n\ntypeof(x)\n# Float64\n\nx = \"Hello, World\"\n# \"Hello, World\"\n\ntypeof(x)\n# String\n```\n\nWhen assigning a value to the variable `x`, Julia infers the type of the value, e.g., `Int64` and then associates the name, `x`, with that value.\n\nAs illustrated, the function `typeof()` will return the type of the variable or value. While you don't have to specify the types of variables, Julia is a *strongly typed* language, just like C or Fortran. The type of a variable is just automatically inferred whenever possible.\n\nSince variables can be reassigned in the global scope, this makes it difficult for the compiler to generate optimised code - the type of the variable could change. If you want fast code, then avoid using global variables, or if you absolutely have to use them, declare them as `const`.\n\n``` julia\nconst MyConst = 1\n# 1\n\ntypeof(MyConst)\n# Int64\n\nMyConst = 2\n# WARNING: redefinition of constant MyConst. This may fail, cause incorrect answers, or produce other errors.\n# 2\n\nMyConst = 2.0\n# ERROR: invalid redefinition of constant MyConst\n# Stacktrace:\n#  [1] top-level scope\n#    @ REPL[4]:1\n```\n\nDeclaring a variable as `const` freezes the type of the variable, allowing more optimisations. It is possible, but not recommended, to change the value, but not the type. It is expected that changes to the values will also be prevented in future versions of Julia.\n\nThe best practice, however, is to put your code inside functions.\n\n### Strings and Characters\n\nText values are stored as either strings (`\"This is a string\"`, type `String`) or single characters (`'c'`, type `Char`). Note the use of double and single quotation marks for `String` vs `Char`. A string can be just one character long: `\"A\"`. Strings can also include multiple lines, and quotation marks, when enclosed with triple quotation marks:\n\n``` julia\ns = \"\"\"\n    This is my\n    very long\n    string with \"quotes\"\n\"\"\"\n# \"This is my \\nvery long\\nstring with \\\"quotes\\\"\\n\"  \n\ns[5]\n# ' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n\ns[5:10]\n# \" is my\"\n```\n\nNote how new lines are indicated with `'\\n'`, which is itself a character (n is short for **n**ew line).\n\nNumerical values can be converted to strings using the `string()` function:\n\n``` julia\nstring(123)\n# \"123\"\n```\n\nStrings and characters in Julia are encoded in UTF-8 Unicode. This allows all kinds of characters, from mathematical symbols to Chinese characters and emojis to be used. It also means that not all *glyphs* take the same amount of memory to store. This can be confusing when processing strings. If you intend to work with strings, read the relevant sections of the [manual](https://docs.julialang.org/en/v1/manual/strings/#Unicode-and-UTF-8) carefully.\n\nA somewhat unintuitive feature of Julia is that string concatenation is done via the `*` operator. This does have the advantage that multiple copies of a string can be concatenated via the exponentiation (`^`) operator:\n\n``` julia\nstr = \"lala\"\n# \"lala\"\n\nstr*str\n# \"lalalala\"\n\nstr^5\n# \"lalalalalalalalalala\"\n```\n\nJulia includes a vast number of string processing functions. These are discussed in detail in the [manual](https://docs.julialang.org/en/v1/manual/strings/).\n\n#### String Interpolation\n\nYou can *interpolate* a value from a variable or expression into a string, using the `$` character:\n\n``` julia\nvalue = 1.0\n# 1.0\n\nkey = \"myvar\"\n# \"myvar\"\n\nprintln(\"The key is: $key and the value is: $value.\")\n# The key is: myvar and the value is: 1.0.\n\nprintln(\"Twice the value is: $(2*value)\")\n# Twice the value is: 2.0\n```\n\n### Integers and Floating-point Values\n\nJulia has the usual selection of variable types for integers and floating-point values. There are signed and unsigned versions of 8, 16, 32, 64 and 128-bit integers. See the [manual](https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/) for details.\n\nThere is also a `Bool` type that holds either `true` (1) or `false` (0).\n\nFor floating-point values, there is Float16, Float32 and Float64.\n\nThe default integer, `Int` is equivalent to `Int64` for 64-bit Julia and `Int32` for 32-bit Julia. Generally, you would want to use `Float64` for floating-point numbers, unless there is a specific reason not to. Calculations on a GPU (via e.g., `CUDA.jl`) should be done using `Float32`, unless you have a very expensive[^1] GPU capable of processing 64-bit floating point calculations.\n\n[^1]: An Nvidia Tesla A100 costs about US\\$7400 in mid-2023\n\n#### A Word on Floating-Point Values\n\nFloating-point values are stored in a limited number of bits (typically 64 bits - a.k.a. double precision) and hence have a limited precision. The result is that most values cannot be precisely stored in a `Float64` variable. As a simple example, 1/10, which is clearly precisely equal to 0.1, is actually calculated as 0.1000000000000000055511151231257827021181583404541015625 with 256-bit precision.\n\nThe smallest positive value that can be stored in a `Float64`, is 2.220446049250313e-16. You can calculate this in Julia using the `eps()` function e.g., `eps(Float64)`. The value epsilon is an indication of the precision you can expect. It is the smallest value you can add to the floating-point value that will cause it to result in a new value. Anything smaller may as well be zero. Obviously, epsilon depends on the magnitude of the values you are working with, and you can again use the `eps()` function: `eps(100) = 1.4210854715202004e-14`, so adding a smaller amount to 100 will not change the value.\n\nWhile you can safely ignore this for many, if not most engineering calculations, it can sometimes become an issue when you least expect it. Consider adding up a very large number of small values. The larger the difference between the running total and the next value you are adding, the larger the rounding error will become. At some point in this exercise, the value you are adding to the running total will be in the order of the relative epsilon and the running total will stop increasing, no matter how many more values you add. The solution to this is actually fairly simple and implemented in the Julia `sum()` function.\n\nThe list of values is split into pairs and the pairs are added to each other, then this is repeated over and over until there is only one value left - the answer. The algorithm works under the inherent assumption that the values are fairly equally sized and so adding similar values results in minimal rounding error. Once the pairs have been summed, the new values should also be similarly sized and so the process repeats, with a minimum rounding error at each step.\n\nSomething else to consider, which much more often trips up new programmers, is that you will very rarely find two identical floating-point values through calculations. Directly comparing values that are realistically speaking equal, will very often result in the wrong part of an `if` statement executing. When comparing floating-point values, always use a check for approximate equality. This is done either via the `≈` operator (`\\approx<tab>`), or the `isapprox()` function, which allows you to specify absolute and relative tolerances. The `≈` operator calls `isapprox()` with default tolerances.\n\nThe internal storage of floating-point values is standardised by the [IEEE 754](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) standard, which is used in just about every programming language. This is important, since it means you can pass values between Julia and code running in R or Python or compiled in C.\n\n### BigInt and BigFloat\n\nSometimes, you may find a need for additional precision. Arbitrary-precision integer and floating-point types are available as BigInt and BigFloat.\n\nThere are several ways to specify that you are using `big` numbers, but the simplest is via the `big()` function:\n\n``` julia\nx = big(10.0)\n# 10.0\n\ntypeof(x)\n# BigFloat\n```\n\nThe precision again comes at the cost of performance. See the [manual](https://docs.julialang.org/en/v1/base/numbers/#BigFloats-and-BigInts) for more details. You only need to specify that one variable/number in a calculation is `big` - the rest will be converted automatically by Julia.\n\n### Complex Numbers\n\nJulia has built-in types for complex numbers, which depend on the integer or floating-point type used to store the real and imaginary parts, e.g.\n\n``` julia\ntypeof(1 + 2im)\n# Complex{Int64}\n\ntypeof(1.0 + 2.0im)\n# ComplexF64 (alias for Complex{Float64})\n```\n\nAs you will notice, a complex type is specified as `Complex{T}` where T is an integer or floating-point type. Any of the integer and floating-point types mentioned before could be used, including `BigInt` and `BigFloat`. Simply define the value as:\n\n``` julia\nz = big(10.0) + 1.0im\n# 10.0 + 1.0im\n\ntypeof(z)\n# Complex{BigFloat}\n\nz = big(10) + im\n# 10 + 1im\n\ntypeof(z)\n# Complex{BigInt}\n```\n\nThe imaginary part of the number is indicated by adding `im` directly behind the number - no space! As shown in the example, the `1` is optional in the imaginary part - you can just specify `im` for `1im`.\n\nThe expected functions for use with complex numbers are available, including:\n\n``` julia\nz = 1 + 1im\n# 1 + 1im\n\nreal(z) # real part\n# 1\n\nimag(z) # imaginary part\n# 1\n\nconj(z) # complex conjugate\n# 1 - 1im\n\nabs(z) # absolute value - distance from zero\n# 1.4142135623730951\n\nabs2(z) # squared absolute value\n# 2\n\nangle(z) # phase angle (radians)\n# 0.7853981633974483\n\nangle(z) * 360/2π # convert to degrees\n# 45.0\n\n√z\n# 1.09868411346781 + 0.45508986056222733im\n\nsqrt(z)\n# 1.09868411346781 + 0.45508986056222733im\n```\n\n### Rational Numbers\n\nYou can also work with rational numbers.\n\n``` julia\na = 1//2 + 3//8\n# 7//8\n\nfloat(a)\n# 0.875\n\nrationalize(0.875)\n# 7//8\n```\n\nThis eliminates rounding losses, but at a loss of performance:\n\n``` julia\nfunction myfunc(x)\n    sum = zero(x)\n    for i in 1:10_000\n        sum += x * i\n    end\n    return sum\nend\n\n# myfunc (generic function with 1 method)\n\nusing BenchmarkTools\n\n@benchmark myfunc(1.0)\n# BenchmarkTools.Trial: 10000 samples with 3 evaluations.\n#  Range (min … max):  8.500 μs …  73.733 μs  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     8.700 μs               ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   8.704 μs ± 966.620 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#   ▅  █  ▆  ▃         █  █   ▅  ▂  ▁   ▁  ▁                    ▂\n#   █▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁█▁▁▁▇▁▁█▁▁▇▁▁▄ █\n#   8.5 μs       Histogram: log(frequency) by time       9.1 μs <\n\n#  Memory estimate: 0 bytes, allocs estimate: 0.\n\n@benchmark myfunc(1//1)\n# BenchmarkTools.Trial: 7295 samples with 1 evaluation.\n#  Range (min … max):  663.600 μs …  1.234 ms  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     680.100 μs              ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   682.504 μs ± 29.021 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#   ▇█▆▃▂▃██▅▄▃▃▃▂▃▁▁▁▁       ▁                                  ▂\n#   ███████████████████████▇▇████▇▇█▆▆▇▇▇▅▆▆▅▆▅▅▅▃▅▅▄▆▅▃▅▅▄▄▁▃▃▅ █\n#   664 μs        Histogram: log(frequency) by time       811 μs <\n\n#  Memory estimate: 0 bytes, allocs estimate: 0.\n```\n\nSo, floating-point calculations are about 78x faster than with rational numbers. What about integers?\n\n``` julia\n@benchmark myfunc(1)\n# BenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n#  Range (min … max):  1.900 ns … 27.200 ns  ┊ GC (min … max): 0.00% … 0.00%\n#  Time  (median):     2.000 ns              ┊ GC (median):    0.00%\n#  Time  (mean ± σ):   1.976 ns ±  0.530 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n#   ▄                                                        █\n#   █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▂\n#   1.9 ns         Histogram: frequency by time           2 ns <\n\n#  Memory estimate: 0 bytes, allocs estimate: 0.\n```\n\n1.9 nanoseconds?!? That sounds too good to be true, doesn't it? Let's see what type of code Julia generated to make that possible.\n\n``` julia\n@code_llvm myfunc(1)\n\n;  @ REPL[6]:1 within `myfunc`\n; Function Attrs: uwtable\ndefine i64 @julia_myfunc_739(i64 signext %0) #0 {\ntop:\n;  @ REPL[6]:3 within `myfunc`\n  %1 = mul i64 %0, 50005000\n;  @ REPL[6]:6 within `myfunc`\n  ret i64 %1\n}\n```\n\nWe can again ignore any line starting with a semi-colon. The one line that matters is this:\n\n``` julia\n  %1 = mul i64 %0, 50005000\n```\n\nThe Julia compiler could analyse the code well enough to see that the answer to our function is simply 50005000 times the input value and that is exactly what it returned!\n\nWith floating-point and rational values, there were type conversions required before multiplying the integer value of the loop counter with the input value. This \"hid\" the true nature of the calculation enough that the compiler could not see the short-cut. There is however continuous development in the compiler, and we can reasonably expect this to also be optimised in a future version of Julia.\n\n### Arrays, Tuples and Ranges\n\n#### Arrays\n\nIn most code, you will find it convenient to deal with a collection of values at the same time. There are several ways of doing this.\n\nThe most common collection of values is an Array. In mathematics, you will be familiar with *vectors* and *matrices*. These are simply one- and two-dimensional arrays. You can have arrays with any number of dimensions (*tensors*). The keywords `Vector` and `Matrix` are also available as synonyms for `Array` in the special cases of one and two dimensions.\n\n::: callout-note\nSimple one-dimensional arrays are treated as **column vectors** for use in linear algebra calculations.\n:::\n\nSome examples:\n\n``` julia\na = [1, 2, 3]   # use commas to specify column vectors\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nb = [1 2 3]   # use spaces to specify row vectors\n# 1×3 Matrix{Int64}:\n#  1  2  3\n\na * b \n# 3×3 Matrix{Int64}:\n#  1  2  3\n#  2  4  6\n#  3  6  9\n\nA = [1 2 3;   # directly specify a 2D array a.k.a. a matrix\n     4 5 6;\n     7 8 9]\n# 3×3 Matrix{Int64}:\n#  1  2  3\n#  4  5  6\n#  7  8  9\n\nB = zeros(3, 3, 3)   # zeros() and ones() fill the array of the specified size\n# 3×3×3 Array{Float64, 3}:\n# [:, :, 1] =\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n\n# [:, :, 2] =\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n\n# [:, :, 3] =\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0\n#  0.0  0.0  0.0 \n\nC = zeros(Int64, 2, 2) # You can specify the type - Float64 is the default\n# 2×2 Matrix{Int64}:\n#  0  0\n#  0  0\n\nD = [1;2;;3;4;;;5;6;;7;8;;;9;10;;11;12]  # ; separates in first dimension, ;; in second dimension, ;;; in third etc.\n# 2×2×3 Array{Int64, 3}:\n# [:, :, 1] =\n#  1  3\n#  2  4\n\n# [:, :, 2] =\n#  5  7\n#  6  8\n\n# [:, :, 3] =\n#   9  11\n#  10  12\n\nE = Float64[]   # an empty 1D array of Float64\n# Float64[]\n```\n\nThe individual entries of an array are accessed via `[]`, e.g.,\n\n``` julia\nA[2, 3]\n# 6\n```\n\nIn the background, `[]` calls `getindex()` and `setindex()` to retrieve or modify the entries of the array. If you define your own array-like type, you will need to supply the appropriate `getindex()` and `setindex()` functions.\n\nYou can concatenate arrays horizontally and vertically with `hcat()` and `vcat()`, or using the syntax above with spaces or semi-colons:\n\n``` julia\nA = [1, 2, 3]\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nB = [4, 5, 6]\n# 3-element Vector{Int64}:\n#  4\n#  5\n#  6\n\n[A; B]\n# 6-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n#  6\n\n[A B]\n# 3×2 Matrix{Int64}:\n#  1  4\n#  2  5\n#  3  6\n\nvcat(A, B)\n# 6-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n#  6\n\nhcat(A, B)\n# 3×2 Matrix{Int64}:\n#  1  4\n#  2  5\n#  3  6\n```\n\n#### Tuples\n\nTuples are functionally similar to arrays. They are specified with commas and (optional) parentheses. They are intimately linked with passing parameters to functions and returning values from functions, e.g.\n\n``` julia\nfunction myfunc(a, b)\n    return a*b, a+b\nend\n# myfunc (generic function with 1 method)\n\nmyfunc(1, 2)\n# (2, 3)\n\ntypeof(myfunc(1, 2))\n# Tuple{Int64, Int64}\n```\n\nWe pass the parameters to the function as a tuple, (a, b). The results are returned as a tuple, (2, 3). Other than passing parameters to functions, what is the use of tuples? They are fairly widely used in Julia. The main differences from arrays are that while arrays are heap-allocated, tuples are stack-allocated. This is some more computer jargon, but what it means in practise is that tuples can be accessed faster than arrays but cannot be as large.\n\nTuples are also *immutable*, meaning once created, they cannot be modified. The entries of an array can always be modified. This is important to keep in mind when writing functions in Julia. The only way you can modify a parameter passed to a function is if that parameter is an array. And then only the individual entries of the array can be changed - you cannot replace the array with another one (more detail later).\n\nSome examples:\n\n``` julia\na = (1, 2, 3)\n# (1, 2, 3)\n\ntypeof(a)\n# Tuple{Int64, Int64, Int64}\n\nb = (1., 2., 3, 1//2)\n# (1.0, 2.0, 3, 1//2)\n\ntypeof(b)\n# Tuple{Float64, Float64, Int64, Rational{Int64}}\n\na[2]\n# 2\n\nc = (1,) # A tuple with only one value - note the trailing comma!\n# (1,)\n\ntypeof(c)\n# Tuple{Int64}\n\nd = 1,2,3  # the parentheses are optional\n# (1, 2, 3)\n\ntypeof(d)\n# Tuple{Int64, Int64, Int64}\n```\n\nWe again use `[]` to access the individual entries.\n\n``` julia\na = (1, 2, 3)\n# (1, 2, 3)\n\na[2]\n# 2\n```\n\nTuples can be unpacked into variables:\n\n``` julia\na\n# (1, 2, 3)\n\nx, y, z = a\n# (1, 2, 3)\n\nx\n# 1\n\ny\n# 2\n\nz\n# 3\n```\n\nAnd since the parentheses are optional in the direct specification of tuples, we can do this:\n\n``` julia\nx = 1\n# 1\n\ny = 2\n# 2\n\ny, x = x, y\n# (1, 2)\n\nx\n# 2\n\ny\n# 1\n```\n\nHere we defined a tuple `(x, y)` and then unpacked it into the variables `y` and `x`, swapping their values.\n\nSince tuples have superior performance to arrays, there exists a package that builds small arrays-like structures from tuples - [`StaticArrays.jl`](https://github.com/JuliaArrays/StaticArrays.jl). This is commonly used for maximum performance, but only for smallish arrays, typically less than 200-300 entries. More than that and you run out of space on the stack, which has a limited size.\n\n#### Named Tuples\n\nYou can also name the entries in a tuple and access them via the names instead of indexes:\n\n``` julia\nnt = (a = 1, b = 2, c = \"Bob\")\n# (a = 1, b = 2, c = \"Bob\")\n\ntypeof(nt)\n# NamedTuple{(:a, :b, :c), Tuple{Int64, Int64, String}}\n\nnt.a\n# 1\n\nnt[2]\n# 2\n\nnt.c\n# \"Bob\"\n\nnt.c === nt[3] # The values are \"egal\", i.e. not just equal, but the actual same bits in memory\n# true\n```\n\nNote that the entries in a tuple or named tuple needn't be all of the same type. This is also true for arrays, but in that case the array will be of type `Any` and performance will be hugely impacted. **Avoid this whenever possible!**\n\n#### Ranges\n\nThe third collection type we are considering are ranges. There are several ways to specify a range:\n\n``` julia\na = 1:10   # start : stop with default step of one, hence a unit range\n# 1:10\n\ntypeof(a)\n# UnitRange{Int64}\n\nb = 1:2:20   # start : step : stop, hence a step range\n# 1:2:19\n\ntypeof(b)\n# StepRange{Int64, Int64}\n\nc = 1.0:0.5:5.0 # with floating-point steps, we get a StepRangeLen\n# 1.0:0.5:5.0\n\ntypeof(c)\n# StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}\n\nd = range(2.0, step=5.3, length=5)  # instead of colon notation, you can call the function with more options\n# 2.0:5.3:23.2\n\ntypeof(d)\n# StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}\n```\n\n::: callout-note\nThe `Base.TwicePrecision{Float64}` part may be confusion. Directly from the Julia help (type `?Base.TwicePrecision` at the REPL prompt:\n\n> *TwicePrecision is an internal type used to increase the precision of floating-point ranges, and not intended for external use. If you encounter them in real code, the most likely explanation is that you are directly accessing the fields of a range. Use the function interface instead, step(r) rather than r.step*\n:::\n\nAnd just like before, we access the entries with `[]`:\n\n``` julia\na[2]\n# 2\n\nb[3]\n# 5\n\nc[4]\n# 2.5\n\nd[5]\n# 23.2\n```\n\nThe main difference is that, while arrays and tuples consist of values stored in memory, ranges are *lazy*. The values are only calculated when they are requested and no matter the length of the range, it takes up the same amount of memory - just enough to store the *start*, *step* and *stop*/*length* values that are needed to calculate any entry and know when you have run through the whole range.\n\nYou can change a range into an array, with the `collect()` function:\n\n``` julia\ncollect(1:10)\n# 10-element Vector{Int64}:\n#   1\n#   2\n#   3\n#   4\n#   5\n#   6\n#   7\n#   8\n#   9\n#  10\n```\n\n#### Iterables\n\nArrays, tuples and ranges (and strings) are all iterable types, meaning you can iterate through their entries:\n\n``` julia\na = [1, 5, 10]\n# 3-element Vector{Int64}:\n#   1\n#   5\n#  10\n\nfor i in a\n    println(i)\nend\n# 1\n# 5\n# 10\n\nfor j in 1:3\n    println(j*2)\nend\n# 2\n# 4\n# 6\n\nt = (1, 2, 3)\n# (1, 2, 3)\n\nfor k in t\n    println(k)\nend\n# 1\n# 2\n# 3\n```\n\n::: callout-note\nYou can also use the Unicode symbol ∈ (`\\in<tab>`) in place of the word `in`.\n:::\n\nFrom a programmer's point of view, iterable types all behave the same. We can therefore write a function that can handle any iterable type. The only requirement for this example is that the item passed should have at least two entries, or there will be an error.\n\n``` julia\nfunction mycomp(a)\n    if a[1] > a[2]\n        return true\n    else\n        return false\n    end\nend\n# mycomp (generic function with 1 method)\n\nar = [1, 2]\n# 2-element Vector{Int64}:\n#  1\n#  2\n\nt = (2, 1)\n# (2, 1)\n\nr = 10:-1:1\n# 10:-1:1\n\nmycomp(ar)\n# false\n\nmycomp(t)\n# true\n\nmycomp(r)\n# true\n```\n\nFor each case, the Julia compiler will generate optimised code depending on the type of the variable passed.\n\n#### Indexing\n\nIn the examples above, we used one-dimensional arrays and there was really no choice in how to index into the structure. The entries are all in a row in memory.\n\nIn the case if multi-dimensional arrays, the entries are still sequential in memory - that is how RAM works! Here, however, there are better and worse options for accessing a given entry in the array.\n\nThis is because of how the values are stored in memory. It is faster to sequentially access values that are stored next to each other than to jump around in memory. Julia is *column major*, meaning that the values in the first column of a matrix are stored next to each other in memory, followed by the values of the second column etc. For higher dimensions, the sequence is similar: each subsequent index follows the next. This is then the fastest way of iterating through the whole array.\n\n``` julia\nA = rand(10_000, 10_000);  # the _ is ignored - it is just to make reading easier. The ; at the end suppresses output of the result\n\nfunction myfunc(A)\n    mysum = 0.0\n    m, n = size(A)\n    for i = 1:m, j = 1:n  # we are running through the matrix a row at a time\n        mysum += A[i, j]\n    end\n    return mysum\nend\n# myfunc (generic function with 1 method)\n\nfunction myfunc2(A)\n    mysum = 0.0\n    m, n = size(A)\n    for j = 1:n, i = 1:m  # we are running through the matrix a column at a time\n        mysum += A[i, j]\n    end\n    return mysum\nend\n# myfunc2 (generic function with 1 method)\n\nusing BenchmarkTools\n\n@btime myfunc(A)\n#   644.754 ms (1 allocation: 16 bytes)\n# 4.99959369384022e7\n\n@btime myfunc2(A)\n#   94.296 ms (1 allocation: 16 bytes)\n# 4.999593693838226e7\n```\n\nSo, in our 10,000 x 10,000 random matrix, summing up the values row-wise takes 644.754ms, while column-wise it takes only 96.449ms. Quite the improvement! If you are worried you won't remember the correct way of iterating through a structure, Julia has you covered. Use `eachindex()` to get the optimal sequence:\n\n``` julia\nfunction myfunc3(A)\n    mysum = 0.0\n    m, n = size(A)\n    for i in eachindex(A)\n        mysum += A[i]\n    end\n    return mysum\nend\n# myfunc3 (generic function with 1 method)\n\n@btime myfunc3(A)\n#   96.394 ms (1 allocation: 16 bytes)\n# 5.000090241950418e7\n```\n\n`eachindex()` returns a linear index, no matter what the dimensionality of the array is and sequences it for the fastest sequential access.\n\nAnother useful indexing function is `enumerate()`. It returns an iterator of tuples, each containing an index and value pair. The indexes are linear, not cartesian.\n\n``` julia\nA = rand(2,2)\n# 2×2 Matrix{Float64}:\n#  0.488632  0.177813\n#  0.221677  0.559213\n\nfor (index, value) in enumerate(A)\n    println(\"$index $value\")\nend\n# 1 0.4886321057630626\n# 2 0.22167740760406662\n# 3 0.17781317540395236\n# 4 0.5592126504604934\n```\n\nFor more information, see the [manual](https://docs.julialang.org/en/v1/base/iterators/#Base.Iterators.enumerate).\n\n::: callout-note\nJulia also provides the keywords `begin` and `end` to directly index the first and last entries in an array:\n\n``` julia\na = [1, 2, 3]\n# 3-element Vector{Int64}: …\n\na[begin]\n# 1\n\na[end]\n# 3\n\na[end-1] # second last entry\n# 2\n```\n:::\n\n#### Array Assignments\n\nThe array variable is a pointer[^2] that holds the address of the memory space where the contents is kept (on the heap). This is not an implementation detail - it is an important thing to keep in mind, as there is a difference between modifying the entries of the array (the values in the memory the array variable points to) and changing the array variable (which memory it points to):\n\n[^2]: A pointer is just a memory address - computer guys like their jargon.\n\n``` julia\na = collect(1:5)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = a\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb[2] = -1\n# -1\n\na\n# 5-element Vector{Int64}:\n#   1\n#  -1\n#   3\n#   4\n#   5\n\na[2] = 10\n# 10\n\nb\n# 5-element Vector{Int64}:\n#   1\n#  10\n#   3\n#   4\n#   5\n```\n\nHere we created an array variable, `a`. Then we assigned `a` to `b`. The result is a new array variable that **points to the same memory space**. If we change the contents of `b`, we also change the contents of `a`, and vice versa.\n\nIf you want an independent copy of `a`, then use the `copy()` function:\n\n``` julia\na = collect(1:5)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = copy(a)\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb[2] = -1\n# -1\n\na\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb\n# 5-element Vector{Int64}:\n#   1\n#  -1\n#   3\n#   4\n#   5\n```\n\n#### Array Comprehensions\n\nThis is a quick, flexible way of creating arrays with specific values, best illustrated by example:\n\n``` julia\na = [sin(i^2) for i in 0:0.1:2π]\n# 63-element Vector{Float64}:\n#   0.0\n#   0.009999833334166666\n#   0.03998933418663417\n#   0.08987854919801107\n#   0.159318206614246\n#   0.24740395925452294\n#   ⋮\n#   0.7940962483324946\n#  -0.24980688359658182\n#  -0.9917788534431158\n#  -0.4698420526176865\n#   0.6749435215575963\n\n[1/(x+y) for x in 1:3, y in 1:3]\n# 3×3 Matrix{Float64}:\n#  0.5       0.333333  0.25\n#  0.333333  0.25      0.2\n#  0.25      0.2       0.166667\n\n[1/(x+y) for x in 1:3 for y in 1:3] # A second `for` keyword and no comma!\n# 9-element Vector{Float64}:\n#  0.5\n#  0.3333333333333333       \n#  0.25\n#  0.3333333333333333\n#  0.25\n#  0.2\n#  0.25\n#  0.2\n#  0.16666666666666666 \n```\n\nTake note of the subtle difference between the second and third examples. This is not terribly intuitive!\n\n#### Broadcasting\n\nYou can process each entry in an iterable in a loop, or you can use the built-in broadcasting (a.k.a. dot notation). The following are equivalent:\n\n``` julia\na = collect(1:5) # create an array\n# 5-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n#  5\n\nb = 2:2:10 # create a range\n# 2:2:10\n\nc = similar(a) # create an uninitialised array with the same size and type as a\n# 5-element Vector{Int64}:\n#                0\n#  140734236573968\n#  140734236545296\n#                0\n#                0\n\nfor i in 1:length(a)\n    c[i] = a[i] + b[i]\nend\n\nc\n# 5-element Vector{Int64}:\n#   3\n#   6\n#   9\n#  12\n#  15\n\nd = a .+ b # element-wise addition\n# 5-element Vector{Int64}:\n#   3\n#   6\n#   9\n#  12\n#  15 \n\ne = sqrt.(d) # works for any function (note the . is between the name and the open parenthesis)\n# 5-element Vector{Float64}:\n#  1.7320508075688772\n#  2.449489742783178\n#  3.0\n#  3.4641016151377544\n#  3.872983346207417\n```\n\n### The Type Hierarchy\n\nThe built-in types have a hierarchy:\n\n![The type hierarchy - Image from https://thautwarm.github.io/](https://thautwarm.github.io/Site-32/_images/julia-type-hierarchy.png)\n\nThis consists of abstract and concrete types. You can only instantiate a variable of a concrete type, but the abstract types are useful to specify groups of types that would behave similarly, e.g., `Float64` and `Int64` could both the added and multiplied. This is true for all the `Number` types, be they `Real` or `Complex`. We could specify allowed groups of types, via the `<:` operator, or specific types, via `::`, e.g.\n\n``` julia\nfunction f(x::T) where T <: Number\n    #do something\nend\n```\n\nHere, Julia will allow us to call f(x) with any sub-type of the `Number` abstract type, such as `Float64`, `Int32` or `ComplexF64`. Calling f(x) with a `String` type will give an error, rather than try to compile a specialised version of `f()`.\n\nWe can also use this to have alternative versions of a function for different types of inputs, via multiple dispatch:\n\n``` julia\nfunction addthem(a::T, b::S) where {T<:Number, S<:Number}\n    return a + b\nend\n\nfunction addthem(a::T, b::T) where T<:AbstractString\n    return a * b\nend\n\naddthem(1, 2)\n#3\n\naddthem(2, 2.0)\n#4.0\n\naddthem(\"One\", \"Two\")\n#OneTwo\n```\n\n::: callout-note\nNote that in the first function we use T and S, both sub-types of `Number`. If both variables where `T<:Number`, then calling the function with an integer and a floating point value - the second example - would have given an error, as the two variables are not of the same type.\n\nWe also used `AbstractString` for the second function, so any type that acts like a `String` should work, as long as they have the `*` operator defined.\n:::\n\n### Structs\n\nStructs are use-defined complex types that can contain multiple fields. They are defined using the `struct` keyword:\n\n``` julia\nstruct PersonData\n    name::String\n    address::String\n    ID::Int64\nend\n\ncustomers = PersonData[] # empty array of PersonData structs\n# PersonData[]\n\ntypeof(customers)\n# Vector{PersonData} (alias for Array{PersonData, 1})\n\nbob = PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456) # create a variable of type PersonData by calling the constructor\n# PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\npush!(customers, bob) # push an entry into the array - will increase the length by one\n# 1-element Vector{PersonData}:\n#  PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\ncustomers[1]\n# PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\nbob.name # access the values via the field names\n# \"Robert Smith\"\n\ncustomers[1].name\n# \"Robert Smith\"\n```\n\nBy default, a `struct` is immutable, meaning it cannot be changed once created:\n\n``` julia\nbob.name = \"Joe Bloggs\"\n# ERROR: setfield!: immutable struct of type PersonData cannot be changed\n# Stacktrace:\n#  [1] setproperty!(x::PersonData, f::Symbol, v::String)\n#    @ Base .\\Base.jl:39\n#  [2] top-level scope\n#    @ REPL[31]:1\n```\n\nTo make a `struct` mutable, simply add the keyword `mutable` to the definition.\n\n``` julia\nmutable struct PersonData2\n    name::String\n    address::String\n    ID::Int64\nend\n\nbob = PersonData2(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n# PersonData2(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\nbob.name\n# \"Robert Smith\"\n\nbob.name = \"Joe Bloggs\"\n# \"Joe Bloggs\"\n\nbob\n# PersonData2(\"Joe Bloggs\", \"2 Cypress Lane\", 123456)\n```\n\nThe `struct` is immutable by default to allow additional compiler optimisations. Mutable structs will therefore have worse performance, but more flexibility.\n\n#### Constructors\n\nJulia automatically creates a *constructor* for each struct you define. This is a function that takes the values of the fields, creates a new structure in memory and assigns the specified values to the fields.\n\nYou can also create additional constructors. There are two types:\n\n-   Outer constructors and\n-   Inner constructors\n\nThe default constructor is an outer constructor. You can also specify additional outer constructors that e.g., have default values for some fields, or calculate some values from others:\n\n``` julia\nstruct PersonData\n    name::String\n    address::String\n    ID::Int64\nend\n\nbob = PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n# PersonData(\"Robert Smith\", \"2 Cypress Lane\", 123456)\n\nfunction PersonData(name, ID)\n    # Call the default constructor to do the allocations and assignments\n    PersonData(name, \"No known address\", ID) \nend\n# PersonData\n\nsally = PersonData(\"Sally Jones\", 123)\n# PersonData(\"Sally Jones\", \"No known address\", 123)\n\nsally.address\n# \"No known address\"\n\ntom = PersonData(\"Tom Jones\", \"Las Vegas\", 34556) # The default is still available\n# PersonData(\"Tom Jones\", \"Las Vegas\", 34556\n```\n\nInner constructors are defined as part of the `struct` definition and are used to validate the entries for the struct before creating the instance.\n\n``` julia\nstruct OnlyNegatives\n    val::Float64\n    OnlyNegatives(val) = val > 0 ? error(\"Non-negative value!\") : new(val)\nend\n\nOnlyNegatives(-1)\n# OnlyNegatives(-1.0)\n\nOnlyNegatives(1)\n# ERROR: Non-negative value!\n# Stacktrace:\n#  [1] error(s::String)\n#    @ Base .\\error.jl:35\n#  [2] OnlyNegatives(val::Int64)\n#    @ Main .\\REPL[7]:3\n#  [3] top-level scope\n#    @ REPL[9]:1\n```\n\nInner constructors have access to a special local function, `new()`, which acts like the default outer constructor would.\n\n::: callout-important\nIf you define an inner constructor, **NO** default constructors are created. You need to handle all cases via your inner constructors.\n:::\n\n## Loops\n\nJulia provides two types of loops:\n\n1.  `for` loops for iterating over an iterable construct, like a range or array with a known length\n2.  `while` loops for iterating until a logical criterium is met, with an initially unknown number of iterations\n\n``` julia\na = zeros(5)\n# 5-element Vector{Float64}:\n#  0.0\n#  0.0\n#  0.0\n#  0.0\n#  0.0\n\nfor i in 1:length(a)\n    a[i] = 2*i^2\nend\n\na\n# 5-element Vector{Float64}:\n#   2.0\n#   8.0\n#  18.0\n#  32.0\n#  50.0\n\nwhile a[i] <= 10\n    println(i, \"\\t\", a[i])\n    i += 1\nend\n# 1       2.0\n# 2       8.0\n```\n\nIn a `while` loop, it is critical to manually implement a step (`i += 1` in the example), or the loop will execute indefinitely!\n\n## Logic and Flow Control\n\nAt some point in your code, you will want to execute different instructions depending on some criteria. The most basic form of flow control is the `if` statement:\n\n``` julia\nif a < 0\n    println(\"Negative\")\nelseif a == 0\n    println(\"Zero\")\nelse\n    println(\"Positive\")\nend\n```\n\nThe `elseif` and `else` blocks are optional. You can have multiple `elseif` blocks with different criteria. You can also nest `if` statements. The `end` statement is a requirement. Unlike many other languages, there is no `then` keyword (`if`...`then`...`else`...`end`).\n\nJulia also offers a short-cut alternative for for simple `if` statements. The following two statements will both print the value `Negative` if `a < 0`.\n\n``` julia\na < 0 && println(\"Negative\")\na >= 0 || println(\"Negative\")\n```\n\nThis looks a little arcane. It works as follows:\n\nThe `&&` operator is a logical `and`. For an `and` statement to be true, both criteria must be true, so if the first statement (before the `&&`) is false, Julia won't bother to evaluate the second statement (after the `&&`), since the whole cannot be true. This is called *short-circuiting evaluation*. This means the `println()` is only executed if `a` is indeed less than zero.\n\nThe `||` operator is a logical `or`. For an `or` statement to be true, either of the two criteria must be true, so if the first statement is true, there is no need need to also evaluate the second - the whole is already true. The `println()` will therefore not be executed if `a` is larger than or equal to zero.\n\n::: callout-tip\nTo help you remember how *short-circuiting evaluations* work, try this:\n\n`a < 0 && println(\"Negative\")` reads as `a < 0` AND then `println()`\n\n`a >= 0 || println(\"Negative\")` reads as `a >= 0` OR else `println()`\n:::\n\nYou may very well choose to stick to more readily understandable `if` statements in your code, but these *short-circuit* notations are commonly used and you will encounter them often in other people's code\n\nFinally, when you are only assigning values to a variable based on some criterium, there is the so-called *ternary operator*:\n\n``` julia\na\n# -1\n\nb = a > 0 ? \"Positive\" : \"Not positive\"\n# \"Not positive\"\n```\n\nThese can be nested as well:\n\n``` julia\nb = a > 0 ? \"Positive\" : (a == 0 ? \"Zero\" : \"Negative\")\n# \"Negative\"\n```\n\nThe parentheses around the final statement are optional, but significantly improves readability.\n\n## Functions\n\nFunctions are the core of any Julia program. Inputs are passed as parameters and any number and type of values can be returned as a tuple. You can also modify the values of array parameters passed to the function. In this case, the function is called *mutating* and it is accepted practise in Julia to end the function name with an exclamation mark (or a bang, if you are American), to indicate that the function mutates one or more parameters. Typically, it would be the first parameter that is mutated.\n\n::: callout-note\nMost people use the terms *parameter* and *argument* interchangeably as they refer to functions. If you want to be strictly formal, then a function is defined to accept *parameters* and you pass specific *argument* values when you call the function. Here, we won't be formal - feel free to use either term.\n:::\n\nThere are four ways to declare a function:\n\n1.  Full declaration\n\n``` julia\nfunction myfunc(a, b)\n    return a + b\nend\n```\n\nThe keyword `return` is optional, but it significantly improves readability. In the absence of a `return` statement, Julia will return the last calculated result. You can also have multiple `return` statements in, e.g., an `if` block. When a `return` is executed (evaluated in Julia parlance), the function will return the specified value and exit.\n\n2.  Short-cut for single-line functions\n\n``` julia\nmyfunc(a, b) = a + b\n```\n\n3.  Anonymous functions, typically used when passing a single-use function to a higher-level function (a function that takes another function as input)\n\n``` julia\nmysum = sum(x -> x^2 + √x, somearray)\n```\n\nHere Julia will apply the function `x -> x^2 + √x` to each entry in the array `somearray` and then add up the results.\n\nYou technically can pass only one parameter to an anonymous function, but since that parameter can be a tuple (and tuples can contain scalars. arrays or even other tuples), there is practically no limit to the number of parameters passed, e.g.\n\n``` julia\nf = (x, y) -> 2x/y^2\n```\n\nHere we also assign the result of the function definition to a variable, `f`, which means we can later call `f(x, y)`. There is really no reason to do this. Rather use the short-cut function definition above.\n\n4.  Do blocks (similar to anonymous functions, but for multi-line functions)\n\n``` julia\nopen(\"myfile.txt\", \"w\") do io\n    write(io, \"Hello world!\")\nend\n```\n\nHere, there are a few things to pay attention to:\n\n-   We are calling the higher-level function `open()`, which takes another function as its first parameter. The `do` block **ALWAYS** passes the specified (anonymous) function to the first parameter of the calling function. The nominal syntax for `open()` is `open(f::Function, args...; kwargs...)`. The function, `f` is specified by the `do` block.\n-   We pass the parameter `io` to the function be specifying `io` next to the keyword `do`. This is similar to the `x -> ...` in an anonymous function, here we effectively have `io -> ...`\n\n### Passing Values to Functions and Returning Results\n\nIn all of the examples so far, we have passed values to the functions. These values are called *parameters* or *arguments*[^3] and there are two types of parameters in Julia: positional parameters and keyword arguments.\n\n[^3]: See the previous comment on this - the terms are often used interchangeably\n\n#### Positional parameters\n\nPositional parameters are parameters where Julia knows which local (to the function) variable to assign the value to, based on the parameter's position in the list of arguments. If we have a function `f(x, y)`, and we call it with `f(1, 2)`, Julia will assign the value of 1 to `x` and 2 to `y`.\n\nPositional parameters can have default values: `f(x, y=2)`. We can now either call the function with `f(2, 4)`, in which case `x` will be assigned a value of 2 and `y` a value of 4, or we can omit the value for `y` and call `f(2)`, in which was `x` will be assigned a value of 2 and `y` will use its default value, also 2.\n\nMultiple parameters can have default values, e.g. `f(x, y=2, z = 3)`. If we now call `f(2)`, `y` and `z` use their default values. What happens when we call `f(2, 10)`?\n\n``` julia\nfunction f(x, y=2, z=4)\n    println(x)\n    println(y)\n    println(z)\nend\n\nf(2)\n# 2\n# 2\n# 4\n\nf(2, 10)\n# 2\n# 10\n# 4\n```\n\nWe see that the second value is passed to `y`, since it is the second positional parameter. Positional values are always assigned left to right, then default values are used for what is left. So how would we pass values for `x` and `z` and have `y` use its default value? The answer is keyword arguments.\n\n#### Keyword arguments\n\nKeyword arguments (a.k.a. keyword parameters, a.k.a. *kwargs*[^4]) are identified by name when passing values to a function. To define them, we first list the positional parameters, then a semi-colon, then the keyword arguments. Keyword arguments **must** all have default values assigned to them.\n\n[^4]: In the spirit of computer science (and technical fields in general) the least understandable option - kwargs - is also the most used one. Go figure.\n\n``` julia\nfunction f(x; y=2, z=4)\n    println(x)\n    println(y)\n    println(z)\nend\n\nf(2)\n# 2\n# 2\n# 4\n```\n\nSo, as expected, `y` and `z` are using their default values. We can now decide to override the defaults for `y`, `z` or both:\n\n``` julia\nf(2, z=3)\n# 2       \n# 2\n# 3\n\nf(2, y=5, z=10)\n# 2\n# 5\n# 10\n```\n\nSince `x` is a positional parameters, a value must always be passed for it, or we get an error:\n\n``` julia\nf(y=5, z=10)\n# ERROR: MethodError: no method matching f(; y::Int64, z::Int64)\n\n# Closest candidates are:\n#   f(::Any; y, z)\n#    @ Main d:\\JuliaCode\\Julia4ER\\Julia for Engineering Research\\scrathpad.jl:42\n```\n\n::: callout-note\nIt is common to find that positional and keyword arguments are separated with a semi-colon at the point where the function is called, e.g. `f(2; y=3, z=5)`. This is just done to emphasise that the parameters after the semi-colon are kwargs, but it is not required. A comma will do just fine.\n:::\n\n#### Returning Results\n\nAs mentioned above, to return values from a function, there are two preferred options:\n\n-   Use the keyword `return`\n-   Mutate (modify) an array passed as parameter to the function\n\nFunctions in Julia will always return a value. Either there is an explicit `return` statement, or the last calculated value is automatically returned. It is good practise to always explicitly return a value. If your function returns nothing, then use `return nothing` to prevent an unexpected and unintended value from being returned.\n\nYou can have multiple `return` statements, but the first one to execute will terminate the function and return to the line after the call to the function.\n\n``` julia\nfunction isnotnegative(x)\n    if x >= 0\n        return true\n    else\n        return false\n    end\nend\n```\n\nor more concisely\n\n``` julia\nfunction isnotnegative(x)\n    return x >= 0\nend\n```\n\nThis is more understandable than the equivalent:\n\n``` julia\nfunction isnotnegative()\n    x >= 0\nend\n```\n\nJulia uses *pass-by-sharing* for parameters passed to functions. If you don't know what that means, you are in good [company](https://discourse.julialang.org/t/i-thought-i-understood-pass-by-sharing-in-julia-until-i-found-this/46897/8).\n\nThe practical implications however are fairly simply to understand. Parameters are immutable - you cannot modify them:\n\n``` julia\nfunction trychangeing(x)\n    println(\"Passed value: $x\")\n    x = 10\n    println(\"Local value: $x\")\nend\n\nx = -1\ntrychangeing(x)\n# Passed value: -1\n# Local value: 10\n\nprintln(\"Value at call site: $x\")\n# Value at call site: -1\n\na = [1]\ntrychangeing(a)\n# Passed value: [1]\n# Local value: 10\n\nprintln(\"Value at call site: $a\")\n# Value at call site: [1]\n```\n\nWhat happens is that Julia creates a new, local variable in the scope of the function, and assigns it the value of the argument that was passed. You can change the values of the parameters, but that does not affect the variables that were passed to the function - `x` and `a` in the examples above.\n\nHow do you then mutate an argument? You cannot change scalar values at all. Neither can you change an array. But the value of an array is just a pointer to some data that it contains, and you *can* change *that* data:\n\n``` julia\nfunction canchange!(x)\n    println(\"Passed value: $x\")\n    x[1] = -10\n    println(\"Local value: $x\")\nend\n\na = [1, 2, 3]\ncanchange!(a)\n# Passed value: [1, 2, 3]\n# Local value: [-10, 2, 3]\n\nprintln(a)\n[-10, 2, 3]\n```\n\n::: callout-note\nNote the addition of the exclamation mark (or \"bang\", for our American friends) to the name of the function. This is not a Julia requirement, just good manners. We inform the user of the code that one or parameter will be mutated. By convention, this will be the first parameter.\n:::\n\nA function returns only one value. What then if you need to return more than one result? Simply return them as a tuple and unpack them at the call site:\n\n``` julia\nfunction sqr_two(a, b)\n    return a^2, b^2 # The parentheses around the tuple are optional\nend\n\na2, b2 = sqr_two(2, 3) # Unpack the returned tuple into the two variables, a2 and b2\nprintln(\"a2 = $a2 and b2 = $b2.\"\n# a2 = 4 and b2 = 9.\n```\n\n#### Slurping and Splatting - Variable number of positional arguments\n\nJulia uses the `...` operator to *slurp* and *splat* values. Slurping means combining multiple scalar values into an array or tuple (slurping them up) and splatting means breaking an array or tuple into a number of scalar values. While this is sometimes used in other places, the most common application is to allow a variable number of parameters to be passed to a function.\n\n``` julia\nfunction confused(a, b, c...)\n    println(\"a is $a\")\n    println(\"b is $b\")\n    println(\"c is $c\")\nend\n\nconfused(1, 2, 3, 4, 5)\n# a is 1  \n# b is 2\n# c is (3, 4, 5)\n```\n\nSplatting allows an array to be passed to a function that expects a number of scalars:\n\n``` julia\nfunction confused2(a, b, c)\n    println(\"a is $a\")\n    println(\"b is $b\")\n    println(\"c is $c\")\nend\n\nx = [1, 2, 3]\nconfused2(x...)\n# a is 1  \n# b is 2\n# c is 3\n\nx = [1, 2, 3, 4]\nconfused2(x...)\n# ERROR: MethodError: no method matching confused2(::Int64, ::Int64, ::Int64, ::Int64)\n\n# Closest candidates are:\n#   confused2(::Any, ::Any, ::Any)\n# ...\n```\n\nThe last example results in an error, as there is no version of the function that accepts four parameters.\n\n## Type Stability and Fast Code\n\nBeing able to change the type of a variable can be useful, but it does also open the door to something that can cause slowdown in your code: **type instability**. This is when the type of x changes during the execution of your code, making many of the optimisations Julia could do, impossible. Instead, additional code is required to handle the type changes. Keep a look-out for something like this:\n\n``` julia\nfunction myfunc(n)\n    sum = 0\n    for i in 1:n\n        sum += 1.5\n    end\n    return sum\nend\n```\n\nAt first glance, there is nothing strange about this code. If you take a closer look however, you will see that `sum` is created as an integer via `sum = 0`, but then we assign floating-point values to it.\n\nJulia has a lot of code analyses tools. One of which is `@code_warntype`:\n\n``` julia\n@code_warntype myfunc(5)\n\nMethodInstance for myfunc(::Int64)\n  from myfunc(n) in Main at REPL[20]:1\nArguments\n  #self#::Core.Const(myfunc)\n  n::Int64\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  sum::Union{Float64, Int64}\n  i::Int64\nBody::Union{Float64, Int64}\n1 ─       (sum = 0)\n│   %2  = (1:n)::Core.PartialStruct(UnitRange{Int64}, Any[Core.Const(1), Int64])\n│         (@_3 = Base.iterate(%2))\n│   %4  = (@_3 === nothing)::Bool\n│   %5  = Base.not_int(%4)::Bool\n└──       goto #4 if not %5\n2 ┄ %7  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Int64\n│         (sum = sum + 1.5)\n│         (@_3 = Base.iterate(%2, %9))\n│   %12 = (@_3 === nothing)::Bool\n│   %13 = Base.not_int(%12)::Bool\n└──       goto #4 if not %13\n3 ─       goto #2\n4 ┄       return sum\n```\n\nLike when we looked at the LLVM code generated for a function, this may seem intimidating, but the important bits are these:\n\n``` julia\nsum::Union{Float64, Int64}\n```\n\nand\n\n``` julia\nBody::Union{Float64, Int64}\n```\n\n::: callout-note\nIn the REPL these are helpfully printed in red to draw your attention.\n:::\n\nJulia indicates that the variable `sum` is not type stable. It is assigned both `Int64` and `Float64`values. This limits the amount of optimisation that is allowed and ends up in slower code.\n\nTo learn more about type stability and many other useful tips to help you write faster code, refer to the [Performance Tips](https://docs.julialang.org/en/v1/manual/performance-tips/) section in the manual.\n\nThe main things to consider, if you want fast code are:\n\n1.  The fastest code is code that you don't need to execute. **Better algorithms always trump more optimised code**\n2.  Avoid type instability in your code.\n3.  Avoid unnecessary memory allocation by re-using arrays where possible.\n\nOnce you have these issues under control, learning to properly benchmark your code (using [BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl)) will allow you to fine tune the performance of your code. Writing fast code is mostly about *not writing slow code*."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"embed-resources":true,"output-file":"04_An_Overview_of_the_Language.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"cosmo","monofont":"JetBrains Mono","smooth-scroll":false,"footnotes-hover":true,"title":"An Overview of the Language"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}