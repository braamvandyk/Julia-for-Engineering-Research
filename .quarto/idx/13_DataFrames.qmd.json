{"title":"DataFrames","markdown":{"yaml":{"title":"DataFrames"},"headingText":"What is a DataFrame?","containsRefs":false,"markdown":"\n\n\nIn short, a DataFrame is a table of data, where each column has a title and a type. Operations can be performed on a per column or per row basis, and columns and rows can be added or removed easily. The [`DataFrames`](https://dataframes.juliadata.org/stable/) package in Julia is the de facto standard for working with tabular data and is integrated in many other packages. In a previous section we have seen that you can read a data file directly into a DataFrame via the `CSV` package, but this is only one example.\n\nThe `DataFrames` package provides a lot of functionality for manipulating the data contain in a DataFrame. There are also additional packages that provide either more options, or alternative (simpler) syntax for convenience, such as `DataFramesMeta` and `Tidier`.\n\nWe shall look at the basic use of DataFrames and leave these auxiliary packages and some more advanced functionality of `DataFrames` for a later section.\n\n### Creating a DataFrame\n\nUsually, you would create a DataFrame by reading in data from a file. You can however also create a DataFrame from variables directly:\n\n``` julia\ndf = DataFrame(X = [1, 2, 3], Y = [2, 3, 4], Z = 2.0)\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Float64\n# ─────┼───────────────────────\n#    1 │     1      2      2.0\n#    2 │     2      3      2.0\n#    3 │     3      4      2.0\n```\n\nNote that columns `X` and `Y` are specified as arrays of integers, and so the columns are typed as `Int64`. `Z` is specified as a floating point value and hence the column is types as `Float64`. The length of `Z` is also expanded to be the same as the other columns, with a fixed value. The column names, `X`, `Y` and `Z`, are all legal Julia symbols (variable names) and so we can use the assignment operator, `=`, here.\n\nYou can also give columns longer names, with spaces, but then instead you need to either use the pair operator, `=>`, or define a `Dict` and then convert that to a DataFrame:\n\n``` julia\ndf = DataFrame(\"X values\" => [1, 2, 3], \"Y values\" => [2, 3, 4], \"Z\" => 2.0)\n# 3×3 DataFrame\n#  Row │ X values  Y values  Z\n#      │ Int64     Int64     Float64\n# ─────┼─────────────────────────────\n#    1 │        1         2      2.0\n#    2 │        2         3      2.0\n#    3 │        3         4      2.0\n\nd = Dict(\"X values\" => [1, 2, 3], \"Y values\" => [2, 3, 4], \"Z\" => 2.0)\n# Dict{String, Any} with 3 entries:\n#   \"Z\"        => 2.0\n#   \"X values\" => [1, 2, 3]\n#   \"Y values\" => [2, 3, 4]\n\ndf = DataFrame(d)\n# 3×3 DataFrame\n#  Row │ X values  Y values  Z\n#      │ Int64     Int64     Float64\n# ─────┼─────────────────────────────\n#    1 │        1         2      2.0\n#    2 │        2         3      2.0\n#    3 │        3         4      2.0\n```\n\n::: callout-caution\nDon't use strings for column names just because you can. Using a symbol, like `:X_values`, instead of the string \"X values\" will give faster results and is just as readable. This does mean you need to use underscores instead of spaces, but all-in-all that is not too high a price to pay.\n:::\n\nA DataFrame can also be constructed one column at a time:\n\n``` julia\ndf = DataFrame()\n# 0×0 DataFrame\n\ndf.A = 1:3\n# 1:3\n\ndf.B = 2:2:6\n# 2:2:6\n\ndf\n# 3×2 DataFrame\n#  Row │ A      B\n#      │ Int64  Int64\n# ─────┼──────────────\n#    1 │     1      2\n#    2 │     2      4\n#    3 │     3      6\n```\n\nOr row by row:\n\n``` julia\ndf = DataFrame(A=String[], B=Int64[])\n# 0×2 DataFrame\n#  Row │ A       B\n#      │ String  Int64\n# ─────┴───────────────\n\npush!(df, (\"Bob\", 1))\n# 1×2 DataFrame\n#  Row │ A       B\n#      │ String  Int64\n# ─────┼───────────────\n#    1 │ Bob         1\n\npush!(df, (\"Tom\", 5))\n# 2×2 DataFrame\n#  Row │ A       B\n#      │ String  Int64\n# ─────┼───────────────\n#    1 │ Bob         1\n#    2 │ Tom         5\n```\n\nNote how we forced types of the columns in the creation of the empty DataFrame. This is needed to give the columns names, and tell the empty DataFrame how many columns it will hold. You could specify the types as `Any`, but that would not lead to god performance.\n\nLastly, you can also convert a matrix to a DataFrame. This requires you to allow DataFrames to automatically generate column names, or pass a vector of names:\n\n``` julia\nm = rand(5, 5)\n# 5×5 Matrix{Float64}:\n#  0.460589   0.734461   0.771352   0.292767   0.0078547\n#  0.254958   0.153814   0.571355   0.196476   0.739701\n#  0.0799407  0.457583   0.553493   0.25409    0.245967\n#  0.106429   0.435509   0.0184347  0.932008   0.805972\n#  0.0877892  0.0231817  0.435262   0.0187286  0.812151\n\ndf = DataFrame(m, :auto) # Automatically generate names\n# 5×5 DataFrame\n#  Row │ x1         x2         x3         x4         x5\n#      │ Float64    Float64    Float64    Float64    Float64\n# ─────┼───────────────────────────────────────────────────────\n#    1 │ 0.460589   0.734461   0.771352   0.292767   0.0078547\n#    2 │ 0.254958   0.153814   0.571355   0.196476   0.739701\n#    3 │ 0.0799407  0.457583   0.553493   0.25409    0.245967\n#    4 │ 0.106429   0.435509   0.0184347  0.932008   0.805972\n#    5 │ 0.0877892  0.0231817  0.435262   0.0187286  0.812151\n\ndf = DataFrame(m, [:X, :Y, :Z, :W, :Q]) # Specify names\n# 5×5 DataFrame\n#  Row │ X          Y          Z          W          Q\n#      │ Float64    Float64    Float64    Float64    Float64\n# ─────┼───────────────────────────────────────────────────────\n#    1 │ 0.460589   0.734461   0.771352   0.292767   0.0078547\n#    2 │ 0.254958   0.153814   0.571355   0.196476   0.739701\n#    3 │ 0.0799407  0.457583   0.553493   0.25409    0.245967\n#    4 │ 0.106429   0.435509   0.0184347  0.932008   0.805972\n#    5 │ 0.0877892  0.0231817  0.435262   0.0187286  0.812151\n```\n\n### Accessing the Data\n\nOnce the data is in a DataFrame, you can access column like they are individual vectors:\n\n``` julia\ndf.X\n# 5-element Vector{Float64}:\n#  0.460589206535297\n#  0.25495814887990786\n#  0.07994066869519556\n#  0.10642869978604408\n#  0.0877892134158087\n```\n\nYou can also add columns, even via calculations:\n\n``` julia\ndf.New = (df.X).^2 .- df.Y\n# 5-element Vector{Float64}:\n#  -0.5223183397440386\n#  -0.08881079559662731\n#  -0.45119243718262425\n#  -0.42418203290738643\n#  -0.015474773743873368\n\ndf\n# 5×6 DataFrame\n#  Row │ X          Y          Z          W          Q          New\n#      │ Float64    Float64    Float64    Float64    Float64    Float64\n# ─────┼───────────────────────────────────────────────────────────────────\n#    1 │ 0.460589   0.734461   0.771352   0.292767   0.0078547  -0.522318\n#    2 │ 0.254958   0.153814   0.571355   0.196476   0.739701   -0.0888108\n#    3 │ 0.0799407  0.457583   0.553493   0.25409    0.245967   -0.451192\n#    4 │ 0.106429   0.435509   0.0184347  0.932008   0.805972   -0.424182\n#    5 │ 0.0877892  0.0231817  0.435262   0.0187286  0.812151   -0.0154748\n```\n\nNote the use of broadcasting in the first command - using `.^` instead of `^` and `.-` instead of `-`. This tells Julia to execute these operations on in element-wise fashion. The new column, `df.Z` is added to the DataFrame automatically.\n\nYou can also access individual entries by specifying the row and column, the latter using either the names or indexes:\n\n``` julia\ndf[2, 3] # Row 2, Column 3 (Z)\n# 0.5713552793835407\n\ndf[2:3, 3:5]\n# 2×3 DataFrame\n#  Row │ Z         W         Q\n#      │ Float64   Float64   Float64\n# ─────┼──────────────────────────────\n#    1 │ 0.571355  0.196476  0.739701\n#    2 │ 0.553493  0.25409   0.245967\n\ndf[1:3, :W]\n# 3-element Vector{Float64}:\n#  0.29276715395306163\n#  0.19647571959450094\n#  0.25409034700483624\n```\n\nTo select an entire row or column, the `:` operator is used, just like in Arrays. This returns a copy of the slice of the DataFrame. When using a `!`, however, a view to the data is returns. Modifying the view will modify the contents of the DataFrame as well:\n\n``` julia\ndf = DataFrame(X = [1, 2, 3], Y = [2, 4, 6], Z = [3, 6, 9])\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Int64\n# ─────┼─────────────────────\n#    1 │     1      2      3\n#    2 │     2      4      6\n#    3 │     3      6      9\n\nxvals = df[:, :X]\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nxvals[1] = 100\n# 100\n\ndf\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Int64\n# ─────┼─────────────────────\n#    1 │     1      2      3\n#    2 │     2      4      6\n#    3 │     3      6      9\n\nxview = df[!, :X]\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nxview[1] = 100\n# 100\n\ndf\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Int64\n# ─────┼─────────────────────\n#    1 │   100      2      3\n#    2 │     2      4      6\n#    3 │     3      6      9\n```\n\nYou can also select just specific rows and columns:\n\n``` julia\ndf[[1, 3], [1, 3]]\n# 2×2 DataFrame\n#  Row │ X      Z     \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      3\n#    2 │     3      9\n```\n\n### Data Wrangling with DataFrames\n\nData wrangling is the pre-processing of your data to get it into the form you need for the modelling or analysis you intend to do with it. This can include many steps. DataFrames has a rich feature set to support you in this. We'll look at several examples here, but if you are going to be doing this type of work often, save yourself a lot of page-turning and download, print and laminate a copy of the [**Data Wrangling with DataFrames.jl Cheat Sheet**](https://www.ahsmart.com/assets/pages/data-wrangling-with-data-frames-jl-cheat-sheet/DataFramesCheatSheet_v1.x_rev1.pdf)\n\nWe start off by creating a dataset to work with:\n\n``` julia\ndf = DataFrame(X = 1:3:1500, Y = repeat(1:100, outer=5), Z = repeat(1:100, inner=5)\n# 500×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      1 \n#    2 │     4      2      1 \n#    3 │     7      3      1 \n#    4 │    10      4      1 \n#    5 │    13      5      1 \n#    6 │    16      6      2 \n#    7 │    19      7      2 \n#    8 │    22      8      2 \n#    9 │    25      9      2 \n#   ⋮  │   ⋮      ⋮      ⋮   \n#  492 │  1474     92     99 \n#  493 │  1477     93     99\n#  494 │  1480     94     99\n#  495 │  1483     95     99\n#  496 │  1486     96    100\n#  497 │  1489     97    100\n#  498 │  1492     98    100\n#  499 │  1495     99    100\n#  500 │  1498    100    100\n#            482 rows omitted\n\nfirst(df,3)\n# 3×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      1\n#    2 │     4      2      1\n#    3 │     7      3      1\n\nlast(df,4)\n# 4×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │  1489     97    100\n#    2 │  1492     98    100\n#    3 │  1495     99    100\n#    4 │  1498    100    100\n\nnames(df)\n# 3-element Vector{String}:\n#  \"X\"\n#  \"Y\"\n#  \"Z\"\n\ndescribe(df)\n# 3×7 DataFrame\n#  Row │ variable  mean     min    median   max    nmissing  eltype   \n#      │ Symbol    Float64  Int64  Float64  Int64  Int64     DataType \n# ─────┼──────────────────────────────────────────────────────────────\n#    1 │ X           749.5      1    749.5   1498         0  Int64\n#    2 │ Y            50.5      1     50.5    100         0  Int64\n#    3 │ Z            50.5      1     50.5    100         0  Int64\n```\n\nIn generating this data, we used Julia's `repeat` function. For the `Y` column, we specify `outer=5`, which means the data (`1:100`) is repeated 5 times as a set, i.e. 1 to 100, then 1 to 100 again, for a total of 5 times. For the `Z` column, we specify `inner=5`, which means each of the values from 1 to 100 is repeated 5 times: 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,... etc.\n\nWe can quickly see the first or last few entries using the Julia functions `first` and `last`, with the second parameter showing how many entries to display. The number of rows displayed by Julia for the full DataFrame depends on the size of the window it is being displayed in. The middle omitted rows are indicated with the `⋮` characters. If the DataFrame is too wide, columns will also be omitted, with a message indicating how many columns are hidden.\n\nIf you **really** want to see all the rows or columns, you can call `show` and specify `allrows=true` and/or `allcols=true`\n\n``` julia\nshow(df, allrows=true, allcols=true)\n```\n\nFor obvious reasons, we won't include the 500 rows of data here.\n\nThe `names()` function returns a vector of the column names as strings. You can also get summary statistics of the data with the `describe()` function.\n\nIf you only want specific statistics, you can specify them in the call:\n\n``` julia\ndescribe(df, :mean, :std)\n# 3×3 DataFrame\n#  Row │ variable  mean     std     \n#      │ Symbol    Float64  Float64 \n# ─────┼────────────────────────────\n#    1 │ X           749.5  433.445\n#    2 │ Y            50.5   28.895\n#    3 │ Z            50.5   28.895\n```\n\nYou can also apply a custom function to describe the data. Here we use the Julia function `extrema()`, which returns the minimum and maximum value in an array. We'll specify that we want the results in a column call `minmax`:\n\n``` julia\ndescribe(df, extrema => :minmax)\n# 3×2 DataFrame\n#  Row │ variable  minmax    \n#      │ Symbol    Tuple…    \n# ─────┼─────────────────────\n#    1 │ X         (1, 1498)\n#    2 │ Y         (1, 100)\n#    3 │ Z         (1, 100)\n```\n\nLastly, the number of rows and column can be easily retrieved:\n\n``` julia\nnrow(df)\n# 500\n\nncol(df)\n# 6\n```\n\n#### Selecting and Transforming Data\n\n##### Selecting Columns\n\nIn the introductory section, we selected specific rows and column based on their indices. You can also select columns based on their names:\n\n``` julia\nselect(df, [:X, :Z])\n# 500×2 DataFrame     \n#  Row │ X      Z     \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      1\n#    2 │     4      1\n#    3 │     7      1\n#   ⋮  │   ⋮      ⋮\n#  498 │  1492    100\n#  499 │  1495    100\n#  500 │  1498    100\n#     494 rows omitted\n```\n\nThere are also selector function to allow for selection of ranges of columns:\n\n-   `Not()`: Select all the columns expect the specified one(s)\n-   `Between()`: Select all column starting with the first specified column and ending with the second. You can use names or indices to specify the columns\n-   `Cols()`: Use this to combine other selector functions\n-   `All()`: Select all columns - same as specifying `:`\n\n**Examples:**\n\nIn the previous example we selected columns `X` and `Z`, which is the same as selecting everything expect `Y`:\n\n``` julia\nselect(df, Not(:Y))\n# 500×2 DataFrame\n#  Row │ X      Z     \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      1\n#    2 │     4      1\n#    3 │     7      1\n#   ⋮  │   ⋮      ⋮\n#  498 │  1492    100\n#  499 │  1495    100\n#  500 │  1498    100\n#     494 rows omitted\n```\n\nWe only passed a single symbol to `Not`, but could also pass an array of symbols to exclude multiple columns.\n\nTo make things more interesting, we can first add a few more columns:\n\n``` julia\ndf.A = 2 .* df.X\ndf.B = df.Y .+ df.Z\ndf.C = df.Z .^ 2\ndf\n# 500×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │     4      2      1      8      3      1\n#    3 │     7      3      1     14      4      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  498 │  1492     98    100   2984    198  10000\n#  499 │  1495     99    100   2990    199  10000\n#  500 │  1498    100    100   2996    200  10000\n#                                 494 rows omitted\n```\n\n``` julia\nselect(df, Cols(:A, Between(:X, :Z)))\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\n```\n\nHere we used `Cols` to combine selecting column `A` and all columns from `X` to `Z`. This also changed the order of the columns.\n\nWe used the `select` function to do the selections, but could as easily have used the normal array-type notation:\n\n``` julia\ndf[:, Cols(:A, Between(:X, :Z))]\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\n```\n\nTo permanently change the DataFrame, either assign the returned result to the same variable, or use the mutating version of `select()`: `select!()`.\n\n``` julia\ndf = select(df, Cols(:A, Between(:X, :Z)))\ndf\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\n```\n\nor\n\n``` julia\nselect!(df, Cols(:A, Between(:X, :Z)))\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1 Da\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\n```\n\nIt is also possible to select columns from a DataFrame that match to a *regular expression*. This is a template that describes a string of text. For more information, see one the many [tutorials](https://www.regular-expressions.info/tutorialcnt.html) on the web.\n\n``` julia\ndf = DataFrame(\n    Names = [\"Tom\", \"Dick\", \"Harry\"], \n    AddressLine1 = [\"2 Maple Drive\", \"4 Oak Street\", \"6 Pine Road\"],\n    AddressLine2 = [\"Hopetown\", \"Smallville\", \"Metropolis\"],\n    AddressZip = [1234, 2345, 3456]\n)\n3×4 DataFrame\n#  Row │ Names   AddressLine1   AddressLine2  AddressZip \n#      │ String  String         String        Int64      \n# ─────┼─────────────────────────────────────────────────\n#    1 │ Tom     2 Maple Drive  Hopetown            1234\n#    2 │ Dick    4 Oak Street   Smallville          2345\n#    3 │ Harry   6 Pine Road    Metropolis          3456\n\n\ndf[:, r\"Addr\"]\n# 3×3 DataFrame\n#  Row │ AddressLine1   AddressLine2  AddressZip \n#      │ String         String        Int64      \n# ─────┼─────────────────────────────────────────\n#    1 │ 2 Maple Drive  Hopetown            1234\n#    2 │ 4 Oak Street   Smallville          2345\n#    3 │ 6 Pine Road    Metropolis          34\n```\n\nHere we select all rows, but only the column that have the substring \"Addr\" in their names.\n\n##### Selecting Rows (Filtering) and Sorting\n\nYou can select rows by filtering the data. There are two equivalent ways:\n\n``` julia\nfilter(:X => <=(10), df)\n# 4×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │     4      2      1      8      3      1\n#    3 │     7      3      1     14      4      1\n#    4 │    10      4      1     20      5      1\n\ndf[df.X .<= 10, :]\n# 4×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │     4      2      1      8      3      1\n#    3 │     7      3      1     14      4      1\n#    4 │    10      4      1     20      5      1\n```\n\nIn both cases we pass a *predicate* function, i.e. a function that returns `true` for rows that should be included. In the first case, a pair operator links a column name to the predicate function and in the second case we simply pass an expression that returns true for all the correct instances. Note the use of broadcasting in the second example.\n\nYou can use any predicate function. A new useful ones include:\n\n``` julia\ndf[findfirst(==(4), df.C), :] # Find the first row where column C has a value of 4\n# DataFrameRow\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    6 │    16      6      2     32      8      4\n\ndf[findall(==(4), df.C), :] # Find all rows where column C has a value of 4\n# 5×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │    16      6      2     32      8      4\n#    2 │    19      7      2     38      9      4\n#    3 │    22      8      2     44     10      4\n#    4 │    25      9      2     50     11      4\n#    5 │    28     10      2     56     12      4\n\ndf[df.C .== 4, :] # Find all rows where column C has a value of 4, alternative form\n# 5×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │    16      6      2     32      8      4\n#    2 │    19      7      2     38      9      4\n#    3 │    22      8      2     44     10      4\n#    4 │    25      9      2     50     11      4\n#    5 │    28     10      2     56     12      4\n```\n\nIt may also be useful to sort the data according to specified columns:\n\n``` julia\nsort(df, :Y)\n# 500×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │   301      1     21    602     22    441\n#    3 │   601      1     41   1202     42   1681\n#    4 │   901      1     61   1802     62   3721\n#    5 │  1201      1     81   2402     82   6561\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  497 │   598    100     40   1196    140   1600\n#  498 │   898    100     60   1796    160   3600\n#  499 │  1198    100     80   2396    180   6400\n#  500 │  1498    100    100   2996    200  10000\n#                                 491 rows omitted\n\nsort(df, [:Y, :B])\n# 500×6 DataFrame\n#  Row │ X      Y      Z      A      B      C\n#      │ Int64  Int64  Int64  Int64  Int64  Int64\n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │   301      1     21    602     22    441\n#    3 │   601      1     41   1202     42   1681\n#    4 │   901      1     61   1802     62   3721\n#    5 │  1201      1     81   2402     82   6561\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  497 │   598    100     40   1196    140   1600\n#  498 │   898    100     60   1796    160   3600\n#  499 │  1198    100     80   2396    180   6400\n#  500 │  1498    100    100   2996    200  10000\n#                                 491 rows omitted\n```\n\n##### Applying Function to Columns and Rows\n\nApplying a function to a column or multiple columns has been shown before when we added columns to a DataFrame. Since each column acts like a vector, we simply use normal Julia broadcasting to apply functions to whole columns:\n\n``` julia\ndf.BdivC = df.B ./ df.C\n# 500-element Vector{Float64}:\n#  2.0\n#  3.0\n#  4.0\n#  5.0\n#  6.0\n#  2.0\n#  2.25\n#  ⋮\n#  0.01979389858177737\n#  0.0196\n#  0.0197\n#  0.0198\n#  0.0199\n#  0.02\n\n# df\n# 500×7 DataFrame\n#  Row │ X      Y      Z      A      B      C      BdivC     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64  Float64   \n# ─────┼─────────────────────────────────────────────────────\n#    1 │     1      1      1      2      2      1  2.0\n#    2 │     4      2      1      8      3      1  3.0\n#    3 │     7      3      1     14      4      1  4.0\n#    4 │    10      4      1     20      5      1  5.0\n#    5 │    13      5      1     26      6      1  6.0\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮        ⋮\n#  497 │  1489     97    100   2978    197  10000  0.0197\n#  498 │  1492     98    100   2984    198  10000  0.0198\n#  499 │  1495     99    100   2990    199  10000  0.0199\n#  500 │  1498    100    100   2996    200  10000  0.02\n#                                            491 rows omitted\n```\n\nIn order to apply functions across rows, we need to use some of the built-in functions of DataFrames, `select` and `transform`, along with `ByRow`.\n\nThe basic syntax is:\n\n`select(df, <array of columns to select>)` `select(df, <array of columns to select>, <array of columns to pass to function> => <function> => <name(s) of column(s) to hold result>)` `select(df, AsTable(:) => <function> => <name(s) of column(s) to hold result>)` \\# pass the entire table to the function\n\nSome examples:\n\n``` julia\n\nselect(df, :X, :X => cumsum => :cumX) # Put the cumulative sum of X in column cumX\n# 500×2 DataFrame\n#  Row │ X      cumX   \n#      │ Int64  Int64  \n# ─────┼───────────────\n#    1 │     1       1\n#    2 │     4       5\n#    3 │     7      12\n#    4 │    10      22\n#    5 │    13      35\n#   ⋮  │   ⋮      ⋮\n#  497 │  1489  370265\n#  498 │  1492  371757\n#  499 │  1495  373252\n#  500 │  1498  374750\n#      491 rows omitted\n\nselect(df, [:X, :Y], [:X, :Y] => ByRow((x, y) -> sin(x)*cos(y)) => :sinXcosY) # Put the value of sin(X)*cos*(Y) in column sinXcosY\n# 500×3 DataFrame\n#  Row │ X      Y      sinXcosY    \n#      │ Int64  Int64  Float64     \n# ─────┼───────────────────────────\n#    1 │     1      1   0.454649\n#    2 │     4      2   0.314941\n#    3 │     7      3  -0.650412\n#    4 │    10      4   0.355596\n#    5 │    13      5   0.119185\n#   ⋮  │   ⋮      ⋮         ⋮\n#  497 │  1489     97   0.106082\n#  498 │  1492     98  -0.207859\n#  499 │  1495     99  -0.0154374\n#  500 │  1498    100   0.443124\n#                  491 rows omitted\n\nselect(df, AsTable(:) => ByRow(extrema) => [:min, :max]) # Find the smallest and largest value in each row\n# 500×2 DataFrame\n#  Row │ min    max   \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      2\n#    2 │     1      8\n#    3 │     1     14\n#    4 │     1     20\n#    5 │     1     26\n#   ⋮  │   ⋮      ⋮\n#  497 │    97  10000\n#  498 │    98  10000\n#  499 │    99  10000\n#  500 │   100  10000\n#     491 rows omitted\n```\n\nIn each case, we used `select` and it only returned the specified columns. If we instead call `transform`, the entire DataFrame is returned, as well as any new columns added in the calculations, e.g.\n\n``` julia\ntransform(df, AsTable(:) => ByRow(extrema) => [:min, :max])\n# 500×8 DataFrame\n#  Row │ X      Y      Z      A      B      C      min    max   \n#      │ Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────────────────────────────────\n#    1 │     1      1      1      2      2      1      1      2\n#    2 │     4      2      1      8      3      1      1      8\n#    3 │     7      3      1     14      4      1      1     14\n#    4 │    10      4      1     20      5      1      1     20\n#    5 │    13      5      1     26      6      1      1     26\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  497 │  1489     97    100   2978    197  10000     97  10000\n#  498 │  1492     98    100   2984    198  10000     98  10000\n#  499 │  1495     99    100   2990    199  10000     99  10000\n#  500 │  1498    100    100   2996    200  10000    100  10000\n#                                               491 rows omitted\n```\n\nJust like before, `select` and `transform` return new DataFrames, while `select!` and `transform!` will modify the existing DataFrame.\n\n### Grouping Data\n\nDataFrames will group your data by column values through the `groupby()` function. One or more columns can be specified and you will get a GroupedDataFrame - a container of `SubDataFrame`s for each unique combination of the values in the specified columns.\n\n``` julia\ndf = DataFrame(X = 1:50, Y = repeat(1:2, outer=25), Z = repeat(2:2:10, inner=10))\n# 50×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      2 \n#    2 │     2      2      2\n#    3 │     3      1      2\n#    4 │     4      2      2\n#    5 │     5      1      2\n#    6 │     6      2      2\n#   ⋮  │   ⋮      ⋮      ⋮\n#   45 │    45      1     10\n#   46 │    46      2     10\n#   47 │    47      1     10\n#   48 │    48      2     10\n#   49 │    49      1     10\n#   50 │    50      2     10\n#             38 rows omitted\n\ngdf = groupby(df, [:Y, :Z]\n# GroupedDataFrame with 10 groups based on keys: Y, Z\n# First Group (5 rows): Y = 1, Z = 2\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      2\n#   ⋮  │   ⋮      ⋮      ⋮\n#    5 │     9      1      2\n#              3 rows omitted\n# ⋮\n# Last Group (5 rows): Y = 2, Z = 10\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │    42      2     10\n#   ⋮  │   ⋮      ⋮      ⋮\n#    5 │    50      2     10\n#              3 rows omitted\n\ncounts = select(gdf, nrow, :X => mean)\n# 50×4 DataFrame\n#  Row │ Y      Z      nrow   X_mean  \n#      │ Int64  Int64  Int64  Float64 \n# ─────┼──────────────────────────────\n#    1 │     1      2      5      5.0\n#    2 │     2      2      5      6.0\n#    3 │     1      2      5      5.0\n#    4 │     2      2      5      6.0\n#    5 │     1      2      5      5.0\n#    6 │     2      2      5      6.0\n#   ⋮  │   ⋮      ⋮      ⋮       ⋮\n#   45 │     1     10      5     45.0\n#   46 │     2     10      5     46.0\n#   47 │     1     10      5     45.0\n#   48 │     2     10      5     46.0\n#   49 │     1     10      5     45.0\n#   50 │     2     10      5     46.0\n#                      38 rows omitted\n```\n\nHere we create a DataFrame with three columns: `X` ranges from 1 to 50, `Y` alternates between 1 and 2, and `Z` is a sequence of the even numbers from 2 to 10. We then group by `Y` and `Z`, which gives us a `GroupedDataFrame` with 10 groups, for the 10 unique combinations of values in `Y` and `Z`. The last command created a new DataFrame, called `counts` which contains the number of rows in each of the 10 `SubDataFrame`s in our `GroupedDataFrame` (`gdf`) as well as the mean[^1] value of the `X` column in each of the 10 groups.\n\n[^1]: Note that to use the `mean` function, you need to first include the `Statistics` standard library\n\n#### A More Complete Example\n\nFor this example, we use a dataset from [Kaggle](https://www.kaggle.com/datasets/uom190346a/food-ingredients-and-allergens). The data file includes information on the ingredients of 399 types of food.\n\n```julia\ndf = CSV.read(raw\"D:\\JuliaCode\\KaggleData\\food_ingredients_and_allergens.csv\", DataFrame; normalizenames=true)\nselect!(df, [:Food_Product, :Allergens])\n# 399×2 DataFrame\n#  Row │ Food_Product             Allergens\n#      │ String                   String31\n# ─────┼─────────────────────────────────────────────────\n#    1 │ Almond Cookies           Almonds, Wheat, Dairy\n#    2 │ Almond Cookies           Almonds, Wheat, Dairy\n#    3 │ Chicken Noodle Soup      Chicken, Wheat, Celery\n#    4 │ Chicken Noodle Soup      Chicken, Wheat, Celery\n#    5 │ Cheddar Cheese           Dairy\n#    6 │ Ranch Dressing           Dairy\n#    7 │ Caramel Popcorn          Dairy\n#    8 │ Caesar Salad             Dairy\n#   ⋮  │            ⋮                       ⋮\n#  393 │ Chocolate Chip Pancakes  Wheat, Dairy, Cocoa\n#  394 │ Lemon Bars               Wheat, Dairy, Eggs\n#  395 │ Lemon Bars               Wheat, Dairy, Eggs\n#  396 │ Pecan Pie                Wheat, Dairy, Nuts\n#  397 │ Zucchini Bread           Wheat, Dairy, Nuts\n#  398 │ Banana Bread             Wheat, Dairy, Nuts\n#  399 │ Hawaiian Pizza           Wheat, Pork, Dairy\n#                                        384 rows omitted\n```\n\nWe are going to focus on the allergens in these foods. We select to keep only the two column containing the names of the foods and the allergens contained in them. Unfortunately, the allergens are given as a single string of comma-separated values. This means we have to do a little processing of the data. \n\nWe ideally want a separate column for each allergen that contains a `true` (1) or `false` (0) to indicate if the allergen is present or not. To get this, we must process all the entries on allergens and split the strings into the individual allergens. We then need to identify the unique values, and add a true or false in a new column for each food and each allergen. This sounds like a lot of work, but Julia makes this easy.\n\n```julia\nallAllergens = String[]\nfor row in eachrow(df)\n    allergens = row.Allergens\n    for s in eachsplit(allergens, \", \")\n        push!(allAllergens, s)\n    end\nend\nunique!(allAllergens)\n\n# 24-element Vector{String}:\n#  \"Almonds\"\n#  \"Wheat\"\n#  \"Dairy\"\n#  \"Chicken\"\n#  \"Celery\"\n#  \"Anchovies\"\n#  \"Cocoa\"\n#  ⋮\n#  \"Oats\"\n#  \"Peanuts\"\n#  \"Pine nuts\"\n#  \"Rice\"\n#  \"Shellfish\"\n#  \"Pork\"\n#  \"Alcohol\"\n```\n\nWe create an empty vector of `String`s to hold the allergen names - `allAllergens`. Then we iterate trough the DataFrame, one row at a time, using the `eachrow` iterator. We extract the string holding the allergens into a temporary string `allergens` with `allergens = row.Allergens` (where `row` is the current row in the iterator `eachrow`).\n\nTo split the string (`allergens`) into the various allergens, we use the Julia function `eachsplit`, which splits the string with the specified delimiter (\", \"), and returns an iterator of substrings. We loop through this iterator and push each substring into the empty vector we created at the start.\n\nLastly, we use the Julia function `unique!` to remove all duplicates from this vector. We now have a list of 24 possible allergens.\n\n```julia\nfor allergen in allAllergens\n    transform!(df, :Allergens => ByRow(s -> contains(string(s), allergen)) => Symbol(allergen))\nend\n\ndf[:, [:Food_Product, :Almonds, :Wheat, :Dairy]]\n# 399×4 DataFrame\n#  Row │ Food_Product             Almonds  Wheat  Dairy \n#      │ String                   Bool     Bool   Bool  \n# ─────┼────────────────────────────────────────────────\n#    1 │ Almond Cookies              true   true   true\n#    2 │ Almond Cookies              true   true   true\n#    3 │ Chicken Noodle Soup        false   true  false\n#    4 │ Chicken Noodle Soup        false   true  false\n#    5 │ Cheddar Cheese             false  false   true\n#    6 │ Ranch Dressing             false  false   true\n#   ⋮  │            ⋮                ⋮       ⋮      ⋮\n#  394 │ Lemon Bars                 false   true   true\n#  395 │ Lemon Bars                 false   true   true\n#  396 │ Pecan Pie                  false   true   true\n#  397 │ Zucchini Bread             false   true   true\n#  398 │ Banana Bread               false   true   true\n#  399 │ Hawaiian Pizza             false   true   true\n#                                       387 rows omitted\n```\n\nWe now run through our newly created list of allergens and call the DataFrames function `transform!` for each allergen. `transform!` is the mutating version of `transform` and will modify the specified DataFrame rather than return a new object. `transform` includes all of the columns in the original DataFrame, unlike `select`, which will include only the specified columns.\n\nWe specify here than we want to take the contents of the `Allergens` column, and pass it, one row at a time (`ByRow()`) to an anonymous function ()`s -> contains(string(s), allergen))`) and store the result in a new column `Symbol(allergen)`. Note that we are converting the name of the allergen, which is a `String` to a `Symbol`, which is what DataFrames expects here.\n\nThe anonymous function we define essentially only calls the Julia function `contains`, which will return a `true` or `false` depending on whether the string contains a specified substring. We convert the value from the DataFrame to a string (with the `string()` function), as DataFrames uses a more specialised data type for string values to save memory and improve performance. We have a quick look at three of the allergens and see that we indeed have exactly what we wanted.\n\nWe can now analyse the data any way we want to. Let's group the data to see combinations of almonds and wheat in the various foods:\n\n```julia\ngdf = groupby(df, [:Almonds, :Wheat])\n\nfor (keys, sdf) in pairs(gdf)\n    println(\"Number of foods with $keys: $(nrow(sdf))\")\nend\n\n# Number of foods with GroupKey: (Almonds = true, Wheat = true): 2\n# Number of foods with GroupKey: (Almonds = false, Wheat = true): 94\n# Number of foods with GroupKey: (Almonds = false, Wheat = false): 303\n```\n\n### Joining DataFrames\n\nDataFrames allows for joining of tables, just like in a SQL database. We shall give a few key definitions here to illustrate the concept.\n\nFirstly, what is a *join*? It is a combination of two tables, based on the values in a specified column, typically an ID or similar index value. The resulting table may include columns from one or both of the tables, for the rows that are included in the joined table, depending on the type of join.\n\nWe define two DataFrames to use in our examples:\n\n```julia\ndf1 = DataFrame(ID = [1, 2, 3], Floor = [\"A\", \"B\", \"C\"], Office = [11, 12, 12])\n# 3×3 DataFrame\n#  Row │ ID     Floor   Office \n#      │ Int64  String  Int64  \n# ─────┼───────────────────────\n#    1 │     1  A           11\n#    2 │     2  B           12\n#    3 │     3  C           12\n\ndf2 = DataFrame(ID = [1, 2, 7, 11], Name = [\"Tom\", \"Dan\", \"Harry\", \"Bob\"])\n# 4×2 DataFrame\n#  Row │ ID     Name   \n#      │ Int64  String \n# ─────┼───────────────\n#    1 │     1  Tom\n#    2 │     2  Dan\n#    3 │     7  Harry\n#    4 │    11  Bob\n```\n**Inner join**: An inner join between two tables will include only the rows where the field (e.g. ID) on which you join, are the same in each table. Rows that include a value of ID that is only present in one of the two tables will not be included. All columns from both tables are included.\n\n\n```julia\ninnerjoin(df1, df2, on=:ID)\n# 2×4 DataFrame\n#  Row │ ID     Floor   Office  Name   \n#      │ Int64  String  Int64   String \n# ─────┼───────────────────────────────\n#    1 │     1  A           11  Tom\n#    2 │     2  B           12  Dan\n```\n\n**Left join**: A left join between two tables will include all the rows from the *left* table, as well as those rows from *right* table where the joining field (e.g. ID) match. All columns are included, which may result in `missing` values in columns from the *right* table.\n\n\n```julia\nleftjoin(df1, df2, on=:ID)\n# 3×4 DataFrame\n#  Row │ ID     Floor   Office  Name    \n#      │ Int64  String  Int64   String? \n# ─────┼────────────────────────────────\n#    1 │     1  A           11  Tom\n#    2 │     2  B           12  Dan\n#    3 │     3  C           12  missing \n```\n\n**Right join**: Similar to a *left join*, but all rows from the *right table* are included and only matching rows from the *left* table. This may result in `missing` values in columns from the *left* table.\n\n\n```julia\nrightjoin(df1, df2, on=:ID)\n# 4×4 DataFrame\n#  Row │ ID     Floor    Office   Name   \n#      │ Int64  String?  Int64?   String \n# ─────┼─────────────────────────────────\n#    1 │     1  A             11  Tom\n#    2 │     2  B             12  Dan\n#    3 │     7  missing  missing  Harry\n#    4 │    11  missing  missing  Bob\n```\n\n**Outer join**: This will include all rows from both *left* and *right* tables, possibly resulting in `missing` values in all columns.\n\n\n```julia\n# outerjoin(df1, df2, on=:ID)\n# 5×4 DataFrame\n#  Row │ ID     Floor    Office   Name    \n#      │ Int64  String?  Int64?   String? \n# ─────┼──────────────────────────────────\n#    1 │     1  A             11  Tom\n#    2 │     2  B             12  Dan\n#    3 │     3  C             12  missing \n#    4 │     7  missing  missing  Harry\n#    5 │    11  missing  missing  Bob\n```\n**Semi join** (a.k.a. **Left semi join**): Like an inner join, this will only return rows that match in both columns, but will only return columns from the *left* table. This is useful if you want to select, for example, names from a list that are also present in another list, without including additional data from that list. To do a *right semi join*, just reverse the order to the two `DataFrame`s.\n\n\n```julia\nsemijoin(df1, df2, on=:ID)\n# 2×3 DataFrame\n#  Row │ ID     Floor   Office \n#      │ Int64  String  Int64  \n# ─────┼───────────────────────\n#    1 │     1  A           11\n#    2 │     2  B           12\n```\n\n**Anti join** (a.k.a. **Left anti join**): Like the semi join, but will only return rows from the *left* table that are **NOT** matched in the *right* table.\n\n\n```julia\nantijoin(df1, df2, on=:ID)\n# 1×3 DataFrame\n#  Row │ ID     Floor   Office \n#      │ Int64  String  Int64  \n# ─────┼───────────────────────\n#    1 │     3  C           12\n```\n","srcMarkdownNoYaml":"\n\n## What is a DataFrame?\n\nIn short, a DataFrame is a table of data, where each column has a title and a type. Operations can be performed on a per column or per row basis, and columns and rows can be added or removed easily. The [`DataFrames`](https://dataframes.juliadata.org/stable/) package in Julia is the de facto standard for working with tabular data and is integrated in many other packages. In a previous section we have seen that you can read a data file directly into a DataFrame via the `CSV` package, but this is only one example.\n\nThe `DataFrames` package provides a lot of functionality for manipulating the data contain in a DataFrame. There are also additional packages that provide either more options, or alternative (simpler) syntax for convenience, such as `DataFramesMeta` and `Tidier`.\n\nWe shall look at the basic use of DataFrames and leave these auxiliary packages and some more advanced functionality of `DataFrames` for a later section.\n\n### Creating a DataFrame\n\nUsually, you would create a DataFrame by reading in data from a file. You can however also create a DataFrame from variables directly:\n\n``` julia\ndf = DataFrame(X = [1, 2, 3], Y = [2, 3, 4], Z = 2.0)\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Float64\n# ─────┼───────────────────────\n#    1 │     1      2      2.0\n#    2 │     2      3      2.0\n#    3 │     3      4      2.0\n```\n\nNote that columns `X` and `Y` are specified as arrays of integers, and so the columns are typed as `Int64`. `Z` is specified as a floating point value and hence the column is types as `Float64`. The length of `Z` is also expanded to be the same as the other columns, with a fixed value. The column names, `X`, `Y` and `Z`, are all legal Julia symbols (variable names) and so we can use the assignment operator, `=`, here.\n\nYou can also give columns longer names, with spaces, but then instead you need to either use the pair operator, `=>`, or define a `Dict` and then convert that to a DataFrame:\n\n``` julia\ndf = DataFrame(\"X values\" => [1, 2, 3], \"Y values\" => [2, 3, 4], \"Z\" => 2.0)\n# 3×3 DataFrame\n#  Row │ X values  Y values  Z\n#      │ Int64     Int64     Float64\n# ─────┼─────────────────────────────\n#    1 │        1         2      2.0\n#    2 │        2         3      2.0\n#    3 │        3         4      2.0\n\nd = Dict(\"X values\" => [1, 2, 3], \"Y values\" => [2, 3, 4], \"Z\" => 2.0)\n# Dict{String, Any} with 3 entries:\n#   \"Z\"        => 2.0\n#   \"X values\" => [1, 2, 3]\n#   \"Y values\" => [2, 3, 4]\n\ndf = DataFrame(d)\n# 3×3 DataFrame\n#  Row │ X values  Y values  Z\n#      │ Int64     Int64     Float64\n# ─────┼─────────────────────────────\n#    1 │        1         2      2.0\n#    2 │        2         3      2.0\n#    3 │        3         4      2.0\n```\n\n::: callout-caution\nDon't use strings for column names just because you can. Using a symbol, like `:X_values`, instead of the string \"X values\" will give faster results and is just as readable. This does mean you need to use underscores instead of spaces, but all-in-all that is not too high a price to pay.\n:::\n\nA DataFrame can also be constructed one column at a time:\n\n``` julia\ndf = DataFrame()\n# 0×0 DataFrame\n\ndf.A = 1:3\n# 1:3\n\ndf.B = 2:2:6\n# 2:2:6\n\ndf\n# 3×2 DataFrame\n#  Row │ A      B\n#      │ Int64  Int64\n# ─────┼──────────────\n#    1 │     1      2\n#    2 │     2      4\n#    3 │     3      6\n```\n\nOr row by row:\n\n``` julia\ndf = DataFrame(A=String[], B=Int64[])\n# 0×2 DataFrame\n#  Row │ A       B\n#      │ String  Int64\n# ─────┴───────────────\n\npush!(df, (\"Bob\", 1))\n# 1×2 DataFrame\n#  Row │ A       B\n#      │ String  Int64\n# ─────┼───────────────\n#    1 │ Bob         1\n\npush!(df, (\"Tom\", 5))\n# 2×2 DataFrame\n#  Row │ A       B\n#      │ String  Int64\n# ─────┼───────────────\n#    1 │ Bob         1\n#    2 │ Tom         5\n```\n\nNote how we forced types of the columns in the creation of the empty DataFrame. This is needed to give the columns names, and tell the empty DataFrame how many columns it will hold. You could specify the types as `Any`, but that would not lead to god performance.\n\nLastly, you can also convert a matrix to a DataFrame. This requires you to allow DataFrames to automatically generate column names, or pass a vector of names:\n\n``` julia\nm = rand(5, 5)\n# 5×5 Matrix{Float64}:\n#  0.460589   0.734461   0.771352   0.292767   0.0078547\n#  0.254958   0.153814   0.571355   0.196476   0.739701\n#  0.0799407  0.457583   0.553493   0.25409    0.245967\n#  0.106429   0.435509   0.0184347  0.932008   0.805972\n#  0.0877892  0.0231817  0.435262   0.0187286  0.812151\n\ndf = DataFrame(m, :auto) # Automatically generate names\n# 5×5 DataFrame\n#  Row │ x1         x2         x3         x4         x5\n#      │ Float64    Float64    Float64    Float64    Float64\n# ─────┼───────────────────────────────────────────────────────\n#    1 │ 0.460589   0.734461   0.771352   0.292767   0.0078547\n#    2 │ 0.254958   0.153814   0.571355   0.196476   0.739701\n#    3 │ 0.0799407  0.457583   0.553493   0.25409    0.245967\n#    4 │ 0.106429   0.435509   0.0184347  0.932008   0.805972\n#    5 │ 0.0877892  0.0231817  0.435262   0.0187286  0.812151\n\ndf = DataFrame(m, [:X, :Y, :Z, :W, :Q]) # Specify names\n# 5×5 DataFrame\n#  Row │ X          Y          Z          W          Q\n#      │ Float64    Float64    Float64    Float64    Float64\n# ─────┼───────────────────────────────────────────────────────\n#    1 │ 0.460589   0.734461   0.771352   0.292767   0.0078547\n#    2 │ 0.254958   0.153814   0.571355   0.196476   0.739701\n#    3 │ 0.0799407  0.457583   0.553493   0.25409    0.245967\n#    4 │ 0.106429   0.435509   0.0184347  0.932008   0.805972\n#    5 │ 0.0877892  0.0231817  0.435262   0.0187286  0.812151\n```\n\n### Accessing the Data\n\nOnce the data is in a DataFrame, you can access column like they are individual vectors:\n\n``` julia\ndf.X\n# 5-element Vector{Float64}:\n#  0.460589206535297\n#  0.25495814887990786\n#  0.07994066869519556\n#  0.10642869978604408\n#  0.0877892134158087\n```\n\nYou can also add columns, even via calculations:\n\n``` julia\ndf.New = (df.X).^2 .- df.Y\n# 5-element Vector{Float64}:\n#  -0.5223183397440386\n#  -0.08881079559662731\n#  -0.45119243718262425\n#  -0.42418203290738643\n#  -0.015474773743873368\n\ndf\n# 5×6 DataFrame\n#  Row │ X          Y          Z          W          Q          New\n#      │ Float64    Float64    Float64    Float64    Float64    Float64\n# ─────┼───────────────────────────────────────────────────────────────────\n#    1 │ 0.460589   0.734461   0.771352   0.292767   0.0078547  -0.522318\n#    2 │ 0.254958   0.153814   0.571355   0.196476   0.739701   -0.0888108\n#    3 │ 0.0799407  0.457583   0.553493   0.25409    0.245967   -0.451192\n#    4 │ 0.106429   0.435509   0.0184347  0.932008   0.805972   -0.424182\n#    5 │ 0.0877892  0.0231817  0.435262   0.0187286  0.812151   -0.0154748\n```\n\nNote the use of broadcasting in the first command - using `.^` instead of `^` and `.-` instead of `-`. This tells Julia to execute these operations on in element-wise fashion. The new column, `df.Z` is added to the DataFrame automatically.\n\nYou can also access individual entries by specifying the row and column, the latter using either the names or indexes:\n\n``` julia\ndf[2, 3] # Row 2, Column 3 (Z)\n# 0.5713552793835407\n\ndf[2:3, 3:5]\n# 2×3 DataFrame\n#  Row │ Z         W         Q\n#      │ Float64   Float64   Float64\n# ─────┼──────────────────────────────\n#    1 │ 0.571355  0.196476  0.739701\n#    2 │ 0.553493  0.25409   0.245967\n\ndf[1:3, :W]\n# 3-element Vector{Float64}:\n#  0.29276715395306163\n#  0.19647571959450094\n#  0.25409034700483624\n```\n\nTo select an entire row or column, the `:` operator is used, just like in Arrays. This returns a copy of the slice of the DataFrame. When using a `!`, however, a view to the data is returns. Modifying the view will modify the contents of the DataFrame as well:\n\n``` julia\ndf = DataFrame(X = [1, 2, 3], Y = [2, 4, 6], Z = [3, 6, 9])\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Int64\n# ─────┼─────────────────────\n#    1 │     1      2      3\n#    2 │     2      4      6\n#    3 │     3      6      9\n\nxvals = df[:, :X]\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nxvals[1] = 100\n# 100\n\ndf\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Int64\n# ─────┼─────────────────────\n#    1 │     1      2      3\n#    2 │     2      4      6\n#    3 │     3      6      9\n\nxview = df[!, :X]\n# 3-element Vector{Int64}:\n#  1\n#  2\n#  3\n\nxview[1] = 100\n# 100\n\ndf\n# 3×3 DataFrame\n#  Row │ X      Y      Z\n#      │ Int64  Int64  Int64\n# ─────┼─────────────────────\n#    1 │   100      2      3\n#    2 │     2      4      6\n#    3 │     3      6      9\n```\n\nYou can also select just specific rows and columns:\n\n``` julia\ndf[[1, 3], [1, 3]]\n# 2×2 DataFrame\n#  Row │ X      Z     \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      3\n#    2 │     3      9\n```\n\n### Data Wrangling with DataFrames\n\nData wrangling is the pre-processing of your data to get it into the form you need for the modelling or analysis you intend to do with it. This can include many steps. DataFrames has a rich feature set to support you in this. We'll look at several examples here, but if you are going to be doing this type of work often, save yourself a lot of page-turning and download, print and laminate a copy of the [**Data Wrangling with DataFrames.jl Cheat Sheet**](https://www.ahsmart.com/assets/pages/data-wrangling-with-data-frames-jl-cheat-sheet/DataFramesCheatSheet_v1.x_rev1.pdf)\n\nWe start off by creating a dataset to work with:\n\n``` julia\ndf = DataFrame(X = 1:3:1500, Y = repeat(1:100, outer=5), Z = repeat(1:100, inner=5)\n# 500×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      1 \n#    2 │     4      2      1 \n#    3 │     7      3      1 \n#    4 │    10      4      1 \n#    5 │    13      5      1 \n#    6 │    16      6      2 \n#    7 │    19      7      2 \n#    8 │    22      8      2 \n#    9 │    25      9      2 \n#   ⋮  │   ⋮      ⋮      ⋮   \n#  492 │  1474     92     99 \n#  493 │  1477     93     99\n#  494 │  1480     94     99\n#  495 │  1483     95     99\n#  496 │  1486     96    100\n#  497 │  1489     97    100\n#  498 │  1492     98    100\n#  499 │  1495     99    100\n#  500 │  1498    100    100\n#            482 rows omitted\n\nfirst(df,3)\n# 3×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      1\n#    2 │     4      2      1\n#    3 │     7      3      1\n\nlast(df,4)\n# 4×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │  1489     97    100\n#    2 │  1492     98    100\n#    3 │  1495     99    100\n#    4 │  1498    100    100\n\nnames(df)\n# 3-element Vector{String}:\n#  \"X\"\n#  \"Y\"\n#  \"Z\"\n\ndescribe(df)\n# 3×7 DataFrame\n#  Row │ variable  mean     min    median   max    nmissing  eltype   \n#      │ Symbol    Float64  Int64  Float64  Int64  Int64     DataType \n# ─────┼──────────────────────────────────────────────────────────────\n#    1 │ X           749.5      1    749.5   1498         0  Int64\n#    2 │ Y            50.5      1     50.5    100         0  Int64\n#    3 │ Z            50.5      1     50.5    100         0  Int64\n```\n\nIn generating this data, we used Julia's `repeat` function. For the `Y` column, we specify `outer=5`, which means the data (`1:100`) is repeated 5 times as a set, i.e. 1 to 100, then 1 to 100 again, for a total of 5 times. For the `Z` column, we specify `inner=5`, which means each of the values from 1 to 100 is repeated 5 times: 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,... etc.\n\nWe can quickly see the first or last few entries using the Julia functions `first` and `last`, with the second parameter showing how many entries to display. The number of rows displayed by Julia for the full DataFrame depends on the size of the window it is being displayed in. The middle omitted rows are indicated with the `⋮` characters. If the DataFrame is too wide, columns will also be omitted, with a message indicating how many columns are hidden.\n\nIf you **really** want to see all the rows or columns, you can call `show` and specify `allrows=true` and/or `allcols=true`\n\n``` julia\nshow(df, allrows=true, allcols=true)\n```\n\nFor obvious reasons, we won't include the 500 rows of data here.\n\nThe `names()` function returns a vector of the column names as strings. You can also get summary statistics of the data with the `describe()` function.\n\nIf you only want specific statistics, you can specify them in the call:\n\n``` julia\ndescribe(df, :mean, :std)\n# 3×3 DataFrame\n#  Row │ variable  mean     std     \n#      │ Symbol    Float64  Float64 \n# ─────┼────────────────────────────\n#    1 │ X           749.5  433.445\n#    2 │ Y            50.5   28.895\n#    3 │ Z            50.5   28.895\n```\n\nYou can also apply a custom function to describe the data. Here we use the Julia function `extrema()`, which returns the minimum and maximum value in an array. We'll specify that we want the results in a column call `minmax`:\n\n``` julia\ndescribe(df, extrema => :minmax)\n# 3×2 DataFrame\n#  Row │ variable  minmax    \n#      │ Symbol    Tuple…    \n# ─────┼─────────────────────\n#    1 │ X         (1, 1498)\n#    2 │ Y         (1, 100)\n#    3 │ Z         (1, 100)\n```\n\nLastly, the number of rows and column can be easily retrieved:\n\n``` julia\nnrow(df)\n# 500\n\nncol(df)\n# 6\n```\n\n#### Selecting and Transforming Data\n\n##### Selecting Columns\n\nIn the introductory section, we selected specific rows and column based on their indices. You can also select columns based on their names:\n\n``` julia\nselect(df, [:X, :Z])\n# 500×2 DataFrame     \n#  Row │ X      Z     \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      1\n#    2 │     4      1\n#    3 │     7      1\n#   ⋮  │   ⋮      ⋮\n#  498 │  1492    100\n#  499 │  1495    100\n#  500 │  1498    100\n#     494 rows omitted\n```\n\nThere are also selector function to allow for selection of ranges of columns:\n\n-   `Not()`: Select all the columns expect the specified one(s)\n-   `Between()`: Select all column starting with the first specified column and ending with the second. You can use names or indices to specify the columns\n-   `Cols()`: Use this to combine other selector functions\n-   `All()`: Select all columns - same as specifying `:`\n\n**Examples:**\n\nIn the previous example we selected columns `X` and `Z`, which is the same as selecting everything expect `Y`:\n\n``` julia\nselect(df, Not(:Y))\n# 500×2 DataFrame\n#  Row │ X      Z     \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      1\n#    2 │     4      1\n#    3 │     7      1\n#   ⋮  │   ⋮      ⋮\n#  498 │  1492    100\n#  499 │  1495    100\n#  500 │  1498    100\n#     494 rows omitted\n```\n\nWe only passed a single symbol to `Not`, but could also pass an array of symbols to exclude multiple columns.\n\nTo make things more interesting, we can first add a few more columns:\n\n``` julia\ndf.A = 2 .* df.X\ndf.B = df.Y .+ df.Z\ndf.C = df.Z .^ 2\ndf\n# 500×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │     4      2      1      8      3      1\n#    3 │     7      3      1     14      4      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  498 │  1492     98    100   2984    198  10000\n#  499 │  1495     99    100   2990    199  10000\n#  500 │  1498    100    100   2996    200  10000\n#                                 494 rows omitted\n```\n\n``` julia\nselect(df, Cols(:A, Between(:X, :Z)))\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\n```\n\nHere we used `Cols` to combine selecting column `A` and all columns from `X` to `Z`. This also changed the order of the columns.\n\nWe used the `select` function to do the selections, but could as easily have used the normal array-type notation:\n\n``` julia\ndf[:, Cols(:A, Between(:X, :Z))]\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\n```\n\nTo permanently change the DataFrame, either assign the returned result to the same variable, or use the mutating version of `select()`: `select!()`.\n\n``` julia\ndf = select(df, Cols(:A, Between(:X, :Z)))\ndf\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\n```\n\nor\n\n``` julia\nselect!(df, Cols(:A, Between(:X, :Z)))\n# 500×4 DataFrame\n#  Row │ A      X      Y      Z     \n#      │ Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────\n#    1 │     2      1      1      1\n#    2 │     8      4      2      1 Da\n#    3 │    14      7      3      1\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮\n#  498 │  2984   1492     98    100\n#  499 │  2990   1495     99    100\n#  500 │  2996   1498    100    100\n#                   494 rows omitted\n```\n\nIt is also possible to select columns from a DataFrame that match to a *regular expression*. This is a template that describes a string of text. For more information, see one the many [tutorials](https://www.regular-expressions.info/tutorialcnt.html) on the web.\n\n``` julia\ndf = DataFrame(\n    Names = [\"Tom\", \"Dick\", \"Harry\"], \n    AddressLine1 = [\"2 Maple Drive\", \"4 Oak Street\", \"6 Pine Road\"],\n    AddressLine2 = [\"Hopetown\", \"Smallville\", \"Metropolis\"],\n    AddressZip = [1234, 2345, 3456]\n)\n3×4 DataFrame\n#  Row │ Names   AddressLine1   AddressLine2  AddressZip \n#      │ String  String         String        Int64      \n# ─────┼─────────────────────────────────────────────────\n#    1 │ Tom     2 Maple Drive  Hopetown            1234\n#    2 │ Dick    4 Oak Street   Smallville          2345\n#    3 │ Harry   6 Pine Road    Metropolis          3456\n\n\ndf[:, r\"Addr\"]\n# 3×3 DataFrame\n#  Row │ AddressLine1   AddressLine2  AddressZip \n#      │ String         String        Int64      \n# ─────┼─────────────────────────────────────────\n#    1 │ 2 Maple Drive  Hopetown            1234\n#    2 │ 4 Oak Street   Smallville          2345\n#    3 │ 6 Pine Road    Metropolis          34\n```\n\nHere we select all rows, but only the column that have the substring \"Addr\" in their names.\n\n##### Selecting Rows (Filtering) and Sorting\n\nYou can select rows by filtering the data. There are two equivalent ways:\n\n``` julia\nfilter(:X => <=(10), df)\n# 4×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │     4      2      1      8      3      1\n#    3 │     7      3      1     14      4      1\n#    4 │    10      4      1     20      5      1\n\ndf[df.X .<= 10, :]\n# 4×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │     4      2      1      8      3      1\n#    3 │     7      3      1     14      4      1\n#    4 │    10      4      1     20      5      1\n```\n\nIn both cases we pass a *predicate* function, i.e. a function that returns `true` for rows that should be included. In the first case, a pair operator links a column name to the predicate function and in the second case we simply pass an expression that returns true for all the correct instances. Note the use of broadcasting in the second example.\n\nYou can use any predicate function. A new useful ones include:\n\n``` julia\ndf[findfirst(==(4), df.C), :] # Find the first row where column C has a value of 4\n# DataFrameRow\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    6 │    16      6      2     32      8      4\n\ndf[findall(==(4), df.C), :] # Find all rows where column C has a value of 4\n# 5×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │    16      6      2     32      8      4\n#    2 │    19      7      2     38      9      4\n#    3 │    22      8      2     44     10      4\n#    4 │    25      9      2     50     11      4\n#    5 │    28     10      2     56     12      4\n\ndf[df.C .== 4, :] # Find all rows where column C has a value of 4, alternative form\n# 5×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │    16      6      2     32      8      4\n#    2 │    19      7      2     38      9      4\n#    3 │    22      8      2     44     10      4\n#    4 │    25      9      2     50     11      4\n#    5 │    28     10      2     56     12      4\n```\n\nIt may also be useful to sort the data according to specified columns:\n\n``` julia\nsort(df, :Y)\n# 500×6 DataFrame\n#  Row │ X      Y      Z      A      B      C     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │   301      1     21    602     22    441\n#    3 │   601      1     41   1202     42   1681\n#    4 │   901      1     61   1802     62   3721\n#    5 │  1201      1     81   2402     82   6561\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  497 │   598    100     40   1196    140   1600\n#  498 │   898    100     60   1796    160   3600\n#  499 │  1198    100     80   2396    180   6400\n#  500 │  1498    100    100   2996    200  10000\n#                                 491 rows omitted\n\nsort(df, [:Y, :B])\n# 500×6 DataFrame\n#  Row │ X      Y      Z      A      B      C\n#      │ Int64  Int64  Int64  Int64  Int64  Int64\n# ─────┼──────────────────────────────────────────\n#    1 │     1      1      1      2      2      1\n#    2 │   301      1     21    602     22    441\n#    3 │   601      1     41   1202     42   1681\n#    4 │   901      1     61   1802     62   3721\n#    5 │  1201      1     81   2402     82   6561\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  497 │   598    100     40   1196    140   1600\n#  498 │   898    100     60   1796    160   3600\n#  499 │  1198    100     80   2396    180   6400\n#  500 │  1498    100    100   2996    200  10000\n#                                 491 rows omitted\n```\n\n##### Applying Function to Columns and Rows\n\nApplying a function to a column or multiple columns has been shown before when we added columns to a DataFrame. Since each column acts like a vector, we simply use normal Julia broadcasting to apply functions to whole columns:\n\n``` julia\ndf.BdivC = df.B ./ df.C\n# 500-element Vector{Float64}:\n#  2.0\n#  3.0\n#  4.0\n#  5.0\n#  6.0\n#  2.0\n#  2.25\n#  ⋮\n#  0.01979389858177737\n#  0.0196\n#  0.0197\n#  0.0198\n#  0.0199\n#  0.02\n\n# df\n# 500×7 DataFrame\n#  Row │ X      Y      Z      A      B      C      BdivC     \n#      │ Int64  Int64  Int64  Int64  Int64  Int64  Float64   \n# ─────┼─────────────────────────────────────────────────────\n#    1 │     1      1      1      2      2      1  2.0\n#    2 │     4      2      1      8      3      1  3.0\n#    3 │     7      3      1     14      4      1  4.0\n#    4 │    10      4      1     20      5      1  5.0\n#    5 │    13      5      1     26      6      1  6.0\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮        ⋮\n#  497 │  1489     97    100   2978    197  10000  0.0197\n#  498 │  1492     98    100   2984    198  10000  0.0198\n#  499 │  1495     99    100   2990    199  10000  0.0199\n#  500 │  1498    100    100   2996    200  10000  0.02\n#                                            491 rows omitted\n```\n\nIn order to apply functions across rows, we need to use some of the built-in functions of DataFrames, `select` and `transform`, along with `ByRow`.\n\nThe basic syntax is:\n\n`select(df, <array of columns to select>)` `select(df, <array of columns to select>, <array of columns to pass to function> => <function> => <name(s) of column(s) to hold result>)` `select(df, AsTable(:) => <function> => <name(s) of column(s) to hold result>)` \\# pass the entire table to the function\n\nSome examples:\n\n``` julia\n\nselect(df, :X, :X => cumsum => :cumX) # Put the cumulative sum of X in column cumX\n# 500×2 DataFrame\n#  Row │ X      cumX   \n#      │ Int64  Int64  \n# ─────┼───────────────\n#    1 │     1       1\n#    2 │     4       5\n#    3 │     7      12\n#    4 │    10      22\n#    5 │    13      35\n#   ⋮  │   ⋮      ⋮\n#  497 │  1489  370265\n#  498 │  1492  371757\n#  499 │  1495  373252\n#  500 │  1498  374750\n#      491 rows omitted\n\nselect(df, [:X, :Y], [:X, :Y] => ByRow((x, y) -> sin(x)*cos(y)) => :sinXcosY) # Put the value of sin(X)*cos*(Y) in column sinXcosY\n# 500×3 DataFrame\n#  Row │ X      Y      sinXcosY    \n#      │ Int64  Int64  Float64     \n# ─────┼───────────────────────────\n#    1 │     1      1   0.454649\n#    2 │     4      2   0.314941\n#    3 │     7      3  -0.650412\n#    4 │    10      4   0.355596\n#    5 │    13      5   0.119185\n#   ⋮  │   ⋮      ⋮         ⋮\n#  497 │  1489     97   0.106082\n#  498 │  1492     98  -0.207859\n#  499 │  1495     99  -0.0154374\n#  500 │  1498    100   0.443124\n#                  491 rows omitted\n\nselect(df, AsTable(:) => ByRow(extrema) => [:min, :max]) # Find the smallest and largest value in each row\n# 500×2 DataFrame\n#  Row │ min    max   \n#      │ Int64  Int64 \n# ─────┼──────────────\n#    1 │     1      2\n#    2 │     1      8\n#    3 │     1     14\n#    4 │     1     20\n#    5 │     1     26\n#   ⋮  │   ⋮      ⋮\n#  497 │    97  10000\n#  498 │    98  10000\n#  499 │    99  10000\n#  500 │   100  10000\n#     491 rows omitted\n```\n\nIn each case, we used `select` and it only returned the specified columns. If we instead call `transform`, the entire DataFrame is returned, as well as any new columns added in the calculations, e.g.\n\n``` julia\ntransform(df, AsTable(:) => ByRow(extrema) => [:min, :max])\n# 500×8 DataFrame\n#  Row │ X      Y      Z      A      B      C      min    max   \n#      │ Int64  Int64  Int64  Int64  Int64  Int64  Int64  Int64 \n# ─────┼────────────────────────────────────────────────────────\n#    1 │     1      1      1      2      2      1      1      2\n#    2 │     4      2      1      8      3      1      1      8\n#    3 │     7      3      1     14      4      1      1     14\n#    4 │    10      4      1     20      5      1      1     20\n#    5 │    13      5      1     26      6      1      1     26\n#   ⋮  │   ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮      ⋮\n#  497 │  1489     97    100   2978    197  10000     97  10000\n#  498 │  1492     98    100   2984    198  10000     98  10000\n#  499 │  1495     99    100   2990    199  10000     99  10000\n#  500 │  1498    100    100   2996    200  10000    100  10000\n#                                               491 rows omitted\n```\n\nJust like before, `select` and `transform` return new DataFrames, while `select!` and `transform!` will modify the existing DataFrame.\n\n### Grouping Data\n\nDataFrames will group your data by column values through the `groupby()` function. One or more columns can be specified and you will get a GroupedDataFrame - a container of `SubDataFrame`s for each unique combination of the values in the specified columns.\n\n``` julia\ndf = DataFrame(X = 1:50, Y = repeat(1:2, outer=25), Z = repeat(2:2:10, inner=10))\n# 50×3 DataFrame\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      2 \n#    2 │     2      2      2\n#    3 │     3      1      2\n#    4 │     4      2      2\n#    5 │     5      1      2\n#    6 │     6      2      2\n#   ⋮  │   ⋮      ⋮      ⋮\n#   45 │    45      1     10\n#   46 │    46      2     10\n#   47 │    47      1     10\n#   48 │    48      2     10\n#   49 │    49      1     10\n#   50 │    50      2     10\n#             38 rows omitted\n\ngdf = groupby(df, [:Y, :Z]\n# GroupedDataFrame with 10 groups based on keys: Y, Z\n# First Group (5 rows): Y = 1, Z = 2\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │     1      1      2\n#   ⋮  │   ⋮      ⋮      ⋮\n#    5 │     9      1      2\n#              3 rows omitted\n# ⋮\n# Last Group (5 rows): Y = 2, Z = 10\n#  Row │ X      Y      Z     \n#      │ Int64  Int64  Int64 \n# ─────┼─────────────────────\n#    1 │    42      2     10\n#   ⋮  │   ⋮      ⋮      ⋮\n#    5 │    50      2     10\n#              3 rows omitted\n\ncounts = select(gdf, nrow, :X => mean)\n# 50×4 DataFrame\n#  Row │ Y      Z      nrow   X_mean  \n#      │ Int64  Int64  Int64  Float64 \n# ─────┼──────────────────────────────\n#    1 │     1      2      5      5.0\n#    2 │     2      2      5      6.0\n#    3 │     1      2      5      5.0\n#    4 │     2      2      5      6.0\n#    5 │     1      2      5      5.0\n#    6 │     2      2      5      6.0\n#   ⋮  │   ⋮      ⋮      ⋮       ⋮\n#   45 │     1     10      5     45.0\n#   46 │     2     10      5     46.0\n#   47 │     1     10      5     45.0\n#   48 │     2     10      5     46.0\n#   49 │     1     10      5     45.0\n#   50 │     2     10      5     46.0\n#                      38 rows omitted\n```\n\nHere we create a DataFrame with three columns: `X` ranges from 1 to 50, `Y` alternates between 1 and 2, and `Z` is a sequence of the even numbers from 2 to 10. We then group by `Y` and `Z`, which gives us a `GroupedDataFrame` with 10 groups, for the 10 unique combinations of values in `Y` and `Z`. The last command created a new DataFrame, called `counts` which contains the number of rows in each of the 10 `SubDataFrame`s in our `GroupedDataFrame` (`gdf`) as well as the mean[^1] value of the `X` column in each of the 10 groups.\n\n[^1]: Note that to use the `mean` function, you need to first include the `Statistics` standard library\n\n#### A More Complete Example\n\nFor this example, we use a dataset from [Kaggle](https://www.kaggle.com/datasets/uom190346a/food-ingredients-and-allergens). The data file includes information on the ingredients of 399 types of food.\n\n```julia\ndf = CSV.read(raw\"D:\\JuliaCode\\KaggleData\\food_ingredients_and_allergens.csv\", DataFrame; normalizenames=true)\nselect!(df, [:Food_Product, :Allergens])\n# 399×2 DataFrame\n#  Row │ Food_Product             Allergens\n#      │ String                   String31\n# ─────┼─────────────────────────────────────────────────\n#    1 │ Almond Cookies           Almonds, Wheat, Dairy\n#    2 │ Almond Cookies           Almonds, Wheat, Dairy\n#    3 │ Chicken Noodle Soup      Chicken, Wheat, Celery\n#    4 │ Chicken Noodle Soup      Chicken, Wheat, Celery\n#    5 │ Cheddar Cheese           Dairy\n#    6 │ Ranch Dressing           Dairy\n#    7 │ Caramel Popcorn          Dairy\n#    8 │ Caesar Salad             Dairy\n#   ⋮  │            ⋮                       ⋮\n#  393 │ Chocolate Chip Pancakes  Wheat, Dairy, Cocoa\n#  394 │ Lemon Bars               Wheat, Dairy, Eggs\n#  395 │ Lemon Bars               Wheat, Dairy, Eggs\n#  396 │ Pecan Pie                Wheat, Dairy, Nuts\n#  397 │ Zucchini Bread           Wheat, Dairy, Nuts\n#  398 │ Banana Bread             Wheat, Dairy, Nuts\n#  399 │ Hawaiian Pizza           Wheat, Pork, Dairy\n#                                        384 rows omitted\n```\n\nWe are going to focus on the allergens in these foods. We select to keep only the two column containing the names of the foods and the allergens contained in them. Unfortunately, the allergens are given as a single string of comma-separated values. This means we have to do a little processing of the data. \n\nWe ideally want a separate column for each allergen that contains a `true` (1) or `false` (0) to indicate if the allergen is present or not. To get this, we must process all the entries on allergens and split the strings into the individual allergens. We then need to identify the unique values, and add a true or false in a new column for each food and each allergen. This sounds like a lot of work, but Julia makes this easy.\n\n```julia\nallAllergens = String[]\nfor row in eachrow(df)\n    allergens = row.Allergens\n    for s in eachsplit(allergens, \", \")\n        push!(allAllergens, s)\n    end\nend\nunique!(allAllergens)\n\n# 24-element Vector{String}:\n#  \"Almonds\"\n#  \"Wheat\"\n#  \"Dairy\"\n#  \"Chicken\"\n#  \"Celery\"\n#  \"Anchovies\"\n#  \"Cocoa\"\n#  ⋮\n#  \"Oats\"\n#  \"Peanuts\"\n#  \"Pine nuts\"\n#  \"Rice\"\n#  \"Shellfish\"\n#  \"Pork\"\n#  \"Alcohol\"\n```\n\nWe create an empty vector of `String`s to hold the allergen names - `allAllergens`. Then we iterate trough the DataFrame, one row at a time, using the `eachrow` iterator. We extract the string holding the allergens into a temporary string `allergens` with `allergens = row.Allergens` (where `row` is the current row in the iterator `eachrow`).\n\nTo split the string (`allergens`) into the various allergens, we use the Julia function `eachsplit`, which splits the string with the specified delimiter (\", \"), and returns an iterator of substrings. We loop through this iterator and push each substring into the empty vector we created at the start.\n\nLastly, we use the Julia function `unique!` to remove all duplicates from this vector. We now have a list of 24 possible allergens.\n\n```julia\nfor allergen in allAllergens\n    transform!(df, :Allergens => ByRow(s -> contains(string(s), allergen)) => Symbol(allergen))\nend\n\ndf[:, [:Food_Product, :Almonds, :Wheat, :Dairy]]\n# 399×4 DataFrame\n#  Row │ Food_Product             Almonds  Wheat  Dairy \n#      │ String                   Bool     Bool   Bool  \n# ─────┼────────────────────────────────────────────────\n#    1 │ Almond Cookies              true   true   true\n#    2 │ Almond Cookies              true   true   true\n#    3 │ Chicken Noodle Soup        false   true  false\n#    4 │ Chicken Noodle Soup        false   true  false\n#    5 │ Cheddar Cheese             false  false   true\n#    6 │ Ranch Dressing             false  false   true\n#   ⋮  │            ⋮                ⋮       ⋮      ⋮\n#  394 │ Lemon Bars                 false   true   true\n#  395 │ Lemon Bars                 false   true   true\n#  396 │ Pecan Pie                  false   true   true\n#  397 │ Zucchini Bread             false   true   true\n#  398 │ Banana Bread               false   true   true\n#  399 │ Hawaiian Pizza             false   true   true\n#                                       387 rows omitted\n```\n\nWe now run through our newly created list of allergens and call the DataFrames function `transform!` for each allergen. `transform!` is the mutating version of `transform` and will modify the specified DataFrame rather than return a new object. `transform` includes all of the columns in the original DataFrame, unlike `select`, which will include only the specified columns.\n\nWe specify here than we want to take the contents of the `Allergens` column, and pass it, one row at a time (`ByRow()`) to an anonymous function ()`s -> contains(string(s), allergen))`) and store the result in a new column `Symbol(allergen)`. Note that we are converting the name of the allergen, which is a `String` to a `Symbol`, which is what DataFrames expects here.\n\nThe anonymous function we define essentially only calls the Julia function `contains`, which will return a `true` or `false` depending on whether the string contains a specified substring. We convert the value from the DataFrame to a string (with the `string()` function), as DataFrames uses a more specialised data type for string values to save memory and improve performance. We have a quick look at three of the allergens and see that we indeed have exactly what we wanted.\n\nWe can now analyse the data any way we want to. Let's group the data to see combinations of almonds and wheat in the various foods:\n\n```julia\ngdf = groupby(df, [:Almonds, :Wheat])\n\nfor (keys, sdf) in pairs(gdf)\n    println(\"Number of foods with $keys: $(nrow(sdf))\")\nend\n\n# Number of foods with GroupKey: (Almonds = true, Wheat = true): 2\n# Number of foods with GroupKey: (Almonds = false, Wheat = true): 94\n# Number of foods with GroupKey: (Almonds = false, Wheat = false): 303\n```\n\n### Joining DataFrames\n\nDataFrames allows for joining of tables, just like in a SQL database. We shall give a few key definitions here to illustrate the concept.\n\nFirstly, what is a *join*? It is a combination of two tables, based on the values in a specified column, typically an ID or similar index value. The resulting table may include columns from one or both of the tables, for the rows that are included in the joined table, depending on the type of join.\n\nWe define two DataFrames to use in our examples:\n\n```julia\ndf1 = DataFrame(ID = [1, 2, 3], Floor = [\"A\", \"B\", \"C\"], Office = [11, 12, 12])\n# 3×3 DataFrame\n#  Row │ ID     Floor   Office \n#      │ Int64  String  Int64  \n# ─────┼───────────────────────\n#    1 │     1  A           11\n#    2 │     2  B           12\n#    3 │     3  C           12\n\ndf2 = DataFrame(ID = [1, 2, 7, 11], Name = [\"Tom\", \"Dan\", \"Harry\", \"Bob\"])\n# 4×2 DataFrame\n#  Row │ ID     Name   \n#      │ Int64  String \n# ─────┼───────────────\n#    1 │     1  Tom\n#    2 │     2  Dan\n#    3 │     7  Harry\n#    4 │    11  Bob\n```\n**Inner join**: An inner join between two tables will include only the rows where the field (e.g. ID) on which you join, are the same in each table. Rows that include a value of ID that is only present in one of the two tables will not be included. All columns from both tables are included.\n\n\n```julia\ninnerjoin(df1, df2, on=:ID)\n# 2×4 DataFrame\n#  Row │ ID     Floor   Office  Name   \n#      │ Int64  String  Int64   String \n# ─────┼───────────────────────────────\n#    1 │     1  A           11  Tom\n#    2 │     2  B           12  Dan\n```\n\n**Left join**: A left join between two tables will include all the rows from the *left* table, as well as those rows from *right* table where the joining field (e.g. ID) match. All columns are included, which may result in `missing` values in columns from the *right* table.\n\n\n```julia\nleftjoin(df1, df2, on=:ID)\n# 3×4 DataFrame\n#  Row │ ID     Floor   Office  Name    \n#      │ Int64  String  Int64   String? \n# ─────┼────────────────────────────────\n#    1 │     1  A           11  Tom\n#    2 │     2  B           12  Dan\n#    3 │     3  C           12  missing \n```\n\n**Right join**: Similar to a *left join*, but all rows from the *right table* are included and only matching rows from the *left* table. This may result in `missing` values in columns from the *left* table.\n\n\n```julia\nrightjoin(df1, df2, on=:ID)\n# 4×4 DataFrame\n#  Row │ ID     Floor    Office   Name   \n#      │ Int64  String?  Int64?   String \n# ─────┼─────────────────────────────────\n#    1 │     1  A             11  Tom\n#    2 │     2  B             12  Dan\n#    3 │     7  missing  missing  Harry\n#    4 │    11  missing  missing  Bob\n```\n\n**Outer join**: This will include all rows from both *left* and *right* tables, possibly resulting in `missing` values in all columns.\n\n\n```julia\n# outerjoin(df1, df2, on=:ID)\n# 5×4 DataFrame\n#  Row │ ID     Floor    Office   Name    \n#      │ Int64  String?  Int64?   String? \n# ─────┼──────────────────────────────────\n#    1 │     1  A             11  Tom\n#    2 │     2  B             12  Dan\n#    3 │     3  C             12  missing \n#    4 │     7  missing  missing  Harry\n#    5 │    11  missing  missing  Bob\n```\n**Semi join** (a.k.a. **Left semi join**): Like an inner join, this will only return rows that match in both columns, but will only return columns from the *left* table. This is useful if you want to select, for example, names from a list that are also present in another list, without including additional data from that list. To do a *right semi join*, just reverse the order to the two `DataFrame`s.\n\n\n```julia\nsemijoin(df1, df2, on=:ID)\n# 2×3 DataFrame\n#  Row │ ID     Floor   Office \n#      │ Int64  String  Int64  \n# ─────┼───────────────────────\n#    1 │     1  A           11\n#    2 │     2  B           12\n```\n\n**Anti join** (a.k.a. **Left anti join**): Like the semi join, but will only return rows from the *left* table that are **NOT** matched in the *right* table.\n\n\n```julia\nantijoin(df1, df2, on=:ID)\n# 1×3 DataFrame\n#  Row │ ID     Floor   Office \n#      │ Int64  String  Int64  \n# ─────┼───────────────────────\n#    1 │     3  C           12\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"embed-resources":true,"output-file":"13_DataFrames.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"cosmo","monofont":"JetBrains Mono","smooth-scroll":false,"footnotes-hover":true,"title":"DataFrames"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}