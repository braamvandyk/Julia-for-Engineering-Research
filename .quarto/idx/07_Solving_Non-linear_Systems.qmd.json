{"title":"Solving Non-linear Systems","markdown":{"yaml":{"title":"Solving Non-linear Systems"},"headingText":"Available packages","containsRefs":false,"markdown":"\n\nIt is often required to solve systems of non-linear equations in engineering. As for the the case of systems of linear equations, there are multiple options in Julia.\n\n\nA popular package is [`NLsolve.jl`](https://github.com/JuliaNLSolvers/NLsolve.jl). This package provides three methods: Trust region, Newton's method with optional line search, and Anderson acceleration. It can also solve fixed-point problems.\n\nAlternatively, you could use [`JuMP`](https://jump.dev/) - a **very** powerful mathematical programming modelling language, built on top of Julia, that can call several free and commercial solvers. In this case, set up a problem with non-linear constraints matching your system and a constant value objective function.\n\nThere are also several less popular packages available.\n\nIn the spirit of not wanting to learn several different interfaces to access options for different algorithms, we shall stick to the SciML package for non-linear systems, [`NonlinearSolve.jl`](https://docs.sciml.ai/NonlinearSolve/stable/).\n\nThis package uses the same interface as [`LinearSolve.jl`](https://docs.sciml.ai/LinearSolve/stable/). It has built-in in algorithms, but is also a unified front-end for other packages, including `NLsolve.jl`.\n\n## NonlinearSolve\n\nThe `NonlinearSolve.jl` package can be used to solve three types of problem:\n\n1.  Interval root-finding (bracketing) problems, where a scalar root is found within a specified interval: find $t ∈ [tₗ, tₕ]$ such that $f(t) = 0$\\\n2.  Solving a system of non-linear equations, i.e. find $\\mathbf{u}$ such that $f(\\mathbf{u}) = \\mathbf{0}$\n3.  Solving steady-state problems, i.e. solve $u' = f(u, t) = f(u, \\infty) = 0$\n\nTo solve a problem, you need to provide a function that defines the system of equations. This can take one of two forms:\n\n-   A non-mutating function (*out-of-place*), `f(t, p)`, which returns `u`\n-   A mutating function (*in-place*), `f!(u, t, p)`, which mutates the parameter `u`\n\nYou then define either an `IntervalNonlinearProblem`, `NonlinearProblem` or `SteadyStateProblem`, depending on which of the three types of problems above you want to solve.\n\nFinally, you call `solve()` to get the result.\n\nAs a simple demonstration, we shall calculate the boiling point of water, using the Antoine correlation with parameters from NIST. We calculate the boiling point by finding the root of a function that is the difference between the vapour pressure at a specified temperature and 1 atm. We do this in two ways, using the Newton-Raphson method from a starting guess and using the *regula falsi* method to find roots in a specified interval.\n\n``` julia\nusing NonlinearSolve\n\n\"\"\"\n    Calculate the difference between the vapour pressure and 1atm\n\"\"\"\nfunction f(u, p)\n    A, B, C = p\n    return 10^(A - B/(u + C)) - 1.01325\nend\n\n# Antoine parameters from NIST\n# Stull, 1947\np = (4.6543, 1435.264, -64.848)\n\n# Initial guess for NewtonRaphson\nu0 = 373.15\n\n# Specified span for Falsi\nuspan = (370.0, 380.0);\n\nprob = NonlinearProblem(f, u0, p)\nsol = solve(prob, NewtonRaphson()) # u: 373.6009857758806\n\nf(sol.u, p) # 4.121456953498637e-9\n\nprob2 = IntervalNonlinearProblem(f, uspan, p)\nsol2 = solve(prob2, Falsi()) # u: 373.60098565855054\n\nf(sol2.u, p) # -1.5543122344752192e-15\n```\n\nWe can also solve for the steady-state solution of a differential equation:\n\n$$u'(t) = u(t) - u^2(t)$$\n\nwith $u(0) = 1.5$. This ODE will have a steady-state at $u = 1$.\n\n``` julia\nusing NonlinearSolve, DifferentialEquations\n\nfunction ssode(u, p, t)\n    return u - u^2\nend\n\nu0 = 1.5\nprobss = SteadyStateProblem(ssode, u0, nothing)\nsolss = solve(probss, DynamicSS(Vern6())) # u: 1.0000007379583993\n```\n\nWhile this is a simple demonstration of how to solve for an ODE's steady-state, it would have been a lot more efficient to convert the problem to a non-linear equation, rather than using the approach of solving the dynamic ODE problem and running to steady-state.","srcMarkdownNoYaml":"\n\nIt is often required to solve systems of non-linear equations in engineering. As for the the case of systems of linear equations, there are multiple options in Julia.\n\n## Available packages\n\nA popular package is [`NLsolve.jl`](https://github.com/JuliaNLSolvers/NLsolve.jl). This package provides three methods: Trust region, Newton's method with optional line search, and Anderson acceleration. It can also solve fixed-point problems.\n\nAlternatively, you could use [`JuMP`](https://jump.dev/) - a **very** powerful mathematical programming modelling language, built on top of Julia, that can call several free and commercial solvers. In this case, set up a problem with non-linear constraints matching your system and a constant value objective function.\n\nThere are also several less popular packages available.\n\nIn the spirit of not wanting to learn several different interfaces to access options for different algorithms, we shall stick to the SciML package for non-linear systems, [`NonlinearSolve.jl`](https://docs.sciml.ai/NonlinearSolve/stable/).\n\nThis package uses the same interface as [`LinearSolve.jl`](https://docs.sciml.ai/LinearSolve/stable/). It has built-in in algorithms, but is also a unified front-end for other packages, including `NLsolve.jl`.\n\n## NonlinearSolve\n\nThe `NonlinearSolve.jl` package can be used to solve three types of problem:\n\n1.  Interval root-finding (bracketing) problems, where a scalar root is found within a specified interval: find $t ∈ [tₗ, tₕ]$ such that $f(t) = 0$\\\n2.  Solving a system of non-linear equations, i.e. find $\\mathbf{u}$ such that $f(\\mathbf{u}) = \\mathbf{0}$\n3.  Solving steady-state problems, i.e. solve $u' = f(u, t) = f(u, \\infty) = 0$\n\nTo solve a problem, you need to provide a function that defines the system of equations. This can take one of two forms:\n\n-   A non-mutating function (*out-of-place*), `f(t, p)`, which returns `u`\n-   A mutating function (*in-place*), `f!(u, t, p)`, which mutates the parameter `u`\n\nYou then define either an `IntervalNonlinearProblem`, `NonlinearProblem` or `SteadyStateProblem`, depending on which of the three types of problems above you want to solve.\n\nFinally, you call `solve()` to get the result.\n\nAs a simple demonstration, we shall calculate the boiling point of water, using the Antoine correlation with parameters from NIST. We calculate the boiling point by finding the root of a function that is the difference between the vapour pressure at a specified temperature and 1 atm. We do this in two ways, using the Newton-Raphson method from a starting guess and using the *regula falsi* method to find roots in a specified interval.\n\n``` julia\nusing NonlinearSolve\n\n\"\"\"\n    Calculate the difference between the vapour pressure and 1atm\n\"\"\"\nfunction f(u, p)\n    A, B, C = p\n    return 10^(A - B/(u + C)) - 1.01325\nend\n\n# Antoine parameters from NIST\n# Stull, 1947\np = (4.6543, 1435.264, -64.848)\n\n# Initial guess for NewtonRaphson\nu0 = 373.15\n\n# Specified span for Falsi\nuspan = (370.0, 380.0);\n\nprob = NonlinearProblem(f, u0, p)\nsol = solve(prob, NewtonRaphson()) # u: 373.6009857758806\n\nf(sol.u, p) # 4.121456953498637e-9\n\nprob2 = IntervalNonlinearProblem(f, uspan, p)\nsol2 = solve(prob2, Falsi()) # u: 373.60098565855054\n\nf(sol2.u, p) # -1.5543122344752192e-15\n```\n\nWe can also solve for the steady-state solution of a differential equation:\n\n$$u'(t) = u(t) - u^2(t)$$\n\nwith $u(0) = 1.5$. This ODE will have a steady-state at $u = 1$.\n\n``` julia\nusing NonlinearSolve, DifferentialEquations\n\nfunction ssode(u, p, t)\n    return u - u^2\nend\n\nu0 = 1.5\nprobss = SteadyStateProblem(ssode, u0, nothing)\nsolss = solve(probss, DynamicSS(Vern6())) # u: 1.0000007379583993\n```\n\nWhile this is a simple demonstration of how to solve for an ODE's steady-state, it would have been a lot more efficient to convert the problem to a non-linear equation, rather than using the approach of solving the dynamic ODE problem and running to steady-state."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"embed-resources":true,"output-file":"07_Solving_Non-linear_Systems.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"cosmo","monofont":"JetBrains Mono","smooth-scroll":false,"footnotes-hover":true,"title":"Solving Non-linear Systems"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}