{"title":"Modeling Toolkit and Symbolics","markdown":{"yaml":{"title":"Modeling Toolkit and Symbolics"},"headingText":"Symbolics.jl and the Symbolics Ecosystem","containsRefs":false,"markdown":"\n\nUp to now, when we needed to solve a system of ODEs or non-linear equations, for example, we have programmed these and passed them to a solver. If you are comfortable with writing code, this is not a problem. There is however a few tools available in Julia that can make the task a lot easier, both for experienced and novice programmers - a modern Computer Algebra System, [Symbolics.jl](https://symbolics.juliasymbolics.org/stable/).\n\nSymbolics allows you to simply specify the equations for your system and then do symbolic manipulations and simplifications to the system. Since Symbolics is written in pure Julia, it interacts seamlessly with normal Julia code and you can do anything with a symbolic variable you would do with any other Julia variable. This gives great flexibility. It doesn't stop there however - it will also generate a Julia function for you - optimised and parallelised, if specified. \n\nIn addition, there are several other packages that build on Symbolics:\n\n- **ModelingToolkit**: Provides the tools to symbolically specify common numerical systems like ODEs, PDEs, non-linear systems, control problems, causal and acausal modelling etc.\n- **Catalyst**: Provides tools for specifying reaction networks and kinetics\n- **DataDrivenDiffEq**: Automatic identifications of ODEs/DAEs from data\n- **SymbolicRegression**: Genetic programming to find equations from data\n- **ReversePropagation**: Source-to-source mode automatic differentiation\n\n## Using Symbolics\nThis is a very brief introduction to Symbolics. For more detail, refer to the [manual](https://symbolics.juliasymbolics.org/stable/getting_started/).\n\nAt the simples level, Symbolics works with symbolic variables and equations. You specify equations with the `@variables` macro and then simply build equations with these symbolic variables. You can simplify equations, using `simplify()`, define and calculate derivates and jacobians etc. If you are using Symbolics in a Jupyter notebook or in Pluto, the equations will be rendered as $LaTeX$. In the REPL or a script, there will be text output. You can also generate $LaTeX$ expressions with the [Latexify](https://korsbo.github.io/Latexify.jl/stable/) package.\n\n\n```julia\nusing Symbolics\n\n@variables x, y\n# 2-element Vector{Num}:\n#  x\n#  y\n\nz = (x + y)*(x - y)\n\nDx = Differential(x)\n# (::Differential) (generic function with 2 methods)\n\nDy = Differential(y)\n# (::Differential) (generic function with 2 methods)\n\nexpand_derivatives(Dx(z))\n# 2x\n\nexpand_derivatives(Dy(z))\n# -2y\n\nsimplify(2x + x^2 - y - x -2x^2)\n# x - y - (x^2)\n\nA = [x x*y y^2;\n     y 2*x*y x^2*y]\n\n# 2×3 Matrix{Num}:\n#  x   x*y      y^2\n#  y  2x*y  y*(x^2)\n\nlatexify(A)\n# L\"\\begin{equation}\n# \\left[\n# \\begin{array}{ccc}\n# x & x y & y^{2} \\\\\n# y & 2 x y & x^{2} y \\\\\n# \\end{array}\n# \\right]\n# \\end{equation}\n# \"\n```\nThe last result, when rendered in $LaTeX$, or in a Jupyter notebook, for example, looks like this:\n\n$$\n\\begin{equation}\n\\left[\n\\begin{array}{ccc}\nx & x y & y^{2} \\\\\ny & 2 x y & x^{2} y \\\\\n\\end{array}\n\\right]\n\\end{equation}\n$$\n\nSo, we can do basic math and calculus and make pretty equations for reports. What else can we do? Well, a whole lot, as it turns out. Symbolics is a full-featured CAS (Computer Algebra System). Whats more, since it is fully written in Julia, it interacts with the rest of Julia in a pretty seamless manner. Anything you would do with a Julia variable, you can also do with a symbolic (type `Num`) variable.\n\nFor example, we can call a function:\n\n```julia\nf(u) = 2*u[1] - u[2]\n# f (generic function with 1 method)\n\nf([x, y])\n# 2x - y\n```\n\nWe can also define more complicated systems, where the variables are dependent on each other:\n\n```julia\nusing Symbolics, Latexify\n\n@variables t x(t) y(t) # Declare an unknown dependency on t for x and y\n# 3-element Vector{Num}:\n#     t\n#  x(t)\n#  y(t)\n\nz = x*t + y*t^2\n# t*x(t) + (t^2)*y(t)\n\nDt = Differential(t)\n# (::Differential) (generic function with 2 methods)\n\nexpand_derivatives(Dt(z))\n# t*Differential(t)(x(t)) + (t^2)*Differential(t)(y(t)) + 2t*y(t) + x(t)\n\nlatexify(expand_derivatives(Dt(z)))\n# L\"\\begin{equation}\n# t \\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} + t^{2} \\frac{\\mathrm{d} y\\left( t \\right)}{\\mathrm{d}t} + 2 t y\\left( t \\right) + x\\left( t \\right)\n# \\end{equation}\n# \"\n\n```\nWhere the result from the last line is:\n$$\n\\begin{equation}\nt \\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} + t^{2} \\frac{\\mathrm{d} y\\left( t \\right)}{\\mathrm{d}t} + 2 t y\\left( t \\right) + x\\left( t \\right)\n\\end{equation}\n$$\n\nIn other words, since we indicated that `x` and `y` depend on `t`, this information was included in the derivative calculation. \n\nThe final, but most important part of Symbolics is its ability to convert symbolic equations into Julia code.\n\n```julia\n\nusing Symbolics\n\n@variables x y\n# 2-element Vector{Num}:\n#  x\n#  y\n\neqs = [x^2 + y, y^2 + x]\n# 2-element Vector{Num}:\n#  y + x^2\n#  x + y^2)\n\nf_expr = build_function(eqs, [x, y])\nBase.remove_linenums!.(f_expr)\n# (:(function (ˍ₋arg1,)\n#       begin\n#           begin\n#               (SymbolicUtils.Code.create_array)(typeof(ˍ₋arg1), nothing, Val{1}(), Val{(2,)}(), (+)(ˍ₋arg1[2], (^)(ˍ₋arg1[1], 2)), (+)(ˍ₋arg1[1], (^)(ˍ₋arg1[2], 2)))\n#           end\n#       end\n#   end), :(function (ˍ₋out, ˍ₋arg1)\n#       begin\n#           begin\n#               #= C:\\Users\\Braam\\.julia\\packages\\SymbolicUtils\\H684H\\src\\code.jl:399 =# @inbounds begin\n#                       ˍ₋out[1] = (+)(ˍ₋arg1[2], (^)(ˍ₋arg1[1], 2))\n#                       ˍ₋out[2] = (+)(ˍ₋arg1[1], (^)(ˍ₋arg1[2], 2))\n#                       nothing\n#                   end\n#           end\n#       end\n#   end))\n```\n\n:::{.callout-note}\nThe `Base.remove_linenums!()` call just removes a lot of additional line number information form the result to make it more readable. You would not normally bother with this.\n:::\n\nDon't worry if this looks unlike anything related to Julia code you have ever seen. What is returned is a Julia expression string - this is how Julia code is stored internally. It is also what you would generate if you wrote a Julia macro (meta-programming). A macro in Julia is a piece of code that, instead of returning a value, returns another piece of code that is then evaluated. Macros in Julia are normally identified by the `@` symbol, e.g. `@variables`. This is a topic for another chapter.\n\nSo, what is going on here? The first thing to note is that the expression contains a tuple that holds two functions. The first starts with `function (ˍ₋arg1,)`, while the second starts with `function (ˍ₋out, ˍ₋arg1)`. If you look more closely at the code, you will see that the functions (we'll call then `func1` and `func2!` here) are equivalent to:\n\n```julia\nfunction func1(u)\n    return u[2] + u[1]^2, u[1] + u[2]^2\nend \n\nfunction func2!(z, u)\n    z[1] = u[2] + u[1]^2\n    z[2] = u[1] + u[2]^2\nend\n```\nBoth functions will do the same calculations, but `func1` returns the values, which requires allocating an array/tuple to store it in, while `func2!` mutates the first parameter to return the value. These are simply two version of the same function. The first is called an *out-of-place* function and the second, an *in-place* function. Sound familiar? We saw these in the chapter on differential equations.\n\nHow do we use them? We need to tell Julia to evaluate the expression to generate the code:\n\n```julia\nmyf1 = eval(f_expr[1])\n# #7 (generic function with 1 method)\n\nmyf1([1, 2])\n# 2-element Vector{Int64}:\n#  3\n#  5\n\nmyf2! = eval(f_expr[2])\n# #9 (generic function with 1 method)\n\nz = zeros(Int, 2)\n# 2-element Vector{Int64}:\n#  0\n#  0\n\nmyf2!(z, [1, 2])\n\nz\n# 2-element Vector{Int64}:\n#  3\n#  5\n```\n\nThis is the key functionality from Symbolics we want to use. But we won't use it directly. Rather, we shall use the [ModelingToolkit](https://docs.sciml.ai/ModelingToolkit/stable/) package, that builds on Symbolics and makes it easy to specify systems of equations, differential or non-linear, and then solve them with numerical solvers.\n\n## Modeling Toolkit\n### Non-linear system\nLet's start with an example of a simple set of non-linear equations:\n\n$$y = 2x^{2} - 7$$\n$$y = 10\\sqrt{x}$$\n\n![](img/mtkexample1.svg)\n\n```julia\nusing ModelingToolkit, NonlinearSolve\n\n@variables x y\n@parameters a b c\n\neqs = [y ~ a*x^2 - b, y ~ c*√x]\n\n@named nlsys = NonlinearSystem(eqs, [x, y], [a, b, c])\n\ninitial_guess = [x => 3.5, y => 20]\nparams = [a => 2, b => 7, c => 10]\n\nprob = NonlinearProblem(nlsys, initial_guess, params)\nsol = solve(prob, NewtonRaphson())\n\n# u: 2-element Vector{Float64}:\n#   3.6045577280701777\n#  18.98567282997952\n```\n\nHere we load two packages: ModelingToolkit, to set up the problem, and NonlinearSolve, to solve it.\n\nUsing the Symbolics package (this is re-exported by ModelingToolkit - you don't need to explicitly load Symbolics), we specify the variables and parameters for the problem. We could hard code the values of `a`, `b` and `c`, but specifying them as parameters allows to change their values easily later.\n\nWe specify the system of equations as an array, `eqs`. Note that in each symbolic equation, we use `~` instead of `=`. This is simply because Julia has rather strong opinions about you overloading the assignment operator, `=`, in a macro.\n\nNow, there is one new step: we create a `NonlinearSystem`. This is effectively the step were we ask `ModelingToolkit` to create the code for our system of non-linear equations. We pass the array of equations, an array with the variables and an array with the parameters. The latter can also be an empty array, if you hard-coded the parameter values.\n\nYou may wonder why there is `@named` in front of this line...\n\nWe need a variable to refer to the object created by `NonlinearSystem`. Internally, however ModelingToolkit needs to also know what the name of this variable is. You *could* handle this by adding a keyword argument `name` with the same name as the variable (expressed as a Symbol), or you can just use the convenient macro, `@named`, that will handle it for you.\n\nNext, we create a `NonlinearProblem`, just like we did in the chapter on solving non-linear systems. Instead of passing a function that encodes the system of equations, we pass the object created by `NonlinearSystem`. Then we solve the problem, exactly like before.\n\n### Solving ODEs\nThe example above was a fairly straightforward problem. `ModelingToolkit` can however do a lot more for us. To illustrate some of the *magic*, we'll look at an example from the `ModelingToolkit` documentation.\n\nHere we have a system three of ODEs, the first of which is a second order ODE.\n\n$$\\begin{align}\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} =& \\sigma \\left(  - x\\left( t \\right) + y\\left( t \\right) \\right) \\\\\n\\frac{\\mathrm{d} y\\left( t \\right)}{\\mathrm{d}t} =&  - y\\left( t \\right) + \\left( \\rho - z\\left( t \\right) \\right) x\\left( t \\right) \\\\\n\\frac{\\mathrm{d} z\\left( t \\right)}{\\mathrm{d}t} =& x\\left( t \\right) y\\left( t \\right) - \\beta z\\left( t \\right)\n\\end{align}$$\n\n```julia\nusing ModelingToolkit, DifferentialEquations, Plots\n\n@parameters σ ρ β\n@variables t x(t) y(t) z(t)\nD = Differential(t)\n\neqs = [D(D(x)) ~ σ * (y - x),\n    D(y) ~ x * (ρ - z) - y,\n    D(z) ~ x * y - β * z]\n\n@named sys = ODESystem(eqs)\n\nsys = structural_simplify(sys)\n\nu0 = [D(x) => 2.0,\n    x => 1.0,\n    y => 0.0,\n    z => 0.0]\n\np = [σ => 28.0,\n    ρ => 10.0,\n    β => 8 / 3]\n\ntspan = (0.0, 100.0)\nprob = ODEProblem(sys, u0, tspan, p, jac = true)\nsol = solve(prob, Tsit5())\n\nplot(sol, idxs = (x, y))\n```\n\nJust like before, we specify the variables and parameters. We then, again, specify an array of equations. As discussed above in the section on `Symbolics`, we use `Differential` to specify the derivatives. A second (or higher) derivative is simply a nested call of this function.\n\nLike in our previous example, we now need to ask `ModelingToolkit` to build the code for our system of ODEs. This is done with a call to `ODESystem`. This time, the call to ODESystem looks a lot simpler. Where are the specifications for the variables and parameters?\n\nAs it happens, the full call would be:\n\n```julia\n@named sys = ODESystem(eqs, t, [x, y, z], [σ, ρ, β])\n```\n\nThe parameters are the equations, the independent variables, the dependent variables and the parameters. `ModelingToolkit` is clever enough to figure out which is which for ODESystems. This doesn't work for `NonlinearSystems` yet, but one would imaging this functionality is on its way.\n\nThe next part is where the magic happens:\n\n```julia\nsys = structural_simplify(sys)\n```\n\nWe call the all-singing, all-dancing `structural_simplify()`, which is really the heart of `ModelingToolkit`. It will do a whole host of transformations of your system, using everything available in `Symbolics`. Let's look at the intermediate results to understand what it is doing for us:\n\n```julia\n@named sys = ODESystem(eqs, t, [x, y, z], [σ, ρ, β])\n\n# Model sys with 3 equations\n# States (3):\n#   x(t)\n#   y(t)\n#   z(t)\n# Parameters (3):\n#   σ\n#   ρ\n#   β\n\nsys = structural_simplify(sys)\n\n# Model sys with 4 equations\n# States (4):\n#   y(t)\n#   z(t)\n#   x(t)\n#   xˍt(t)       \n# Parameters (3):\n#   σ\n#   ρ\n#   β\n# Incidence matrix:4×9 SparseArrays.SparseMatrixCSC{Num, Int64} with 13 stored entries:\n#  ×  ×  ×  ⋅  ⋅  ⋅  ×  ⋅  ⋅\n#  ×  ×  ×  ⋅  ⋅  ⋅  ⋅  ×  ⋅\n#  ⋅  ⋅  ⋅  ×  ⋅  ×  ⋅  ⋅  ⋅\n#  ×  ⋅  ×  ⋅  ⋅  ⋅  ⋅  ⋅  ×\n\nequations(sys)\n\n# 4-element Vector{Equation}:\n#  Differential(t)(y(t)) ~ (ρ - z(t))*x(t) - y(t)\n#  Differential(t)(z(t)) ~ x(t)*y(t) - β*z(t)\n#  Differential(t)(x(t)) ~ xˍt(t)\n#  Differential(t)(xˍt(t)) ~ xˍtt(t)\n```\n\nFrom the results of each line, you can see that `structural_simplify()` has converted our system of three first and second order ODEs into a system of four first order ODEs. We can inspect these equations with the `equations()` function, and get the pretty versions with `latexify()`:\n\n$$\\begin{align}\n\\frac{\\mathrm{d} y\\left( t \\right)}{\\mathrm{d}t} =&  - y\\left( t \\right) + \\left( \\rho - z\\left( t \\right) \\right) x\\left( t \\right) \\\\\n\\frac{\\mathrm{d} z\\left( t \\right)}{\\mathrm{d}t} =& x\\left( t \\right) y\\left( t \\right) - \\beta z\\left( t \\right) \\\\\n\\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} =& xˍt\\left( t \\right) \\\\\n\\frac{\\mathrm{d} xˍt\\left( t \\right)}{\\mathrm{d}t} =& xˍtt\\left( t \\right)\n\\end{align}$$\n\nWait a minute! Aren't we missing some details on the last two equations? What is `x_tt(t)` defined as? For reasons that are as clear as mud, you need to also call `observed(sys)` to see the missing bits:\n\n```julia\nobserved(sys)\n# 1-element Vector{Equation}:\n#  xˍtt(t) ~ σ*(y(t) - x(t))\n```\n\nThe rest of the code should be familiar. We specify the initial values and the time span for the integration, create an ODEProblem and call the solver. The only part that will be new is in the call to `ODEProblem`:\n\n```julia\nprob = ODEProblem(sys, u0, tspan, p, jac = true)\n```\n\nWe have added the keyword parameter `jac = true`. This tells the ODE solver that we have also specified the Jacobian matrix of the system, which was done automatically, and symbolically, for you by `ModelingToolkit`. This can greatly enhance the solving of difficult systems.\n\nThen we solve the problem and finally, we plot the results:\n\n![](img/mtkexample2.svg)\n\nThis was a very short introduction to Symbolics and ModelingToolkit. There is a lot more to learn in the documentation, including several tutorials.\n","srcMarkdownNoYaml":"\n\nUp to now, when we needed to solve a system of ODEs or non-linear equations, for example, we have programmed these and passed them to a solver. If you are comfortable with writing code, this is not a problem. There is however a few tools available in Julia that can make the task a lot easier, both for experienced and novice programmers - a modern Computer Algebra System, [Symbolics.jl](https://symbolics.juliasymbolics.org/stable/).\n\n## Symbolics.jl and the Symbolics Ecosystem\nSymbolics allows you to simply specify the equations for your system and then do symbolic manipulations and simplifications to the system. Since Symbolics is written in pure Julia, it interacts seamlessly with normal Julia code and you can do anything with a symbolic variable you would do with any other Julia variable. This gives great flexibility. It doesn't stop there however - it will also generate a Julia function for you - optimised and parallelised, if specified. \n\nIn addition, there are several other packages that build on Symbolics:\n\n- **ModelingToolkit**: Provides the tools to symbolically specify common numerical systems like ODEs, PDEs, non-linear systems, control problems, causal and acausal modelling etc.\n- **Catalyst**: Provides tools for specifying reaction networks and kinetics\n- **DataDrivenDiffEq**: Automatic identifications of ODEs/DAEs from data\n- **SymbolicRegression**: Genetic programming to find equations from data\n- **ReversePropagation**: Source-to-source mode automatic differentiation\n\n## Using Symbolics\nThis is a very brief introduction to Symbolics. For more detail, refer to the [manual](https://symbolics.juliasymbolics.org/stable/getting_started/).\n\nAt the simples level, Symbolics works with symbolic variables and equations. You specify equations with the `@variables` macro and then simply build equations with these symbolic variables. You can simplify equations, using `simplify()`, define and calculate derivates and jacobians etc. If you are using Symbolics in a Jupyter notebook or in Pluto, the equations will be rendered as $LaTeX$. In the REPL or a script, there will be text output. You can also generate $LaTeX$ expressions with the [Latexify](https://korsbo.github.io/Latexify.jl/stable/) package.\n\n\n```julia\nusing Symbolics\n\n@variables x, y\n# 2-element Vector{Num}:\n#  x\n#  y\n\nz = (x + y)*(x - y)\n\nDx = Differential(x)\n# (::Differential) (generic function with 2 methods)\n\nDy = Differential(y)\n# (::Differential) (generic function with 2 methods)\n\nexpand_derivatives(Dx(z))\n# 2x\n\nexpand_derivatives(Dy(z))\n# -2y\n\nsimplify(2x + x^2 - y - x -2x^2)\n# x - y - (x^2)\n\nA = [x x*y y^2;\n     y 2*x*y x^2*y]\n\n# 2×3 Matrix{Num}:\n#  x   x*y      y^2\n#  y  2x*y  y*(x^2)\n\nlatexify(A)\n# L\"\\begin{equation}\n# \\left[\n# \\begin{array}{ccc}\n# x & x y & y^{2} \\\\\n# y & 2 x y & x^{2} y \\\\\n# \\end{array}\n# \\right]\n# \\end{equation}\n# \"\n```\nThe last result, when rendered in $LaTeX$, or in a Jupyter notebook, for example, looks like this:\n\n$$\n\\begin{equation}\n\\left[\n\\begin{array}{ccc}\nx & x y & y^{2} \\\\\ny & 2 x y & x^{2} y \\\\\n\\end{array}\n\\right]\n\\end{equation}\n$$\n\nSo, we can do basic math and calculus and make pretty equations for reports. What else can we do? Well, a whole lot, as it turns out. Symbolics is a full-featured CAS (Computer Algebra System). Whats more, since it is fully written in Julia, it interacts with the rest of Julia in a pretty seamless manner. Anything you would do with a Julia variable, you can also do with a symbolic (type `Num`) variable.\n\nFor example, we can call a function:\n\n```julia\nf(u) = 2*u[1] - u[2]\n# f (generic function with 1 method)\n\nf([x, y])\n# 2x - y\n```\n\nWe can also define more complicated systems, where the variables are dependent on each other:\n\n```julia\nusing Symbolics, Latexify\n\n@variables t x(t) y(t) # Declare an unknown dependency on t for x and y\n# 3-element Vector{Num}:\n#     t\n#  x(t)\n#  y(t)\n\nz = x*t + y*t^2\n# t*x(t) + (t^2)*y(t)\n\nDt = Differential(t)\n# (::Differential) (generic function with 2 methods)\n\nexpand_derivatives(Dt(z))\n# t*Differential(t)(x(t)) + (t^2)*Differential(t)(y(t)) + 2t*y(t) + x(t)\n\nlatexify(expand_derivatives(Dt(z)))\n# L\"\\begin{equation}\n# t \\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} + t^{2} \\frac{\\mathrm{d} y\\left( t \\right)}{\\mathrm{d}t} + 2 t y\\left( t \\right) + x\\left( t \\right)\n# \\end{equation}\n# \"\n\n```\nWhere the result from the last line is:\n$$\n\\begin{equation}\nt \\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} + t^{2} \\frac{\\mathrm{d} y\\left( t \\right)}{\\mathrm{d}t} + 2 t y\\left( t \\right) + x\\left( t \\right)\n\\end{equation}\n$$\n\nIn other words, since we indicated that `x` and `y` depend on `t`, this information was included in the derivative calculation. \n\nThe final, but most important part of Symbolics is its ability to convert symbolic equations into Julia code.\n\n```julia\n\nusing Symbolics\n\n@variables x y\n# 2-element Vector{Num}:\n#  x\n#  y\n\neqs = [x^2 + y, y^2 + x]\n# 2-element Vector{Num}:\n#  y + x^2\n#  x + y^2)\n\nf_expr = build_function(eqs, [x, y])\nBase.remove_linenums!.(f_expr)\n# (:(function (ˍ₋arg1,)\n#       begin\n#           begin\n#               (SymbolicUtils.Code.create_array)(typeof(ˍ₋arg1), nothing, Val{1}(), Val{(2,)}(), (+)(ˍ₋arg1[2], (^)(ˍ₋arg1[1], 2)), (+)(ˍ₋arg1[1], (^)(ˍ₋arg1[2], 2)))\n#           end\n#       end\n#   end), :(function (ˍ₋out, ˍ₋arg1)\n#       begin\n#           begin\n#               #= C:\\Users\\Braam\\.julia\\packages\\SymbolicUtils\\H684H\\src\\code.jl:399 =# @inbounds begin\n#                       ˍ₋out[1] = (+)(ˍ₋arg1[2], (^)(ˍ₋arg1[1], 2))\n#                       ˍ₋out[2] = (+)(ˍ₋arg1[1], (^)(ˍ₋arg1[2], 2))\n#                       nothing\n#                   end\n#           end\n#       end\n#   end))\n```\n\n:::{.callout-note}\nThe `Base.remove_linenums!()` call just removes a lot of additional line number information form the result to make it more readable. You would not normally bother with this.\n:::\n\nDon't worry if this looks unlike anything related to Julia code you have ever seen. What is returned is a Julia expression string - this is how Julia code is stored internally. It is also what you would generate if you wrote a Julia macro (meta-programming). A macro in Julia is a piece of code that, instead of returning a value, returns another piece of code that is then evaluated. Macros in Julia are normally identified by the `@` symbol, e.g. `@variables`. This is a topic for another chapter.\n\nSo, what is going on here? The first thing to note is that the expression contains a tuple that holds two functions. The first starts with `function (ˍ₋arg1,)`, while the second starts with `function (ˍ₋out, ˍ₋arg1)`. If you look more closely at the code, you will see that the functions (we'll call then `func1` and `func2!` here) are equivalent to:\n\n```julia\nfunction func1(u)\n    return u[2] + u[1]^2, u[1] + u[2]^2\nend \n\nfunction func2!(z, u)\n    z[1] = u[2] + u[1]^2\n    z[2] = u[1] + u[2]^2\nend\n```\nBoth functions will do the same calculations, but `func1` returns the values, which requires allocating an array/tuple to store it in, while `func2!` mutates the first parameter to return the value. These are simply two version of the same function. The first is called an *out-of-place* function and the second, an *in-place* function. Sound familiar? We saw these in the chapter on differential equations.\n\nHow do we use them? We need to tell Julia to evaluate the expression to generate the code:\n\n```julia\nmyf1 = eval(f_expr[1])\n# #7 (generic function with 1 method)\n\nmyf1([1, 2])\n# 2-element Vector{Int64}:\n#  3\n#  5\n\nmyf2! = eval(f_expr[2])\n# #9 (generic function with 1 method)\n\nz = zeros(Int, 2)\n# 2-element Vector{Int64}:\n#  0\n#  0\n\nmyf2!(z, [1, 2])\n\nz\n# 2-element Vector{Int64}:\n#  3\n#  5\n```\n\nThis is the key functionality from Symbolics we want to use. But we won't use it directly. Rather, we shall use the [ModelingToolkit](https://docs.sciml.ai/ModelingToolkit/stable/) package, that builds on Symbolics and makes it easy to specify systems of equations, differential or non-linear, and then solve them with numerical solvers.\n\n## Modeling Toolkit\n### Non-linear system\nLet's start with an example of a simple set of non-linear equations:\n\n$$y = 2x^{2} - 7$$\n$$y = 10\\sqrt{x}$$\n\n![](img/mtkexample1.svg)\n\n```julia\nusing ModelingToolkit, NonlinearSolve\n\n@variables x y\n@parameters a b c\n\neqs = [y ~ a*x^2 - b, y ~ c*√x]\n\n@named nlsys = NonlinearSystem(eqs, [x, y], [a, b, c])\n\ninitial_guess = [x => 3.5, y => 20]\nparams = [a => 2, b => 7, c => 10]\n\nprob = NonlinearProblem(nlsys, initial_guess, params)\nsol = solve(prob, NewtonRaphson())\n\n# u: 2-element Vector{Float64}:\n#   3.6045577280701777\n#  18.98567282997952\n```\n\nHere we load two packages: ModelingToolkit, to set up the problem, and NonlinearSolve, to solve it.\n\nUsing the Symbolics package (this is re-exported by ModelingToolkit - you don't need to explicitly load Symbolics), we specify the variables and parameters for the problem. We could hard code the values of `a`, `b` and `c`, but specifying them as parameters allows to change their values easily later.\n\nWe specify the system of equations as an array, `eqs`. Note that in each symbolic equation, we use `~` instead of `=`. This is simply because Julia has rather strong opinions about you overloading the assignment operator, `=`, in a macro.\n\nNow, there is one new step: we create a `NonlinearSystem`. This is effectively the step were we ask `ModelingToolkit` to create the code for our system of non-linear equations. We pass the array of equations, an array with the variables and an array with the parameters. The latter can also be an empty array, if you hard-coded the parameter values.\n\nYou may wonder why there is `@named` in front of this line...\n\nWe need a variable to refer to the object created by `NonlinearSystem`. Internally, however ModelingToolkit needs to also know what the name of this variable is. You *could* handle this by adding a keyword argument `name` with the same name as the variable (expressed as a Symbol), or you can just use the convenient macro, `@named`, that will handle it for you.\n\nNext, we create a `NonlinearProblem`, just like we did in the chapter on solving non-linear systems. Instead of passing a function that encodes the system of equations, we pass the object created by `NonlinearSystem`. Then we solve the problem, exactly like before.\n\n### Solving ODEs\nThe example above was a fairly straightforward problem. `ModelingToolkit` can however do a lot more for us. To illustrate some of the *magic*, we'll look at an example from the `ModelingToolkit` documentation.\n\nHere we have a system three of ODEs, the first of which is a second order ODE.\n\n$$\\begin{align}\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} =& \\sigma \\left(  - x\\left( t \\right) + y\\left( t \\right) \\right) \\\\\n\\frac{\\mathrm{d} y\\left( t \\right)}{\\mathrm{d}t} =&  - y\\left( t \\right) + \\left( \\rho - z\\left( t \\right) \\right) x\\left( t \\right) \\\\\n\\frac{\\mathrm{d} z\\left( t \\right)}{\\mathrm{d}t} =& x\\left( t \\right) y\\left( t \\right) - \\beta z\\left( t \\right)\n\\end{align}$$\n\n```julia\nusing ModelingToolkit, DifferentialEquations, Plots\n\n@parameters σ ρ β\n@variables t x(t) y(t) z(t)\nD = Differential(t)\n\neqs = [D(D(x)) ~ σ * (y - x),\n    D(y) ~ x * (ρ - z) - y,\n    D(z) ~ x * y - β * z]\n\n@named sys = ODESystem(eqs)\n\nsys = structural_simplify(sys)\n\nu0 = [D(x) => 2.0,\n    x => 1.0,\n    y => 0.0,\n    z => 0.0]\n\np = [σ => 28.0,\n    ρ => 10.0,\n    β => 8 / 3]\n\ntspan = (0.0, 100.0)\nprob = ODEProblem(sys, u0, tspan, p, jac = true)\nsol = solve(prob, Tsit5())\n\nplot(sol, idxs = (x, y))\n```\n\nJust like before, we specify the variables and parameters. We then, again, specify an array of equations. As discussed above in the section on `Symbolics`, we use `Differential` to specify the derivatives. A second (or higher) derivative is simply a nested call of this function.\n\nLike in our previous example, we now need to ask `ModelingToolkit` to build the code for our system of ODEs. This is done with a call to `ODESystem`. This time, the call to ODESystem looks a lot simpler. Where are the specifications for the variables and parameters?\n\nAs it happens, the full call would be:\n\n```julia\n@named sys = ODESystem(eqs, t, [x, y, z], [σ, ρ, β])\n```\n\nThe parameters are the equations, the independent variables, the dependent variables and the parameters. `ModelingToolkit` is clever enough to figure out which is which for ODESystems. This doesn't work for `NonlinearSystems` yet, but one would imaging this functionality is on its way.\n\nThe next part is where the magic happens:\n\n```julia\nsys = structural_simplify(sys)\n```\n\nWe call the all-singing, all-dancing `structural_simplify()`, which is really the heart of `ModelingToolkit`. It will do a whole host of transformations of your system, using everything available in `Symbolics`. Let's look at the intermediate results to understand what it is doing for us:\n\n```julia\n@named sys = ODESystem(eqs, t, [x, y, z], [σ, ρ, β])\n\n# Model sys with 3 equations\n# States (3):\n#   x(t)\n#   y(t)\n#   z(t)\n# Parameters (3):\n#   σ\n#   ρ\n#   β\n\nsys = structural_simplify(sys)\n\n# Model sys with 4 equations\n# States (4):\n#   y(t)\n#   z(t)\n#   x(t)\n#   xˍt(t)       \n# Parameters (3):\n#   σ\n#   ρ\n#   β\n# Incidence matrix:4×9 SparseArrays.SparseMatrixCSC{Num, Int64} with 13 stored entries:\n#  ×  ×  ×  ⋅  ⋅  ⋅  ×  ⋅  ⋅\n#  ×  ×  ×  ⋅  ⋅  ⋅  ⋅  ×  ⋅\n#  ⋅  ⋅  ⋅  ×  ⋅  ×  ⋅  ⋅  ⋅\n#  ×  ⋅  ×  ⋅  ⋅  ⋅  ⋅  ⋅  ×\n\nequations(sys)\n\n# 4-element Vector{Equation}:\n#  Differential(t)(y(t)) ~ (ρ - z(t))*x(t) - y(t)\n#  Differential(t)(z(t)) ~ x(t)*y(t) - β*z(t)\n#  Differential(t)(x(t)) ~ xˍt(t)\n#  Differential(t)(xˍt(t)) ~ xˍtt(t)\n```\n\nFrom the results of each line, you can see that `structural_simplify()` has converted our system of three first and second order ODEs into a system of four first order ODEs. We can inspect these equations with the `equations()` function, and get the pretty versions with `latexify()`:\n\n$$\\begin{align}\n\\frac{\\mathrm{d} y\\left( t \\right)}{\\mathrm{d}t} =&  - y\\left( t \\right) + \\left( \\rho - z\\left( t \\right) \\right) x\\left( t \\right) \\\\\n\\frac{\\mathrm{d} z\\left( t \\right)}{\\mathrm{d}t} =& x\\left( t \\right) y\\left( t \\right) - \\beta z\\left( t \\right) \\\\\n\\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} =& xˍt\\left( t \\right) \\\\\n\\frac{\\mathrm{d} xˍt\\left( t \\right)}{\\mathrm{d}t} =& xˍtt\\left( t \\right)\n\\end{align}$$\n\nWait a minute! Aren't we missing some details on the last two equations? What is `x_tt(t)` defined as? For reasons that are as clear as mud, you need to also call `observed(sys)` to see the missing bits:\n\n```julia\nobserved(sys)\n# 1-element Vector{Equation}:\n#  xˍtt(t) ~ σ*(y(t) - x(t))\n```\n\nThe rest of the code should be familiar. We specify the initial values and the time span for the integration, create an ODEProblem and call the solver. The only part that will be new is in the call to `ODEProblem`:\n\n```julia\nprob = ODEProblem(sys, u0, tspan, p, jac = true)\n```\n\nWe have added the keyword parameter `jac = true`. This tells the ODE solver that we have also specified the Jacobian matrix of the system, which was done automatically, and symbolically, for you by `ModelingToolkit`. This can greatly enhance the solving of difficult systems.\n\nThen we solve the problem and finally, we plot the results:\n\n![](img/mtkexample2.svg)\n\nThis was a very short introduction to Symbolics and ModelingToolkit. There is a lot more to learn in the documentation, including several tutorials.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"embed-resources":true,"output-file":"11_Modelling_Toolkit_and_Symbolics.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"cosmo","monofont":"JetBrains Mono","smooth-scroll":false,"footnotes-hover":true,"title":"Modeling Toolkit and Symbolics"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}