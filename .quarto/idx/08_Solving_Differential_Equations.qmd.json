{"title":"Solving Differential Equations","markdown":{"yaml":{"title":"Solving Differential Equations"},"headingText":"Available packages for ODEs and PDEs","containsRefs":false,"markdown":"\n\n\nThe [DifferentialEquations](https://docs.sciml.ai/DiffEqDocs/stable/) package is a very powerful toolkit for solving differential equations. It has multiple, state of the art solvers for ordinary differential equations. It can also handle stochastic differential equations, random differential equations, delay differential equations, differential algebraic equations, stochastic differential algebraic equations etc.\n\nShould you wish to solve partial differential equations, you will need to convert the PDE to a set of ODEs. This can be done via the method of lines ([MethodOfLines.jl](https://github.com/SciML/MethodOfLines.jl)), or via several other advanced tools in Julia, including [Trixi.jl](https://trixi-framework.github.io/Trixi.jl/stable/) or several other finite element methods [see JuliaFEM](http://www.juliafem.org/).\n\nHere we shall focus on the most common applications in process modelling, solving systems of ordinary differential equations. In a later section, we shall look at using the method of lines to solve partial differential equations, along with specifying the equations in symbolic form.\n\n## System of ODEs - Solving a Plug Flow Reactor Model\n\nFor our ODE example, we take a simple PFR model and a kinetic model.\n\n$$ A + B \\rightarrow C$$\n\nwith the reaction proceeding in the gas phase over a catalyst with the following rate equation:\n\n$$-r_A = k_o exp \\Big[\\frac{E_a}{R}(1/T - 1/T_o)\\Big] P_A P_B$$ $$[-r_A] = kmol/h/kg$$\n\nWe also have the following data:\n\n| Parameter |             Value             |\n|:----------|:-----------------------------:|\n| $k_o$     | $0.5 \\frac{kmol}{h.kg.bar^2}$ |\n| $E_a$     |         $100\\ J/mol$          |\n| $T_o$     |           $500\\ K$            |\n| $R$       |       $8.314\\ J/mol/K$        |\n\nThe feed stream entering the reactor has 60kmol/h of A and 40kmol/h of B. The reactor is isothermal at 510K. The inlet pressure is 10bar(abs) and the pressure drop is 1bar. Calculate the composition profile for the reactor.\n\nIn order to solve the problem, we need to tell the solver what the set of ODEs is for each of the molar flows. We already know the equation for the rate of change for A as it flows over the catalyst. Stoichiometry gives us the rate of change for B and C.\n\nWe package this information into a function, `rates(u, p, t)`, which is what we will supply to the solver.\n\nThe differential equation solver will accept two forms of functions:\n\n`rates(u, p, t)` is a function that takes the current values of the dependent variable(s), model parameter(s), `p` and the current value of the independent variable, `t`, and then returns the differential(s) of the dependent variable(s) at that point.\n\n`u` can be a vector or a scalar. `p` should be any iterable type, but is usually passed as a tuple, since this will give faster code than passing a vector.\n\nThe alternative form, called the *in-place* form, is `rates!(du, u, p, t)`. In this case, `du` is a scalar or vector that holds the derivative(s) and is updated in the function. This in-place version typically results in faster code, as there are fewer memory allocation needed. This should be your default form for specifying ordinary differential equations. The exclamation mark (bang, for our American friends) is just a Julia convention to indicate that this is a *mutating* function, i.e. it modifies one or more of its parameters. Again by convention, this is will usually be the first parameter, `du`. You do not *have* to add the exclamation mark to the function name, but this is definitely the preferred thing to do.\n\n``` julia\nusing DifferentialEquations, Plots\n\n\"\"\"\nThe reactions rates for A + B -> C\n    u:  array with the molar flows of A, B and C\n    p:  tuple with P and T\n    t:  position in the reactor 0..L\n\"\"\"\nfunction rates!(du, u, p, t)\n    k₀ = 0.50\n    Eₐ = 100.0\n    T₀ = 500.0\n    R = 8.314\n    \n    # Convert molar flows to molar fractions\n    y = u ./ sum(u)\n\n    # Unpack the tuple to get pressure and temperature\n    P₀, ΔP, T, tmax = p\n\n    P = P₀ - t/tmax*ΔP\n    k = k₀ * exp(-Eₐ/R * (1/T - 1/T₀))\n    rA = -k * y[1] * y[2] * P^2\n    rB = rA\n    rC = -rA\n\n    du[1] = rA\n    du[2] = rB\n    du[3] = rC\nend\n\n# Set up the input values and pack into a tuple of parameters\nT = 510.0\nP = 10.0\nΔP = 1.0\ntmax = 20.0\np = (P, ΔP, T, tmax)\n\n# The starting values for the initial value problem\nu₀ = [60.0, 40.0, 0.0]\n\n# The span over which to integrate - here the mass of catalyst\ntspan = (0.0, tmax)\n\n# Create the ODEProblem object\nprob = ODEProblem(rates!, u₀, tspan, p)\n\n# Solve with the default solver\nsol = solve(prob)\n\n# Plot the result - the molar flows vs the mass of catalyst\nplot(sol, leg=:right)\nsavefig(\"img/ODEmol.svg\")\n```\n\n![The plot of `sol.u` vs `sol.t`, generated by \\`plot(sol)](img/ODEmol.svg)\n\nThe default plot recipe (defined by the DifferentialEquations package) will plot each of the dependent variables against the independent variable. All we need to do is call `plot(sol)`. Here, the default placement of the legend was interfering with the lines, so we move it to the right centre, by adding `leg = :right`) to the call to `plot()`.\n\nNow we have solved the set of three differential equations and we have the molar flows of each component at various points along the length of the reactor. The points were set by the variable step-size solver. There are *many* options you can pass the solver, including fixed steps at which to record the values. See the [documentation](https://docs.sciml.ai/DiffEqDocs/stable/) for details.\n\nPart of what is returned in the `sol` structure is an interpolator. If we want to have the molar flows at **any** point in the reactor, we need only call `sol(x)` to get the values of the dependent variables (`sol.u`) at a value `x` of the independent variable (`sol.t`). `sol` is a callable structure, sometimes called a *functor*.\n\n``` julia\nsol(5.123)\n# 3-element Vector{Float64}:\n#  28.55013685340714\n#   8.550136853407144\n#  31.44986314659286\n```\n\nThe original question however was for the composition, which is generally interpreted as the fractions of the components, not their flows. Let's convert the results to molar fractions:\n\n``` julia\n# Now, we want to plot the molar fractions...\n# Copy over the independent values (sol.t) into our x array (optional)\nx = sol.t\n\n# For each entry in sol.u, sum up the molar flows - we get an array of values\n# with the total molar flow at every point in the reactor\ntotflows = sum.(sol.u)\n\n# Now divide the individual flows with the total. \nfracs = sol.u ./ totflows\n\n# We get the same structure as sol.u - an array of arrays.\n# We need to flatten this to plot it.\ny = hcat(fracs...)'\nplot(x,y, labels=[\"A\" \"B\" \"C\"])\n```\n\n![The plot of molar fractions in the reactor profile](img/ODEfrac.svg)\n\nThe last bit of code in this part will need some explanation. As mentioned above, the solution returned by the ODE solver is a structure, `sol` with multiple fields, including `sol.t` for the independent variable. This will hold the values for each step taken by the solver. The results for the dependent variables, `u[...]` are in `sol.u`, for each the steps in `t`. This means that `sol.u` is an array of arrays:\n\n``` julia\nsol.u\n# 17-element Vector{Vector{Float64}}:\n#  [60.0, 40.0, 0.0]\n#  [59.99858583839893, 39.99858583839893, 0.001414161601070281]  \n#  [59.984446697061045, 39.984446697061045, 0.015553302938956699]\n#  [59.84330258351507, 39.84330258351507, 0.15669741648493382]   \n#  [58.45642225894246, 38.45642225894246, 1.543577741057545]     \n#  ⋮\n#  [21.04774569180567, 1.0477456918056731, 38.952254308194334]\n#  [20.551956292857035, 0.5519562928570385, 39.44804370714297]\n#  [20.282897789407816, 0.2828977894078193, 39.71710221059219]\n#  [20.20298976079487, 0.20298976079487502, 39.79701023920513]\n```\n\nWe can to convert these to molar fractions, which means we need to divide each entry of the sub-arrays by the sum of that sub-array. This is very easy in Julia. We just do this:\n\n``` julia\ntotflows = sum.(sol.u)\nfracs = sol.u ./ totflows\n```\n\nWe *broadcast* the `sum()` function over `sol.u` by inserting a period between the function name and the first parenthesis - `sum.()`. This means the function is applied individually to each element in `sol.u`. Since each entry of `sol.u` is an array, we therefore get the an array of the total molar flows at each point in the reactor.\n\nNow we want to divide each entry in each sub-array in `sol.u` with this sum to get the molar fractions at each point. We do this by broadcasting again. For functions the period is inserted between the function name and the parenthesis, but for operators, the period is put in front of the operator. The broadcast, or element-wise, division will divide each entry in `fracs` (an array of molar flows) by the corresponding entry in `totflows`. The result in an array of arrays, just like `sol.u`, but with the molar fractions instead of molar flows.\n\n``` julia\ntotflows = sum.(sol.u)\n# 17-element Vector{Float64}:\n#  100.0\n#   99.99858583839894\n#   99.98444669706105\n#   99.84330258351507\n#   98.45642225894247\n#    ⋮\n#   61.04774569180567\n#   60.55195629285704\n#   60.282897789407826\n#   60.20298976079488\n\nfracs = sol.u ./ totflows\n# 17-element Vector{Vector{Float64}}:\n#  [0.6, 0.4, 0.0]\n#  [0.5999943432736005, 0.3999915149104007, 1.4141815998834358e-5]\n#  [0.5999377771105296, 0.3999066656657945, 0.0001555572236758087]\n#  [0.5993722266294071, 0.3990583399441108, 0.0015694334264820865]\n#  [0.5937288895710717, 0.39059333435660765, 0.015677776072320636]\n#  ⋮\n#  [0.34477515022525834, 0.01716272533788762, 0.6380621244368541]\n#  [0.339410277571518, 0.009115416357277122, 0.6514743060712049]\n#  [0.33646189107006863, 0.0046928366051030585, 0.6588452723248283]\n#  [0.3355811703217333, 0.0033717554826000534, 0.6610470741956666]\n```\n\nThe plotting library expects you to pass the x-values as an array and when there are multiple y-values, these should be in a matrix where each column is a series. We therefore need to convert the array of arrays into a matrix.\n\nThis is done with `y = hcat(fracs...)'`, which uses two new Julia concepts.\n\nThe first is *splatting*. If a function, say `f(a, b, c)` takes three scalar parameters, we can *splat* an array into the function by calling `f(d...)`, where d is an array. The first entry in `d` will be passed into `a`, the second into `b` and the rest of the array into `c`. If `d` had only three entries, `c` will be a scalar, else `c` will be a tuple.\n\nThe opposite of splatting is *slurping*, when multiple scalars are slurped up into a single array parameter. It uses the same syntax of an ellipsis.\n\nWhat happens here is that the `hcat()` function (horizontal concatenation) expects a series of values that will be concatenated as the columns of a new array. We pass it the `fracs` variable, which is an array of arrays, and we splat it. This means that `hcat()` gets a series of inputs, one for each row in `fracs`. These are then concatenated as follows:\n\n``` julia\nhcat(fracs...)\n# 3×17 Matrix{Float64}:\n#  0.6  0.599994    0.599938     0.599372    0.593729   0.574037   0.540935  0.502011  …  0.391779   0.369135  0.354054   0.344775   0.33941     0.336462    0.335581\n#  0.4  0.399992    0.399907     0.399058    0.390593   0.361056   0.311402  0.253017     0.0876678  0.053702  0.0310817  0.0171627  0.00911542  0.00469284  0.00337176       \n#  0.0  1.41418e-5  0.000155557  0.00156943  0.0156778  0.0649074  0.147664  0.244972     0.520554   0.577163  0.614864   0.638062   0.651474    0.658845    0.661047\n```\n\nWhy use `hcat()` and not `vcat()`? Remember that a 1D array in Julia is considered to be a column vector. This means `fracs` is a column vector where each entry is also a column vector. If we `vcat` fracs, these individual column vectors get appended to each other in one long column vector and we lose the distinction between the individual points along the reactor:\n\n``` julia\nvcat(fracs...)\n# 51-element Vector{Float64}:\n#  0.6\n#  0.4\n#  0.0\n#  0.5999943432702689\n#  0.3999915149054033\n#  1.4141824327869601e-5\n#  0.5999377767074147\n#  ⋮\n#  0.33587562016618194\n#  0.00381343024927297\n#  0.6603109495845451\n#  0.33464693236081094\n#  0.0019703985412164293\n#  0.6633826690979727\n```\n\nBut the `hcat(fracs...)` call horizontally concatenated the sub-arrays (column vectors), making each series (species) a row of the matrix. We need each series (species) to be a column. We get that by transposing the result with the `'` appended to the end. `A'` is the transposed version of a real matrix, `A`\n\n::: callout-important\n`A'` is technically the **adjoint** matrix. This means it is the transpose of the matrix of complex conjugates. For real values, however, this makes no difference. For complex values, you need to call `transpose()`, rather than use the adjoint operator, if you want the transpose.\n:::\n\n``` julia\ny = hcat(fracs...)'\n# 17×3 adjoint(::Matrix{Float64}) with eltype Float64:\n#  0.6       0.4         0.0\n#  0.599994  0.399992    1.41418e-5\n#  0.599938  0.399907    0.000155557\n#  0.599372  0.399058    0.00156943\n#  0.593729  0.390593    0.0156778\n#  ⋮\n#  0.344775  0.0171627   0.638062\n#  0.33941   0.00911542  0.651474\n#  0.336462  0.00469284  0.658845\n#  0.335581  0.00337176  0.661047\n```\n\nFinally we get:\n\n``` julia\ny = hcat(fracs...)'\n# 17×3 adjoint(::Matrix{Float64}) with eltype Float64:\n#  0.6       0.4         0.0\n#  0.599994  0.399992    1.41418e-5\n#  0.599938  0.399907    0.000155558\n#  0.599372  0.399058    0.00156954\n#  0.593725  0.390587    0.015688\n#  0.573817  0.360726    0.0654572\n#  0.540162  0.310243    0.149596\n#  ⋮\n#  0.366919  0.0503788   0.582702\n#  0.352276  0.0284133   0.619311\n#  0.343461  0.0151917   0.641347\n#  0.338506  0.00775872  0.653735\n#  0.335876  0.00381343  0.660311\n#  0.334647  0.0019704   0.663383\n```\n\n::: callout-note\nNote that the type returned is an `adjoint(::Matrix{Float64})`. This is a *lazy* structure. It just maps onto the original matrix, rather than recalculate it, for better efficiency.\n:::\n\nNow we have each series as a column and we pass the series labels as a **row vector** (with spaces between the entries, not commas), since each series must also be a column in the `labels` parameter.","srcMarkdownNoYaml":"\n\n## Available packages for ODEs and PDEs\n\nThe [DifferentialEquations](https://docs.sciml.ai/DiffEqDocs/stable/) package is a very powerful toolkit for solving differential equations. It has multiple, state of the art solvers for ordinary differential equations. It can also handle stochastic differential equations, random differential equations, delay differential equations, differential algebraic equations, stochastic differential algebraic equations etc.\n\nShould you wish to solve partial differential equations, you will need to convert the PDE to a set of ODEs. This can be done via the method of lines ([MethodOfLines.jl](https://github.com/SciML/MethodOfLines.jl)), or via several other advanced tools in Julia, including [Trixi.jl](https://trixi-framework.github.io/Trixi.jl/stable/) or several other finite element methods [see JuliaFEM](http://www.juliafem.org/).\n\nHere we shall focus on the most common applications in process modelling, solving systems of ordinary differential equations. In a later section, we shall look at using the method of lines to solve partial differential equations, along with specifying the equations in symbolic form.\n\n## System of ODEs - Solving a Plug Flow Reactor Model\n\nFor our ODE example, we take a simple PFR model and a kinetic model.\n\n$$ A + B \\rightarrow C$$\n\nwith the reaction proceeding in the gas phase over a catalyst with the following rate equation:\n\n$$-r_A = k_o exp \\Big[\\frac{E_a}{R}(1/T - 1/T_o)\\Big] P_A P_B$$ $$[-r_A] = kmol/h/kg$$\n\nWe also have the following data:\n\n| Parameter |             Value             |\n|:----------|:-----------------------------:|\n| $k_o$     | $0.5 \\frac{kmol}{h.kg.bar^2}$ |\n| $E_a$     |         $100\\ J/mol$          |\n| $T_o$     |           $500\\ K$            |\n| $R$       |       $8.314\\ J/mol/K$        |\n\nThe feed stream entering the reactor has 60kmol/h of A and 40kmol/h of B. The reactor is isothermal at 510K. The inlet pressure is 10bar(abs) and the pressure drop is 1bar. Calculate the composition profile for the reactor.\n\nIn order to solve the problem, we need to tell the solver what the set of ODEs is for each of the molar flows. We already know the equation for the rate of change for A as it flows over the catalyst. Stoichiometry gives us the rate of change for B and C.\n\nWe package this information into a function, `rates(u, p, t)`, which is what we will supply to the solver.\n\nThe differential equation solver will accept two forms of functions:\n\n`rates(u, p, t)` is a function that takes the current values of the dependent variable(s), model parameter(s), `p` and the current value of the independent variable, `t`, and then returns the differential(s) of the dependent variable(s) at that point.\n\n`u` can be a vector or a scalar. `p` should be any iterable type, but is usually passed as a tuple, since this will give faster code than passing a vector.\n\nThe alternative form, called the *in-place* form, is `rates!(du, u, p, t)`. In this case, `du` is a scalar or vector that holds the derivative(s) and is updated in the function. This in-place version typically results in faster code, as there are fewer memory allocation needed. This should be your default form for specifying ordinary differential equations. The exclamation mark (bang, for our American friends) is just a Julia convention to indicate that this is a *mutating* function, i.e. it modifies one or more of its parameters. Again by convention, this is will usually be the first parameter, `du`. You do not *have* to add the exclamation mark to the function name, but this is definitely the preferred thing to do.\n\n``` julia\nusing DifferentialEquations, Plots\n\n\"\"\"\nThe reactions rates for A + B -> C\n    u:  array with the molar flows of A, B and C\n    p:  tuple with P and T\n    t:  position in the reactor 0..L\n\"\"\"\nfunction rates!(du, u, p, t)\n    k₀ = 0.50\n    Eₐ = 100.0\n    T₀ = 500.0\n    R = 8.314\n    \n    # Convert molar flows to molar fractions\n    y = u ./ sum(u)\n\n    # Unpack the tuple to get pressure and temperature\n    P₀, ΔP, T, tmax = p\n\n    P = P₀ - t/tmax*ΔP\n    k = k₀ * exp(-Eₐ/R * (1/T - 1/T₀))\n    rA = -k * y[1] * y[2] * P^2\n    rB = rA\n    rC = -rA\n\n    du[1] = rA\n    du[2] = rB\n    du[3] = rC\nend\n\n# Set up the input values and pack into a tuple of parameters\nT = 510.0\nP = 10.0\nΔP = 1.0\ntmax = 20.0\np = (P, ΔP, T, tmax)\n\n# The starting values for the initial value problem\nu₀ = [60.0, 40.0, 0.0]\n\n# The span over which to integrate - here the mass of catalyst\ntspan = (0.0, tmax)\n\n# Create the ODEProblem object\nprob = ODEProblem(rates!, u₀, tspan, p)\n\n# Solve with the default solver\nsol = solve(prob)\n\n# Plot the result - the molar flows vs the mass of catalyst\nplot(sol, leg=:right)\nsavefig(\"img/ODEmol.svg\")\n```\n\n![The plot of `sol.u` vs `sol.t`, generated by \\`plot(sol)](img/ODEmol.svg)\n\nThe default plot recipe (defined by the DifferentialEquations package) will plot each of the dependent variables against the independent variable. All we need to do is call `plot(sol)`. Here, the default placement of the legend was interfering with the lines, so we move it to the right centre, by adding `leg = :right`) to the call to `plot()`.\n\nNow we have solved the set of three differential equations and we have the molar flows of each component at various points along the length of the reactor. The points were set by the variable step-size solver. There are *many* options you can pass the solver, including fixed steps at which to record the values. See the [documentation](https://docs.sciml.ai/DiffEqDocs/stable/) for details.\n\nPart of what is returned in the `sol` structure is an interpolator. If we want to have the molar flows at **any** point in the reactor, we need only call `sol(x)` to get the values of the dependent variables (`sol.u`) at a value `x` of the independent variable (`sol.t`). `sol` is a callable structure, sometimes called a *functor*.\n\n``` julia\nsol(5.123)\n# 3-element Vector{Float64}:\n#  28.55013685340714\n#   8.550136853407144\n#  31.44986314659286\n```\n\nThe original question however was for the composition, which is generally interpreted as the fractions of the components, not their flows. Let's convert the results to molar fractions:\n\n``` julia\n# Now, we want to plot the molar fractions...\n# Copy over the independent values (sol.t) into our x array (optional)\nx = sol.t\n\n# For each entry in sol.u, sum up the molar flows - we get an array of values\n# with the total molar flow at every point in the reactor\ntotflows = sum.(sol.u)\n\n# Now divide the individual flows with the total. \nfracs = sol.u ./ totflows\n\n# We get the same structure as sol.u - an array of arrays.\n# We need to flatten this to plot it.\ny = hcat(fracs...)'\nplot(x,y, labels=[\"A\" \"B\" \"C\"])\n```\n\n![The plot of molar fractions in the reactor profile](img/ODEfrac.svg)\n\nThe last bit of code in this part will need some explanation. As mentioned above, the solution returned by the ODE solver is a structure, `sol` with multiple fields, including `sol.t` for the independent variable. This will hold the values for each step taken by the solver. The results for the dependent variables, `u[...]` are in `sol.u`, for each the steps in `t`. This means that `sol.u` is an array of arrays:\n\n``` julia\nsol.u\n# 17-element Vector{Vector{Float64}}:\n#  [60.0, 40.0, 0.0]\n#  [59.99858583839893, 39.99858583839893, 0.001414161601070281]  \n#  [59.984446697061045, 39.984446697061045, 0.015553302938956699]\n#  [59.84330258351507, 39.84330258351507, 0.15669741648493382]   \n#  [58.45642225894246, 38.45642225894246, 1.543577741057545]     \n#  ⋮\n#  [21.04774569180567, 1.0477456918056731, 38.952254308194334]\n#  [20.551956292857035, 0.5519562928570385, 39.44804370714297]\n#  [20.282897789407816, 0.2828977894078193, 39.71710221059219]\n#  [20.20298976079487, 0.20298976079487502, 39.79701023920513]\n```\n\nWe can to convert these to molar fractions, which means we need to divide each entry of the sub-arrays by the sum of that sub-array. This is very easy in Julia. We just do this:\n\n``` julia\ntotflows = sum.(sol.u)\nfracs = sol.u ./ totflows\n```\n\nWe *broadcast* the `sum()` function over `sol.u` by inserting a period between the function name and the first parenthesis - `sum.()`. This means the function is applied individually to each element in `sol.u`. Since each entry of `sol.u` is an array, we therefore get the an array of the total molar flows at each point in the reactor.\n\nNow we want to divide each entry in each sub-array in `sol.u` with this sum to get the molar fractions at each point. We do this by broadcasting again. For functions the period is inserted between the function name and the parenthesis, but for operators, the period is put in front of the operator. The broadcast, or element-wise, division will divide each entry in `fracs` (an array of molar flows) by the corresponding entry in `totflows`. The result in an array of arrays, just like `sol.u`, but with the molar fractions instead of molar flows.\n\n``` julia\ntotflows = sum.(sol.u)\n# 17-element Vector{Float64}:\n#  100.0\n#   99.99858583839894\n#   99.98444669706105\n#   99.84330258351507\n#   98.45642225894247\n#    ⋮\n#   61.04774569180567\n#   60.55195629285704\n#   60.282897789407826\n#   60.20298976079488\n\nfracs = sol.u ./ totflows\n# 17-element Vector{Vector{Float64}}:\n#  [0.6, 0.4, 0.0]\n#  [0.5999943432736005, 0.3999915149104007, 1.4141815998834358e-5]\n#  [0.5999377771105296, 0.3999066656657945, 0.0001555572236758087]\n#  [0.5993722266294071, 0.3990583399441108, 0.0015694334264820865]\n#  [0.5937288895710717, 0.39059333435660765, 0.015677776072320636]\n#  ⋮\n#  [0.34477515022525834, 0.01716272533788762, 0.6380621244368541]\n#  [0.339410277571518, 0.009115416357277122, 0.6514743060712049]\n#  [0.33646189107006863, 0.0046928366051030585, 0.6588452723248283]\n#  [0.3355811703217333, 0.0033717554826000534, 0.6610470741956666]\n```\n\nThe plotting library expects you to pass the x-values as an array and when there are multiple y-values, these should be in a matrix where each column is a series. We therefore need to convert the array of arrays into a matrix.\n\nThis is done with `y = hcat(fracs...)'`, which uses two new Julia concepts.\n\nThe first is *splatting*. If a function, say `f(a, b, c)` takes three scalar parameters, we can *splat* an array into the function by calling `f(d...)`, where d is an array. The first entry in `d` will be passed into `a`, the second into `b` and the rest of the array into `c`. If `d` had only three entries, `c` will be a scalar, else `c` will be a tuple.\n\nThe opposite of splatting is *slurping*, when multiple scalars are slurped up into a single array parameter. It uses the same syntax of an ellipsis.\n\nWhat happens here is that the `hcat()` function (horizontal concatenation) expects a series of values that will be concatenated as the columns of a new array. We pass it the `fracs` variable, which is an array of arrays, and we splat it. This means that `hcat()` gets a series of inputs, one for each row in `fracs`. These are then concatenated as follows:\n\n``` julia\nhcat(fracs...)\n# 3×17 Matrix{Float64}:\n#  0.6  0.599994    0.599938     0.599372    0.593729   0.574037   0.540935  0.502011  …  0.391779   0.369135  0.354054   0.344775   0.33941     0.336462    0.335581\n#  0.4  0.399992    0.399907     0.399058    0.390593   0.361056   0.311402  0.253017     0.0876678  0.053702  0.0310817  0.0171627  0.00911542  0.00469284  0.00337176       \n#  0.0  1.41418e-5  0.000155557  0.00156943  0.0156778  0.0649074  0.147664  0.244972     0.520554   0.577163  0.614864   0.638062   0.651474    0.658845    0.661047\n```\n\nWhy use `hcat()` and not `vcat()`? Remember that a 1D array in Julia is considered to be a column vector. This means `fracs` is a column vector where each entry is also a column vector. If we `vcat` fracs, these individual column vectors get appended to each other in one long column vector and we lose the distinction between the individual points along the reactor:\n\n``` julia\nvcat(fracs...)\n# 51-element Vector{Float64}:\n#  0.6\n#  0.4\n#  0.0\n#  0.5999943432702689\n#  0.3999915149054033\n#  1.4141824327869601e-5\n#  0.5999377767074147\n#  ⋮\n#  0.33587562016618194\n#  0.00381343024927297\n#  0.6603109495845451\n#  0.33464693236081094\n#  0.0019703985412164293\n#  0.6633826690979727\n```\n\nBut the `hcat(fracs...)` call horizontally concatenated the sub-arrays (column vectors), making each series (species) a row of the matrix. We need each series (species) to be a column. We get that by transposing the result with the `'` appended to the end. `A'` is the transposed version of a real matrix, `A`\n\n::: callout-important\n`A'` is technically the **adjoint** matrix. This means it is the transpose of the matrix of complex conjugates. For real values, however, this makes no difference. For complex values, you need to call `transpose()`, rather than use the adjoint operator, if you want the transpose.\n:::\n\n``` julia\ny = hcat(fracs...)'\n# 17×3 adjoint(::Matrix{Float64}) with eltype Float64:\n#  0.6       0.4         0.0\n#  0.599994  0.399992    1.41418e-5\n#  0.599938  0.399907    0.000155557\n#  0.599372  0.399058    0.00156943\n#  0.593729  0.390593    0.0156778\n#  ⋮\n#  0.344775  0.0171627   0.638062\n#  0.33941   0.00911542  0.651474\n#  0.336462  0.00469284  0.658845\n#  0.335581  0.00337176  0.661047\n```\n\nFinally we get:\n\n``` julia\ny = hcat(fracs...)'\n# 17×3 adjoint(::Matrix{Float64}) with eltype Float64:\n#  0.6       0.4         0.0\n#  0.599994  0.399992    1.41418e-5\n#  0.599938  0.399907    0.000155558\n#  0.599372  0.399058    0.00156954\n#  0.593725  0.390587    0.015688\n#  0.573817  0.360726    0.0654572\n#  0.540162  0.310243    0.149596\n#  ⋮\n#  0.366919  0.0503788   0.582702\n#  0.352276  0.0284133   0.619311\n#  0.343461  0.0151917   0.641347\n#  0.338506  0.00775872  0.653735\n#  0.335876  0.00381343  0.660311\n#  0.334647  0.0019704   0.663383\n```\n\n::: callout-note\nNote that the type returned is an `adjoint(::Matrix{Float64})`. This is a *lazy* structure. It just maps onto the original matrix, rather than recalculate it, for better efficiency.\n:::\n\nNow we have each series as a column and we pass the series labels as a **row vector** (with spaces between the entries, not commas), since each series must also be a column in the `labels` parameter."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"embed-resources":true,"output-file":"08_Solving_Differential_Equations.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"cosmo","monofont":"JetBrains Mono","smooth-scroll":false,"footnotes-hover":true,"title":"Solving Differential Equations"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}