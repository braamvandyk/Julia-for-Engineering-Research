{
  "hash": "6e8a1300a9b70ad1fbaecf98b73dfe3f",
  "result": {
    "markdown": "---\ntitle: \"Solving Non-linear Systems\"\n---\n\nIt is often required to solve systems of non-linear equations in engineering. As for the the case of systems of linear equations, there are multiple options in Julia.\n\n## Available packages\n\nA popular package is [`NLsolve.jl`](https://github.com/JuliaNLSolvers/NLsolve.jl). This package provides three methods: Trust region, Newton's method with optional line search, and Anderson acceleration. It can also solve fixed-point problems.\n\nAlternatively, you could use [`JuMP`](https://jump.dev/) - a **very** powerful mathematical programming modeling language, built on top of Julia, that can call several free and commercial solvers. In this case, set up a problem with non-linear constraints matching your system and a constant value objective function.\n\nThere are also several less popular packages available.\n\nIn the spirit of not wanting to learn several different interfaces to access options for different algorithms, we shall stick to the SciML package for non-linear systems, [`NonlinearSolve.jl`](https://docs.sciml.ai/NonlinearSolve/stable/).\n\nThis package uses the same interface as [`LinearSolve.jl`](https://docs.sciml.ai/LinearSolve/stable/). It has built-in in algorithms, but is also a unified front-end for other packages, including `NLsolve.jl`.\n\n## NonlinearSolve\n\nThe `NonlinearSolve.jl` package can be used to solve three types of problem:\n\n1.  Interval root-finding (bracketing) problems, where a scalar root is found within a specified interval: find $t ∈ [tₗ, tₕ]$ such that $f(t) = 0$\\\n2.  Solving a system of non-linear equations, i.e. find $\\mathbf{u}$ such that $f(\\mathbf{u}) = \\mathbf{0}$\n3.  Solving stead-state problems, i.e. solve $u' = f(u, t) = f(u, \\infty) = 0$\n\nTo solve a problem, you need to provide a function that defines the system of equations. This can take one of two forms:\n\n-   A non-mutating function, `f(t, p)`, which returns `u`\n-   A mutating function, `f!(u, t, p)`, which mutates the parameter `u`\n\nYou then define either an `IntervalNonlinearProblem`, `NonlinearProblem` or `SteadyStateProblem`, depending on which of the three types of problems above you want to solve.\n\nFinally, you call `solve()` to get the result.\n\nAs a simple demonstration, we shall calculate the boiling point of water, using the Antoine correlation with parameters from NIST. We calculate the boiling point by finding the root of a function that is the difference between the vapour pressure at a specified temperature and 1 atm. We do this in two ways, using the Newton-Raphson method from a starting guess and using the regula falsi method to find roots in a specified interval.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing NonlinearSolve\n\n\"\"\"\n    Calculate the difference between the vapour pressure and 1atm\n\"\"\"\nfunction f(u, p)\n    A, B, C = p\n    return 10^(A - B/(u + C)) - 1.01325\nend\n\n# Antoine parameters from NIST\n# Stull, 1947\np = (4.6543, 1435.264, -64.848)\n\n# Initial guess for NewtonRaphson\nu0 = 373.15\n\n# Specified span for Falsi\nuspan = (370.0, 380.0);\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nprob = NonlinearProblem(f, u0, p)\nsol = solve(prob, NewtonRaphson())\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nu: 373.6009857758806\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nf(sol.u, p)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n4.121456953498637e-9\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nprob2 = IntervalNonlinearProblem(f, uspan, p)\nsol2 = solve(prob2, Falsi())\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nu: 373.60098565855054\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nf(sol2.u, p)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n-1.5543122344752192e-15\n```\n:::\n:::\n\n\nWe can also solve for the steady-state solution of a differential equation:\n\n$$u'(t) = u(t) - u^2(t)$$\n\nwith $u(0) = 1.5$. This ODE will have a steady-state at $u = 0$.\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nusing NonlinearSolve, DifferentialEquations\n\nfunction ssode(u, p, t)\n    return u - u^2\nend\n\nu0 = 1.5\nprobss = SteadyStateProblem(ssode, u0, nothing)\nsolss = solve(probss, DynamicSS(Vern6()))\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nu: 1.0000007379583993\n```\n:::\n:::\n\n\nWhile this is a simple demonstration of how to solve for an ODE's steady-state, it would have been a lot more efficient to convert the problem to a non-linear equation, rather than using the approach of solving the dynamic ODE problem and running to steady-state.\n\n",
    "supporting": [
      "07_Solving_Non-linear_Systems_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}